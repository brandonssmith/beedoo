{"ast":null,"code":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport { addClassNamesToElement, isHTMLAnchorElement, $findMatchingParent } from '@lexical/utils';\nimport { createCommand, ElementNode, $isRangeSelection, $applyNodeReplacement, $isElementNode, $getSelection, $isNodeSelection, $normalizeSelection__EXPERIMENTAL, $setSelection } from 'lexical';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n// Do not require this module directly! Use normal `invariant` calls.\n\nfunction formatDevErrorMessage(message) {\n  throw new Error(message);\n}\nconst SUPPORTED_URL_PROTOCOLS = new Set(['http:', 'https:', 'mailto:', 'sms:', 'tel:']);\n\n/** @noInheritDoc */\nclass LinkNode extends ElementNode {\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  static getType() {\n    return 'link';\n  }\n  static clone(node) {\n    return new LinkNode(node.__url, {\n      rel: node.__rel,\n      target: node.__target,\n      title: node.__title\n    }, node.__key);\n  }\n  constructor(url = '', attributes = {}, key) {\n    super(key);\n    const {\n      target = null,\n      rel = null,\n      title = null\n    } = attributes;\n    this.__url = url;\n    this.__target = target;\n    this.__rel = rel;\n    this.__title = title;\n  }\n  createDOM(config) {\n    const element = document.createElement('a');\n    this.updateLinkDOM(null, element, config);\n    addClassNamesToElement(element, config.theme.link);\n    return element;\n  }\n  updateLinkDOM(prevNode, anchor, config) {\n    if (isHTMLAnchorElement(anchor)) {\n      if (!prevNode || prevNode.__url !== this.__url) {\n        anchor.href = this.sanitizeUrl(this.__url);\n      }\n      for (const attr of ['target', 'rel', 'title']) {\n        const key = `__${attr}`;\n        const value = this[key];\n        if (!prevNode || prevNode[key] !== value) {\n          if (value) {\n            anchor[attr] = value;\n          } else {\n            anchor.removeAttribute(attr);\n          }\n        }\n      }\n    }\n  }\n  updateDOM(prevNode, anchor, config) {\n    this.updateLinkDOM(prevNode, anchor, config);\n    return false;\n  }\n  static importDOM() {\n    return {\n      a: node => ({\n        conversion: $convertAnchorElement,\n        priority: 1\n      })\n    };\n  }\n  static importJSON(serializedNode) {\n    return $createLinkNode().updateFromJSON(serializedNode);\n  }\n  updateFromJSON(serializedNode) {\n    return super.updateFromJSON(serializedNode).setURL(serializedNode.url).setRel(serializedNode.rel || null).setTarget(serializedNode.target || null).setTitle(serializedNode.title || null);\n  }\n  sanitizeUrl(url) {\n    url = formatUrl(url);\n    try {\n      const parsedUrl = new URL(formatUrl(url));\n      // eslint-disable-next-line no-script-url\n      if (!SUPPORTED_URL_PROTOCOLS.has(parsedUrl.protocol)) {\n        return 'about:blank';\n      }\n    } catch (_unused) {\n      return url;\n    }\n    return url;\n  }\n  exportJSON() {\n    return {\n      ...super.exportJSON(),\n      rel: this.getRel(),\n      target: this.getTarget(),\n      title: this.getTitle(),\n      url: this.getURL()\n    };\n  }\n  getURL() {\n    return this.getLatest().__url;\n  }\n  setURL(url) {\n    const writable = this.getWritable();\n    writable.__url = url;\n    return writable;\n  }\n  getTarget() {\n    return this.getLatest().__target;\n  }\n  setTarget(target) {\n    const writable = this.getWritable();\n    writable.__target = target;\n    return writable;\n  }\n  getRel() {\n    return this.getLatest().__rel;\n  }\n  setRel(rel) {\n    const writable = this.getWritable();\n    writable.__rel = rel;\n    return writable;\n  }\n  getTitle() {\n    return this.getLatest().__title;\n  }\n  setTitle(title) {\n    const writable = this.getWritable();\n    writable.__title = title;\n    return writable;\n  }\n  insertNewAfter(_, restoreSelection = true) {\n    const linkNode = $createLinkNode(this.__url, {\n      rel: this.__rel,\n      target: this.__target,\n      title: this.__title\n    });\n    this.insertAfter(linkNode, restoreSelection);\n    return linkNode;\n  }\n  canInsertTextBefore() {\n    return false;\n  }\n  canInsertTextAfter() {\n    return false;\n  }\n  canBeEmpty() {\n    return false;\n  }\n  isInline() {\n    return true;\n  }\n  extractWithChild(child, selection, destination) {\n    if (!$isRangeSelection(selection)) {\n      return false;\n    }\n    const anchorNode = selection.anchor.getNode();\n    const focusNode = selection.focus.getNode();\n    return this.isParentOf(anchorNode) && this.isParentOf(focusNode) && selection.getTextContent().length > 0;\n  }\n  isEmailURI() {\n    return this.__url.startsWith('mailto:');\n  }\n  isWebSiteURI() {\n    return this.__url.startsWith('https://') || this.__url.startsWith('http://');\n  }\n}\nfunction $convertAnchorElement(domNode) {\n  let node = null;\n  if (isHTMLAnchorElement(domNode)) {\n    const content = domNode.textContent;\n    if (content !== null && content !== '' || domNode.children.length > 0) {\n      node = $createLinkNode(domNode.getAttribute('href') || '', {\n        rel: domNode.getAttribute('rel'),\n        target: domNode.getAttribute('target'),\n        title: domNode.getAttribute('title')\n      });\n    }\n  }\n  return {\n    node\n  };\n}\n\n/**\n * Takes a URL and creates a LinkNode.\n * @param url - The URL the LinkNode should direct to.\n * @param attributes - Optional HTML a tag attributes \\\\{ target, rel, title \\\\}\n * @returns The LinkNode.\n */\nfunction $createLinkNode(url = '', attributes) {\n  return $applyNodeReplacement(new LinkNode(url, attributes));\n}\n\n/**\n * Determines if node is a LinkNode.\n * @param node - The node to be checked.\n * @returns true if node is a LinkNode, false otherwise.\n */\nfunction $isLinkNode(node) {\n  return node instanceof LinkNode;\n}\n// Custom node type to override `canInsertTextAfter` that will\n// allow typing within the link\nclass AutoLinkNode extends LinkNode {\n  /** @internal */\n  /** Indicates whether the autolink was ever unlinked. **/\n\n  constructor(url = '', attributes = {}, key) {\n    super(url, attributes, key);\n    this.__isUnlinked = attributes.isUnlinked !== undefined && attributes.isUnlinked !== null ? attributes.isUnlinked : false;\n  }\n  static getType() {\n    return 'autolink';\n  }\n  static clone(node) {\n    return new AutoLinkNode(node.__url, {\n      isUnlinked: node.__isUnlinked,\n      rel: node.__rel,\n      target: node.__target,\n      title: node.__title\n    }, node.__key);\n  }\n  getIsUnlinked() {\n    return this.__isUnlinked;\n  }\n  setIsUnlinked(value) {\n    const self = this.getWritable();\n    self.__isUnlinked = value;\n    return self;\n  }\n  createDOM(config) {\n    if (this.__isUnlinked) {\n      return document.createElement('span');\n    } else {\n      return super.createDOM(config);\n    }\n  }\n  updateDOM(prevNode, anchor, config) {\n    return super.updateDOM(prevNode, anchor, config) || prevNode.__isUnlinked !== this.__isUnlinked;\n  }\n  static importJSON(serializedNode) {\n    return $createAutoLinkNode().updateFromJSON(serializedNode);\n  }\n  updateFromJSON(serializedNode) {\n    return super.updateFromJSON(serializedNode).setIsUnlinked(serializedNode.isUnlinked || false);\n  }\n  static importDOM() {\n    // TODO: Should link node should handle the import over autolink?\n    return null;\n  }\n  exportJSON() {\n    return {\n      ...super.exportJSON(),\n      isUnlinked: this.__isUnlinked\n    };\n  }\n  insertNewAfter(selection, restoreSelection = true) {\n    const element = this.getParentOrThrow().insertNewAfter(selection, restoreSelection);\n    if ($isElementNode(element)) {\n      const linkNode = $createAutoLinkNode(this.__url, {\n        isUnlinked: this.__isUnlinked,\n        rel: this.__rel,\n        target: this.__target,\n        title: this.__title\n      });\n      element.append(linkNode);\n      return linkNode;\n    }\n    return null;\n  }\n}\n\n/**\n * Takes a URL and creates an AutoLinkNode. AutoLinkNodes are generally automatically generated\n * during typing, which is especially useful when a button to generate a LinkNode is not practical.\n * @param url - The URL the LinkNode should direct to.\n * @param attributes - Optional HTML a tag attributes. \\\\{ target, rel, title \\\\}\n * @returns The LinkNode.\n */\nfunction $createAutoLinkNode(url = '', attributes) {\n  return $applyNodeReplacement(new AutoLinkNode(url, attributes));\n}\n\n/**\n * Determines if node is an AutoLinkNode.\n * @param node - The node to be checked.\n * @returns true if node is an AutoLinkNode, false otherwise.\n */\nfunction $isAutoLinkNode(node) {\n  return node instanceof AutoLinkNode;\n}\nconst TOGGLE_LINK_COMMAND = createCommand('TOGGLE_LINK_COMMAND');\nfunction $getPointNode(point, offset) {\n  if (point.type === 'element') {\n    const node = point.getNode();\n    if (!$isElementNode(node)) {\n      formatDevErrorMessage(`$getPointNode: element point is not an ElementNode`);\n    }\n    const childNode = node.getChildren()[point.offset + offset];\n    return childNode || null;\n  }\n  return null;\n}\n\n/**\n * Preserve the logical start/end of a RangeSelection in situations where\n * the point is an element that may be reparented in the callback.\n *\n * @param $fn The function to run\n * @returns The result of the callback\n */\nfunction $withSelectedNodes($fn) {\n  const initialSelection = $getSelection();\n  if (!$isRangeSelection(initialSelection)) {\n    return $fn();\n  }\n  const normalized = $normalizeSelection__EXPERIMENTAL(initialSelection);\n  const isBackwards = normalized.isBackward();\n  const anchorNode = $getPointNode(normalized.anchor, isBackwards ? -1 : 0);\n  const focusNode = $getPointNode(normalized.focus, isBackwards ? 0 : -1);\n  const rval = $fn();\n  if (anchorNode || focusNode) {\n    const updatedSelection = $getSelection();\n    if ($isRangeSelection(updatedSelection)) {\n      const finalSelection = updatedSelection.clone();\n      if (anchorNode) {\n        const anchorParent = anchorNode.getParent();\n        if (anchorParent) {\n          finalSelection.anchor.set(anchorParent.getKey(), anchorNode.getIndexWithinParent() + (isBackwards ? 1 : 0), 'element');\n        }\n      }\n      if (focusNode) {\n        const focusParent = focusNode.getParent();\n        if (focusParent) {\n          finalSelection.focus.set(focusParent.getKey(), focusNode.getIndexWithinParent() + (isBackwards ? 0 : 1), 'element');\n        }\n      }\n      $setSelection($normalizeSelection__EXPERIMENTAL(finalSelection));\n    }\n  }\n  return rval;\n}\n\n/**\n * Generates or updates a LinkNode. It can also delete a LinkNode if the URL is null,\n * but saves any children and brings them up to the parent node.\n * @param url - The URL the link directs to.\n * @param attributes - Optional HTML a tag attributes. \\\\{ target, rel, title \\\\}\n */\nfunction $toggleLink(url, attributes = {}) {\n  const {\n    target,\n    title\n  } = attributes;\n  const rel = attributes.rel === undefined ? 'noreferrer' : attributes.rel;\n  const selection = $getSelection();\n  if (selection === null || !$isRangeSelection(selection) && !$isNodeSelection(selection)) {\n    return;\n  }\n  if ($isNodeSelection(selection)) {\n    const nodes = selection.getNodes();\n    if (nodes.length === 0) {\n      return;\n    }\n\n    // Handle all selected nodes\n    nodes.forEach(node => {\n      if (url === null) {\n        // Remove link\n        const linkParent = $findMatchingParent(node, parent => !$isAutoLinkNode(parent) && $isLinkNode(parent));\n        if (linkParent) {\n          linkParent.insertBefore(node);\n          if (linkParent.getChildren().length === 0) {\n            linkParent.remove();\n          }\n        }\n      } else {\n        // Add/Update link\n        const existingLink = $findMatchingParent(node, parent => !$isAutoLinkNode(parent) && $isLinkNode(parent));\n        if (existingLink) {\n          existingLink.setURL(url);\n          if (target !== undefined) {\n            existingLink.setTarget(target);\n          }\n          if (rel !== undefined) {\n            existingLink.setRel(rel);\n          }\n        } else {\n          const linkNode = $createLinkNode(url, {\n            rel,\n            target\n          });\n          node.insertBefore(linkNode);\n          linkNode.append(node);\n        }\n      }\n    });\n    return;\n  }\n\n  // Handle RangeSelection\n  const nodes = selection.extract();\n  if (url === null) {\n    // Remove LinkNodes\n    nodes.forEach(node => {\n      const parentLink = $findMatchingParent(node, parent => !$isAutoLinkNode(parent) && $isLinkNode(parent));\n      if (parentLink) {\n        const children = parentLink.getChildren();\n        for (let i = 0; i < children.length; i++) {\n          parentLink.insertBefore(children[i]);\n        }\n        parentLink.remove();\n      }\n    });\n    return;\n  }\n  const updatedNodes = new Set();\n  const updateLinkNode = linkNode => {\n    if (updatedNodes.has(linkNode.getKey())) {\n      return;\n    }\n    updatedNodes.add(linkNode.getKey());\n    linkNode.setURL(url);\n    if (target !== undefined) {\n      linkNode.setTarget(target);\n    }\n    if (rel !== undefined) {\n      linkNode.setRel(rel);\n    }\n    if (title !== undefined) {\n      linkNode.setTitle(title);\n    }\n  };\n  // Add or merge LinkNodes\n  if (nodes.length === 1) {\n    const firstNode = nodes[0];\n    // if the first node is a LinkNode or if its\n    // parent is a LinkNode, we update the URL, target and rel.\n    const linkNode = $getAncestor(firstNode, $isLinkNode);\n    if (linkNode !== null) {\n      return updateLinkNode(linkNode);\n    }\n  }\n  $withSelectedNodes(() => {\n    let linkNode = null;\n    for (const node of nodes) {\n      if (!node.isAttached()) {\n        continue;\n      }\n      const parentLinkNode = $getAncestor(node, $isLinkNode);\n      if (parentLinkNode) {\n        updateLinkNode(parentLinkNode);\n        continue;\n      }\n      if ($isElementNode(node)) {\n        if (!node.isInline()) {\n          // Ignore block nodes, if there are any children we will see them\n          // later and wrap in a new LinkNode\n          continue;\n        }\n        if ($isLinkNode(node)) {\n          // If it's not an autolink node and we don't already have a LinkNode\n          // in this block then we can update it and re-use it\n          if (!$isAutoLinkNode(node) && (linkNode === null || !linkNode.getParentOrThrow().isParentOf(node))) {\n            updateLinkNode(node);\n            linkNode = node;\n            continue;\n          }\n          // Unwrap LinkNode, we already have one or it's an AutoLinkNode\n          for (const child of node.getChildren()) {\n            node.insertBefore(child);\n          }\n          node.remove();\n          continue;\n        }\n      }\n      const prevLinkNode = node.getPreviousSibling();\n      if ($isLinkNode(prevLinkNode) && prevLinkNode.is(linkNode)) {\n        prevLinkNode.append(node);\n        continue;\n      }\n      linkNode = $createLinkNode(url, {\n        rel,\n        target,\n        title\n      });\n      node.insertAfter(linkNode);\n      linkNode.append(node);\n    }\n  });\n}\n/** @deprecated renamed to {@link $toggleLink} by @lexical/eslint-plugin rules-of-lexical */\nconst toggleLink = $toggleLink;\nfunction $getAncestor(node, predicate) {\n  let parent = node;\n  while (parent !== null && parent.getParent() !== null && !predicate(parent)) {\n    parent = parent.getParentOrThrow();\n  }\n  return predicate(parent) ? parent : null;\n}\nconst PHONE_NUMBER_REGEX = /^\\+?[0-9\\s()-]{5,}$/;\n\n/**\n * Formats a URL string by adding appropriate protocol if missing\n *\n * @param url - URL to format\n * @returns Formatted URL with appropriate protocol\n */\nfunction formatUrl(url) {\n  // Check if URL already has a protocol\n  if (url.match(/^[a-z][a-z0-9+.-]*:/i)) {\n    // URL already has a protocol, leave it as is\n    return url;\n  }\n  // Check if it's a relative path (starting with '/', '.', or '#')\n  else if (url.match(/^[/#.]/)) {\n    // Relative path, leave it as is\n    return url;\n  }\n\n  // Check for email address\n  else if (url.includes('@')) {\n    return `mailto:${url}`;\n  }\n\n  // Check for phone number\n  else if (PHONE_NUMBER_REGEX.test(url)) {\n    return `tel:${url}`;\n  }\n\n  // For everything else, return with https:// prefix\n  return `https://${url}`;\n}\nexport { $createAutoLinkNode, $createLinkNode, $isAutoLinkNode, $isLinkNode, $toggleLink, AutoLinkNode, LinkNode, TOGGLE_LINK_COMMAND, formatUrl, toggleLink };","map":{"version":3,"names":["addClassNamesToElement","isHTMLAnchorElement","$findMatchingParent","createCommand","ElementNode","$isRangeSelection","$applyNodeReplacement","$isElementNode","$getSelection","$isNodeSelection","$normalizeSelection__EXPERIMENTAL","$setSelection","formatDevErrorMessage","message","Error","SUPPORTED_URL_PROTOCOLS","Set","LinkNode","getType","clone","node","__url","rel","__rel","target","__target","title","__title","__key","constructor","url","attributes","key","createDOM","config","element","document","createElement","updateLinkDOM","theme","link","prevNode","anchor","href","sanitizeUrl","attr","value","removeAttribute","updateDOM","importDOM","a","conversion","$convertAnchorElement","priority","importJSON","serializedNode","$createLinkNode","updateFromJSON","setURL","setRel","setTarget","setTitle","formatUrl","parsedUrl","URL","has","protocol","_unused","exportJSON","getRel","getTarget","getTitle","getURL","getLatest","writable","getWritable","insertNewAfter","_","restoreSelection","linkNode","insertAfter","canInsertTextBefore","canInsertTextAfter","canBeEmpty","isInline","extractWithChild","child","selection","destination","anchorNode","getNode","focusNode","focus","isParentOf","getTextContent","length","isEmailURI","startsWith","isWebSiteURI","domNode","content","textContent","children","getAttribute","$isLinkNode","AutoLinkNode","__isUnlinked","isUnlinked","undefined","getIsUnlinked","setIsUnlinked","self","$createAutoLinkNode","getParentOrThrow","append","$isAutoLinkNode","TOGGLE_LINK_COMMAND","$getPointNode","point","offset","type","childNode","getChildren","$withSelectedNodes","$fn","initialSelection","normalized","isBackwards","isBackward","rval","updatedSelection","finalSelection","anchorParent","getParent","set","getKey","getIndexWithinParent","focusParent","$toggleLink","nodes","getNodes","forEach","linkParent","parent","insertBefore","remove","existingLink","extract","parentLink","i","updatedNodes","updateLinkNode","add","firstNode","$getAncestor","isAttached","parentLinkNode","prevLinkNode","getPreviousSibling","is","toggleLink","predicate","PHONE_NUMBER_REGEX","match","includes","test"],"sources":["C:/Code/beedoo/node_modules/@lexical/link/LexicalLink.dev.mjs"],"sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport { addClassNamesToElement, isHTMLAnchorElement, $findMatchingParent } from '@lexical/utils';\nimport { createCommand, ElementNode, $isRangeSelection, $applyNodeReplacement, $isElementNode, $getSelection, $isNodeSelection, $normalizeSelection__EXPERIMENTAL, $setSelection } from 'lexical';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n// Do not require this module directly! Use normal `invariant` calls.\n\nfunction formatDevErrorMessage(message) {\n  throw new Error(message);\n}\n\nconst SUPPORTED_URL_PROTOCOLS = new Set(['http:', 'https:', 'mailto:', 'sms:', 'tel:']);\n\n/** @noInheritDoc */\nclass LinkNode extends ElementNode {\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  static getType() {\n    return 'link';\n  }\n  static clone(node) {\n    return new LinkNode(node.__url, {\n      rel: node.__rel,\n      target: node.__target,\n      title: node.__title\n    }, node.__key);\n  }\n  constructor(url = '', attributes = {}, key) {\n    super(key);\n    const {\n      target = null,\n      rel = null,\n      title = null\n    } = attributes;\n    this.__url = url;\n    this.__target = target;\n    this.__rel = rel;\n    this.__title = title;\n  }\n  createDOM(config) {\n    const element = document.createElement('a');\n    this.updateLinkDOM(null, element, config);\n    addClassNamesToElement(element, config.theme.link);\n    return element;\n  }\n  updateLinkDOM(prevNode, anchor, config) {\n    if (isHTMLAnchorElement(anchor)) {\n      if (!prevNode || prevNode.__url !== this.__url) {\n        anchor.href = this.sanitizeUrl(this.__url);\n      }\n      for (const attr of ['target', 'rel', 'title']) {\n        const key = `__${attr}`;\n        const value = this[key];\n        if (!prevNode || prevNode[key] !== value) {\n          if (value) {\n            anchor[attr] = value;\n          } else {\n            anchor.removeAttribute(attr);\n          }\n        }\n      }\n    }\n  }\n  updateDOM(prevNode, anchor, config) {\n    this.updateLinkDOM(prevNode, anchor, config);\n    return false;\n  }\n  static importDOM() {\n    return {\n      a: node => ({\n        conversion: $convertAnchorElement,\n        priority: 1\n      })\n    };\n  }\n  static importJSON(serializedNode) {\n    return $createLinkNode().updateFromJSON(serializedNode);\n  }\n  updateFromJSON(serializedNode) {\n    return super.updateFromJSON(serializedNode).setURL(serializedNode.url).setRel(serializedNode.rel || null).setTarget(serializedNode.target || null).setTitle(serializedNode.title || null);\n  }\n  sanitizeUrl(url) {\n    url = formatUrl(url);\n    try {\n      const parsedUrl = new URL(formatUrl(url));\n      // eslint-disable-next-line no-script-url\n      if (!SUPPORTED_URL_PROTOCOLS.has(parsedUrl.protocol)) {\n        return 'about:blank';\n      }\n    } catch (_unused) {\n      return url;\n    }\n    return url;\n  }\n  exportJSON() {\n    return {\n      ...super.exportJSON(),\n      rel: this.getRel(),\n      target: this.getTarget(),\n      title: this.getTitle(),\n      url: this.getURL()\n    };\n  }\n  getURL() {\n    return this.getLatest().__url;\n  }\n  setURL(url) {\n    const writable = this.getWritable();\n    writable.__url = url;\n    return writable;\n  }\n  getTarget() {\n    return this.getLatest().__target;\n  }\n  setTarget(target) {\n    const writable = this.getWritable();\n    writable.__target = target;\n    return writable;\n  }\n  getRel() {\n    return this.getLatest().__rel;\n  }\n  setRel(rel) {\n    const writable = this.getWritable();\n    writable.__rel = rel;\n    return writable;\n  }\n  getTitle() {\n    return this.getLatest().__title;\n  }\n  setTitle(title) {\n    const writable = this.getWritable();\n    writable.__title = title;\n    return writable;\n  }\n  insertNewAfter(_, restoreSelection = true) {\n    const linkNode = $createLinkNode(this.__url, {\n      rel: this.__rel,\n      target: this.__target,\n      title: this.__title\n    });\n    this.insertAfter(linkNode, restoreSelection);\n    return linkNode;\n  }\n  canInsertTextBefore() {\n    return false;\n  }\n  canInsertTextAfter() {\n    return false;\n  }\n  canBeEmpty() {\n    return false;\n  }\n  isInline() {\n    return true;\n  }\n  extractWithChild(child, selection, destination) {\n    if (!$isRangeSelection(selection)) {\n      return false;\n    }\n    const anchorNode = selection.anchor.getNode();\n    const focusNode = selection.focus.getNode();\n    return this.isParentOf(anchorNode) && this.isParentOf(focusNode) && selection.getTextContent().length > 0;\n  }\n  isEmailURI() {\n    return this.__url.startsWith('mailto:');\n  }\n  isWebSiteURI() {\n    return this.__url.startsWith('https://') || this.__url.startsWith('http://');\n  }\n}\nfunction $convertAnchorElement(domNode) {\n  let node = null;\n  if (isHTMLAnchorElement(domNode)) {\n    const content = domNode.textContent;\n    if (content !== null && content !== '' || domNode.children.length > 0) {\n      node = $createLinkNode(domNode.getAttribute('href') || '', {\n        rel: domNode.getAttribute('rel'),\n        target: domNode.getAttribute('target'),\n        title: domNode.getAttribute('title')\n      });\n    }\n  }\n  return {\n    node\n  };\n}\n\n/**\n * Takes a URL and creates a LinkNode.\n * @param url - The URL the LinkNode should direct to.\n * @param attributes - Optional HTML a tag attributes \\\\{ target, rel, title \\\\}\n * @returns The LinkNode.\n */\nfunction $createLinkNode(url = '', attributes) {\n  return $applyNodeReplacement(new LinkNode(url, attributes));\n}\n\n/**\n * Determines if node is a LinkNode.\n * @param node - The node to be checked.\n * @returns true if node is a LinkNode, false otherwise.\n */\nfunction $isLinkNode(node) {\n  return node instanceof LinkNode;\n}\n// Custom node type to override `canInsertTextAfter` that will\n// allow typing within the link\nclass AutoLinkNode extends LinkNode {\n  /** @internal */\n  /** Indicates whether the autolink was ever unlinked. **/\n\n  constructor(url = '', attributes = {}, key) {\n    super(url, attributes, key);\n    this.__isUnlinked = attributes.isUnlinked !== undefined && attributes.isUnlinked !== null ? attributes.isUnlinked : false;\n  }\n  static getType() {\n    return 'autolink';\n  }\n  static clone(node) {\n    return new AutoLinkNode(node.__url, {\n      isUnlinked: node.__isUnlinked,\n      rel: node.__rel,\n      target: node.__target,\n      title: node.__title\n    }, node.__key);\n  }\n  getIsUnlinked() {\n    return this.__isUnlinked;\n  }\n  setIsUnlinked(value) {\n    const self = this.getWritable();\n    self.__isUnlinked = value;\n    return self;\n  }\n  createDOM(config) {\n    if (this.__isUnlinked) {\n      return document.createElement('span');\n    } else {\n      return super.createDOM(config);\n    }\n  }\n  updateDOM(prevNode, anchor, config) {\n    return super.updateDOM(prevNode, anchor, config) || prevNode.__isUnlinked !== this.__isUnlinked;\n  }\n  static importJSON(serializedNode) {\n    return $createAutoLinkNode().updateFromJSON(serializedNode);\n  }\n  updateFromJSON(serializedNode) {\n    return super.updateFromJSON(serializedNode).setIsUnlinked(serializedNode.isUnlinked || false);\n  }\n  static importDOM() {\n    // TODO: Should link node should handle the import over autolink?\n    return null;\n  }\n  exportJSON() {\n    return {\n      ...super.exportJSON(),\n      isUnlinked: this.__isUnlinked\n    };\n  }\n  insertNewAfter(selection, restoreSelection = true) {\n    const element = this.getParentOrThrow().insertNewAfter(selection, restoreSelection);\n    if ($isElementNode(element)) {\n      const linkNode = $createAutoLinkNode(this.__url, {\n        isUnlinked: this.__isUnlinked,\n        rel: this.__rel,\n        target: this.__target,\n        title: this.__title\n      });\n      element.append(linkNode);\n      return linkNode;\n    }\n    return null;\n  }\n}\n\n/**\n * Takes a URL and creates an AutoLinkNode. AutoLinkNodes are generally automatically generated\n * during typing, which is especially useful when a button to generate a LinkNode is not practical.\n * @param url - The URL the LinkNode should direct to.\n * @param attributes - Optional HTML a tag attributes. \\\\{ target, rel, title \\\\}\n * @returns The LinkNode.\n */\nfunction $createAutoLinkNode(url = '', attributes) {\n  return $applyNodeReplacement(new AutoLinkNode(url, attributes));\n}\n\n/**\n * Determines if node is an AutoLinkNode.\n * @param node - The node to be checked.\n * @returns true if node is an AutoLinkNode, false otherwise.\n */\nfunction $isAutoLinkNode(node) {\n  return node instanceof AutoLinkNode;\n}\nconst TOGGLE_LINK_COMMAND = createCommand('TOGGLE_LINK_COMMAND');\nfunction $getPointNode(point, offset) {\n  if (point.type === 'element') {\n    const node = point.getNode();\n    if (!$isElementNode(node)) {\n      formatDevErrorMessage(`$getPointNode: element point is not an ElementNode`);\n    }\n    const childNode = node.getChildren()[point.offset + offset];\n    return childNode || null;\n  }\n  return null;\n}\n\n/**\n * Preserve the logical start/end of a RangeSelection in situations where\n * the point is an element that may be reparented in the callback.\n *\n * @param $fn The function to run\n * @returns The result of the callback\n */\nfunction $withSelectedNodes($fn) {\n  const initialSelection = $getSelection();\n  if (!$isRangeSelection(initialSelection)) {\n    return $fn();\n  }\n  const normalized = $normalizeSelection__EXPERIMENTAL(initialSelection);\n  const isBackwards = normalized.isBackward();\n  const anchorNode = $getPointNode(normalized.anchor, isBackwards ? -1 : 0);\n  const focusNode = $getPointNode(normalized.focus, isBackwards ? 0 : -1);\n  const rval = $fn();\n  if (anchorNode || focusNode) {\n    const updatedSelection = $getSelection();\n    if ($isRangeSelection(updatedSelection)) {\n      const finalSelection = updatedSelection.clone();\n      if (anchorNode) {\n        const anchorParent = anchorNode.getParent();\n        if (anchorParent) {\n          finalSelection.anchor.set(anchorParent.getKey(), anchorNode.getIndexWithinParent() + (isBackwards ? 1 : 0), 'element');\n        }\n      }\n      if (focusNode) {\n        const focusParent = focusNode.getParent();\n        if (focusParent) {\n          finalSelection.focus.set(focusParent.getKey(), focusNode.getIndexWithinParent() + (isBackwards ? 0 : 1), 'element');\n        }\n      }\n      $setSelection($normalizeSelection__EXPERIMENTAL(finalSelection));\n    }\n  }\n  return rval;\n}\n\n/**\n * Generates or updates a LinkNode. It can also delete a LinkNode if the URL is null,\n * but saves any children and brings them up to the parent node.\n * @param url - The URL the link directs to.\n * @param attributes - Optional HTML a tag attributes. \\\\{ target, rel, title \\\\}\n */\nfunction $toggleLink(url, attributes = {}) {\n  const {\n    target,\n    title\n  } = attributes;\n  const rel = attributes.rel === undefined ? 'noreferrer' : attributes.rel;\n  const selection = $getSelection();\n  if (selection === null || !$isRangeSelection(selection) && !$isNodeSelection(selection)) {\n    return;\n  }\n  if ($isNodeSelection(selection)) {\n    const nodes = selection.getNodes();\n    if (nodes.length === 0) {\n      return;\n    }\n\n    // Handle all selected nodes\n    nodes.forEach(node => {\n      if (url === null) {\n        // Remove link\n        const linkParent = $findMatchingParent(node, parent => !$isAutoLinkNode(parent) && $isLinkNode(parent));\n        if (linkParent) {\n          linkParent.insertBefore(node);\n          if (linkParent.getChildren().length === 0) {\n            linkParent.remove();\n          }\n        }\n      } else {\n        // Add/Update link\n        const existingLink = $findMatchingParent(node, parent => !$isAutoLinkNode(parent) && $isLinkNode(parent));\n        if (existingLink) {\n          existingLink.setURL(url);\n          if (target !== undefined) {\n            existingLink.setTarget(target);\n          }\n          if (rel !== undefined) {\n            existingLink.setRel(rel);\n          }\n        } else {\n          const linkNode = $createLinkNode(url, {\n            rel,\n            target\n          });\n          node.insertBefore(linkNode);\n          linkNode.append(node);\n        }\n      }\n    });\n    return;\n  }\n\n  // Handle RangeSelection\n  const nodes = selection.extract();\n  if (url === null) {\n    // Remove LinkNodes\n    nodes.forEach(node => {\n      const parentLink = $findMatchingParent(node, parent => !$isAutoLinkNode(parent) && $isLinkNode(parent));\n      if (parentLink) {\n        const children = parentLink.getChildren();\n        for (let i = 0; i < children.length; i++) {\n          parentLink.insertBefore(children[i]);\n        }\n        parentLink.remove();\n      }\n    });\n    return;\n  }\n  const updatedNodes = new Set();\n  const updateLinkNode = linkNode => {\n    if (updatedNodes.has(linkNode.getKey())) {\n      return;\n    }\n    updatedNodes.add(linkNode.getKey());\n    linkNode.setURL(url);\n    if (target !== undefined) {\n      linkNode.setTarget(target);\n    }\n    if (rel !== undefined) {\n      linkNode.setRel(rel);\n    }\n    if (title !== undefined) {\n      linkNode.setTitle(title);\n    }\n  };\n  // Add or merge LinkNodes\n  if (nodes.length === 1) {\n    const firstNode = nodes[0];\n    // if the first node is a LinkNode or if its\n    // parent is a LinkNode, we update the URL, target and rel.\n    const linkNode = $getAncestor(firstNode, $isLinkNode);\n    if (linkNode !== null) {\n      return updateLinkNode(linkNode);\n    }\n  }\n  $withSelectedNodes(() => {\n    let linkNode = null;\n    for (const node of nodes) {\n      if (!node.isAttached()) {\n        continue;\n      }\n      const parentLinkNode = $getAncestor(node, $isLinkNode);\n      if (parentLinkNode) {\n        updateLinkNode(parentLinkNode);\n        continue;\n      }\n      if ($isElementNode(node)) {\n        if (!node.isInline()) {\n          // Ignore block nodes, if there are any children we will see them\n          // later and wrap in a new LinkNode\n          continue;\n        }\n        if ($isLinkNode(node)) {\n          // If it's not an autolink node and we don't already have a LinkNode\n          // in this block then we can update it and re-use it\n          if (!$isAutoLinkNode(node) && (linkNode === null || !linkNode.getParentOrThrow().isParentOf(node))) {\n            updateLinkNode(node);\n            linkNode = node;\n            continue;\n          }\n          // Unwrap LinkNode, we already have one or it's an AutoLinkNode\n          for (const child of node.getChildren()) {\n            node.insertBefore(child);\n          }\n          node.remove();\n          continue;\n        }\n      }\n      const prevLinkNode = node.getPreviousSibling();\n      if ($isLinkNode(prevLinkNode) && prevLinkNode.is(linkNode)) {\n        prevLinkNode.append(node);\n        continue;\n      }\n      linkNode = $createLinkNode(url, {\n        rel,\n        target,\n        title\n      });\n      node.insertAfter(linkNode);\n      linkNode.append(node);\n    }\n  });\n}\n/** @deprecated renamed to {@link $toggleLink} by @lexical/eslint-plugin rules-of-lexical */\nconst toggleLink = $toggleLink;\nfunction $getAncestor(node, predicate) {\n  let parent = node;\n  while (parent !== null && parent.getParent() !== null && !predicate(parent)) {\n    parent = parent.getParentOrThrow();\n  }\n  return predicate(parent) ? parent : null;\n}\nconst PHONE_NUMBER_REGEX = /^\\+?[0-9\\s()-]{5,}$/;\n\n/**\n * Formats a URL string by adding appropriate protocol if missing\n *\n * @param url - URL to format\n * @returns Formatted URL with appropriate protocol\n */\nfunction formatUrl(url) {\n  // Check if URL already has a protocol\n  if (url.match(/^[a-z][a-z0-9+.-]*:/i)) {\n    // URL already has a protocol, leave it as is\n    return url;\n  }\n  // Check if it's a relative path (starting with '/', '.', or '#')\n  else if (url.match(/^[/#.]/)) {\n    // Relative path, leave it as is\n    return url;\n  }\n\n  // Check for email address\n  else if (url.includes('@')) {\n    return `mailto:${url}`;\n  }\n\n  // Check for phone number\n  else if (PHONE_NUMBER_REGEX.test(url)) {\n    return `tel:${url}`;\n  }\n\n  // For everything else, return with https:// prefix\n  return `https://${url}`;\n}\n\nexport { $createAutoLinkNode, $createLinkNode, $isAutoLinkNode, $isLinkNode, $toggleLink, AutoLinkNode, LinkNode, TOGGLE_LINK_COMMAND, formatUrl, toggleLink };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}