{"ast":null,"code":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport { $isTextNode, $isTokenOrSegmented, $getCharacterOffsets, $isElementNode, $isRootNode, $getNodeByKey, $getPreviousSelection, $createTextNode, $isRangeSelection, $getSelection, $caretRangeFromSelection, $createRangeSelection, INTERNAL_$isBlock, $setSelection, $isRootOrShadowRoot, $hasAncestor, $isLeafNode, $caretFromPoint, $isExtendableTextPointCaret, $extendCaretToRange, $isChildCaret, $isDecoratorNode, $getEditor } from 'lexical';\nexport { $cloneWithProperties, $selectAll } from 'lexical';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n// Do not require this module directly! Use normal `invariant` calls.\n\nfunction formatDevErrorMessage(message) {\n  throw new Error(message);\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nconst CSS_TO_STYLES = new Map();\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction getDOMTextNode(element) {\n  let node = element;\n  while (node != null) {\n    if (node.nodeType === Node.TEXT_NODE) {\n      return node;\n    }\n    node = node.firstChild;\n  }\n  return null;\n}\nfunction getDOMIndexWithinParent(node) {\n  const parent = node.parentNode;\n  if (parent == null) {\n    throw new Error('Should never happen');\n  }\n  return [parent, Array.from(parent.childNodes).indexOf(node)];\n}\n\n/**\n * Creates a selection range for the DOM.\n * @param editor - The lexical editor.\n * @param anchorNode - The anchor node of a selection.\n * @param _anchorOffset - The amount of space offset from the anchor to the focus.\n * @param focusNode - The current focus.\n * @param _focusOffset - The amount of space offset from the focus to the anchor.\n * @returns The range of selection for the DOM that was created.\n */\nfunction createDOMRange(editor, anchorNode, _anchorOffset, focusNode, _focusOffset) {\n  const anchorKey = anchorNode.getKey();\n  const focusKey = focusNode.getKey();\n  const range = document.createRange();\n  let anchorDOM = editor.getElementByKey(anchorKey);\n  let focusDOM = editor.getElementByKey(focusKey);\n  let anchorOffset = _anchorOffset;\n  let focusOffset = _focusOffset;\n  if ($isTextNode(anchorNode)) {\n    anchorDOM = getDOMTextNode(anchorDOM);\n  }\n  if ($isTextNode(focusNode)) {\n    focusDOM = getDOMTextNode(focusDOM);\n  }\n  if (anchorNode === undefined || focusNode === undefined || anchorDOM === null || focusDOM === null) {\n    return null;\n  }\n  if (anchorDOM.nodeName === 'BR') {\n    [anchorDOM, anchorOffset] = getDOMIndexWithinParent(anchorDOM);\n  }\n  if (focusDOM.nodeName === 'BR') {\n    [focusDOM, focusOffset] = getDOMIndexWithinParent(focusDOM);\n  }\n  const firstChild = anchorDOM.firstChild;\n  if (anchorDOM === focusDOM && firstChild != null && firstChild.nodeName === 'BR' && anchorOffset === 0 && focusOffset === 0) {\n    focusOffset = 1;\n  }\n  try {\n    range.setStart(anchorDOM, anchorOffset);\n    range.setEnd(focusDOM, focusOffset);\n  } catch (e) {\n    return null;\n  }\n  if (range.collapsed && (anchorOffset !== focusOffset || anchorKey !== focusKey)) {\n    // Range is backwards, we need to reverse it\n    range.setStart(focusDOM, focusOffset);\n    range.setEnd(anchorDOM, anchorOffset);\n  }\n  return range;\n}\n\n/**\n * Creates DOMRects, generally used to help the editor find a specific location on the screen.\n * @param editor - The lexical editor\n * @param range - A fragment of a document that can contain nodes and parts of text nodes.\n * @returns The selectionRects as an array.\n */\nfunction createRectsFromDOMRange(editor, range) {\n  const rootElement = editor.getRootElement();\n  if (rootElement === null) {\n    return [];\n  }\n  const rootRect = rootElement.getBoundingClientRect();\n  const computedStyle = getComputedStyle(rootElement);\n  const rootPadding = parseFloat(computedStyle.paddingLeft) + parseFloat(computedStyle.paddingRight);\n  const selectionRects = Array.from(range.getClientRects());\n  let selectionRectsLength = selectionRects.length;\n  //sort rects from top left to bottom right.\n  selectionRects.sort((a, b) => {\n    const top = a.top - b.top;\n    // Some rects match position closely, but not perfectly,\n    // so we give a 3px tolerance.\n    if (Math.abs(top) <= 3) {\n      return a.left - b.left;\n    }\n    return top;\n  });\n  let prevRect;\n  for (let i = 0; i < selectionRectsLength; i++) {\n    const selectionRect = selectionRects[i];\n    // Exclude rects that overlap preceding Rects in the sorted list.\n    const isOverlappingRect = prevRect && prevRect.top <= selectionRect.top && prevRect.top + prevRect.height > selectionRect.top && prevRect.left + prevRect.width > selectionRect.left;\n    // Exclude selections that span the entire element\n    const selectionSpansElement = selectionRect.width + rootPadding === rootRect.width;\n    if (isOverlappingRect || selectionSpansElement) {\n      selectionRects.splice(i--, 1);\n      selectionRectsLength--;\n      continue;\n    }\n    prevRect = selectionRect;\n  }\n  return selectionRects;\n}\n\n/**\n * Creates an object containing all the styles and their values provided in the CSS string.\n * @param css - The CSS string of styles and their values.\n * @returns The styleObject containing all the styles and their values.\n */\nfunction getStyleObjectFromRawCSS(css) {\n  const styleObject = {};\n  if (!css) {\n    return styleObject;\n  }\n  const styles = css.split(';');\n  for (const style of styles) {\n    if (style !== '') {\n      const [key, value] = style.split(/:([^]+)/); // split on first colon\n      if (key && value) {\n        styleObject[key.trim()] = value.trim();\n      }\n    }\n  }\n  return styleObject;\n}\n\n/**\n * Given a CSS string, returns an object from the style cache.\n * @param css - The CSS property as a string.\n * @returns The value of the given CSS property.\n */\nfunction getStyleObjectFromCSS(css) {\n  let value = CSS_TO_STYLES.get(css);\n  if (value === undefined) {\n    value = getStyleObjectFromRawCSS(css);\n    CSS_TO_STYLES.set(css, value);\n  }\n  {\n    // Freeze the value in DEV to prevent accidental mutations\n    Object.freeze(value);\n  }\n  return value;\n}\n\n/**\n * Gets the CSS styles from the style object.\n * @param styles - The style object containing the styles to get.\n * @returns A string containing the CSS styles and their values.\n */\nfunction getCSSFromStyleObject(styles) {\n  let css = '';\n  for (const style in styles) {\n    if (style) {\n      css += `${style}: ${styles[style]};`;\n    }\n  }\n  return css;\n}\n\n/**\n * Generally used to append text content to HTML and JSON. Grabs the text content and \"slices\"\n * it to be generated into the new TextNode.\n * @param selection - The selection containing the node whose TextNode is to be edited.\n * @param textNode - The TextNode to be edited.\n * @returns The updated TextNode.\n */\nfunction $sliceSelectedTextNodeContent(selection, textNode) {\n  const anchorAndFocus = selection.getStartEndPoints();\n  if (textNode.isSelected(selection) && !$isTokenOrSegmented(textNode) && anchorAndFocus !== null) {\n    const [anchor, focus] = anchorAndFocus;\n    const isBackward = selection.isBackward();\n    const anchorNode = anchor.getNode();\n    const focusNode = focus.getNode();\n    const isAnchor = textNode.is(anchorNode);\n    const isFocus = textNode.is(focusNode);\n    if (isAnchor || isFocus) {\n      const [anchorOffset, focusOffset] = $getCharacterOffsets(selection);\n      const isSame = anchorNode.is(focusNode);\n      const isFirst = textNode.is(isBackward ? focusNode : anchorNode);\n      const isLast = textNode.is(isBackward ? anchorNode : focusNode);\n      let startOffset = 0;\n      let endOffset = undefined;\n      if (isSame) {\n        startOffset = anchorOffset > focusOffset ? focusOffset : anchorOffset;\n        endOffset = anchorOffset > focusOffset ? anchorOffset : focusOffset;\n      } else if (isFirst) {\n        const offset = isBackward ? focusOffset : anchorOffset;\n        startOffset = offset;\n        endOffset = undefined;\n      } else if (isLast) {\n        const offset = isBackward ? anchorOffset : focusOffset;\n        startOffset = 0;\n        endOffset = offset;\n      }\n\n      // NOTE: This mutates __text directly because the primary use case is to\n      // modify a $cloneWithProperties node that should never be added\n      // to the EditorState so we must not call getWritable via setTextContent\n      textNode.__text = textNode.__text.slice(startOffset, endOffset);\n    }\n  }\n  return textNode;\n}\n\n/**\n * Determines if the current selection is at the end of the node.\n * @param point - The point of the selection to test.\n * @returns true if the provided point offset is in the last possible position, false otherwise.\n */\nfunction $isAtNodeEnd(point) {\n  if (point.type === 'text') {\n    return point.offset === point.getNode().getTextContentSize();\n  }\n  const node = point.getNode();\n  if (!$isElementNode(node)) {\n    formatDevErrorMessage(`isAtNodeEnd: node must be a TextNode or ElementNode`);\n  }\n  return point.offset === node.getChildrenSize();\n}\n\n/**\n * Trims text from a node in order to shorten it, eg. to enforce a text's max length. If it deletes text\n * that is an ancestor of the anchor then it will leave 2 indents, otherwise, if no text content exists, it deletes\n * the TextNode. It will move the focus to either the end of any left over text or beginning of a new TextNode.\n * @param editor - The lexical editor.\n * @param anchor - The anchor of the current selection, where the selection should be pointing.\n * @param delCount - The amount of characters to delete. Useful as a dynamic variable eg. textContentSize - maxLength;\n */\nfunction $trimTextContentFromAnchor(editor, anchor, delCount) {\n  // Work from the current selection anchor point\n  let currentNode = anchor.getNode();\n  let remaining = delCount;\n  if ($isElementNode(currentNode)) {\n    const descendantNode = currentNode.getDescendantByIndex(anchor.offset);\n    if (descendantNode !== null) {\n      currentNode = descendantNode;\n    }\n  }\n  while (remaining > 0 && currentNode !== null) {\n    if ($isElementNode(currentNode)) {\n      const lastDescendant = currentNode.getLastDescendant();\n      if (lastDescendant !== null) {\n        currentNode = lastDescendant;\n      }\n    }\n    let nextNode = currentNode.getPreviousSibling();\n    let additionalElementWhitespace = 0;\n    if (nextNode === null) {\n      let parent = currentNode.getParentOrThrow();\n      let parentSibling = parent.getPreviousSibling();\n      while (parentSibling === null) {\n        parent = parent.getParent();\n        if (parent === null) {\n          nextNode = null;\n          break;\n        }\n        parentSibling = parent.getPreviousSibling();\n      }\n      if (parent !== null) {\n        additionalElementWhitespace = parent.isInline() ? 0 : 2;\n        nextNode = parentSibling;\n      }\n    }\n    let text = currentNode.getTextContent();\n    // If the text is empty, we need to consider adding in two line breaks to match\n    // the content if we were to get it from its parent.\n    if (text === '' && $isElementNode(currentNode) && !currentNode.isInline()) {\n      // TODO: should this be handled in core?\n      text = '\\n\\n';\n    }\n    const currentNodeSize = text.length;\n    if (!$isTextNode(currentNode) || remaining >= currentNodeSize) {\n      const parent = currentNode.getParent();\n      currentNode.remove();\n      if (parent != null && parent.getChildrenSize() === 0 && !$isRootNode(parent)) {\n        parent.remove();\n      }\n      remaining -= currentNodeSize + additionalElementWhitespace;\n      currentNode = nextNode;\n    } else {\n      const key = currentNode.getKey();\n      // See if we can just revert it to what was in the last editor state\n      const prevTextContent = editor.getEditorState().read(() => {\n        const prevNode = $getNodeByKey(key);\n        if ($isTextNode(prevNode) && prevNode.isSimpleText()) {\n          return prevNode.getTextContent();\n        }\n        return null;\n      });\n      const offset = currentNodeSize - remaining;\n      const slicedText = text.slice(0, offset);\n      if (prevTextContent !== null && prevTextContent !== text) {\n        const prevSelection = $getPreviousSelection();\n        let target = currentNode;\n        if (!currentNode.isSimpleText()) {\n          const textNode = $createTextNode(prevTextContent);\n          currentNode.replace(textNode);\n          target = textNode;\n        } else {\n          currentNode.setTextContent(prevTextContent);\n        }\n        if ($isRangeSelection(prevSelection) && prevSelection.isCollapsed()) {\n          const prevOffset = prevSelection.anchor.offset;\n          target.select(prevOffset, prevOffset);\n        }\n      } else if (currentNode.isSimpleText()) {\n        // Split text\n        const isSelected = anchor.key === key;\n        let anchorOffset = anchor.offset;\n        // Move offset to end if it's less than the remaining number, otherwise\n        // we'll have a negative splitStart.\n        if (anchorOffset < remaining) {\n          anchorOffset = currentNodeSize;\n        }\n        const splitStart = isSelected ? anchorOffset - remaining : 0;\n        const splitEnd = isSelected ? anchorOffset : offset;\n        if (isSelected && splitStart === 0) {\n          const [excessNode] = currentNode.splitText(splitStart, splitEnd);\n          excessNode.remove();\n        } else {\n          const [, excessNode] = currentNode.splitText(splitStart, splitEnd);\n          excessNode.remove();\n        }\n      } else {\n        const textNode = $createTextNode(slicedText);\n        currentNode.replace(textNode);\n      }\n      remaining = 0;\n    }\n  }\n}\n\n/**\n * Gets the TextNode's style object and adds the styles to the CSS.\n * @param node - The TextNode to add styles to.\n */\nfunction $addNodeStyle(node) {\n  const CSSText = node.getStyle();\n  const styles = getStyleObjectFromRawCSS(CSSText);\n  CSS_TO_STYLES.set(CSSText, styles);\n}\n\n/**\n * Applies the provided styles to the given TextNode, ElementNode, or\n * collapsed RangeSelection.\n *\n * @param target - The TextNode, ElementNode, or collapsed RangeSelection to apply the styles to\n * @param patch - The patch to apply, which can include multiple styles. \\\\{CSSProperty: value\\\\} . Can also accept a function that returns the new property value.\n */\nfunction $patchStyle(target, patch) {\n  if (!($isRangeSelection(target) ? target.isCollapsed() : $isTextNode(target) || $isElementNode(target))) {\n    formatDevErrorMessage(`$patchStyle must only be called with a TextNode, ElementNode, or collapsed RangeSelection`);\n  }\n  const prevStyles = getStyleObjectFromCSS($isRangeSelection(target) ? target.style : $isTextNode(target) ? target.getStyle() : target.getTextStyle());\n  const newStyles = Object.entries(patch).reduce((styles, [key, value]) => {\n    if (typeof value === 'function') {\n      styles[key] = value(prevStyles[key], target);\n    } else if (value === null) {\n      delete styles[key];\n    } else {\n      styles[key] = value;\n    }\n    return styles;\n  }, {\n    ...prevStyles\n  });\n  const newCSSText = getCSSFromStyleObject(newStyles);\n  if ($isRangeSelection(target) || $isTextNode(target)) {\n    target.setStyle(newCSSText);\n  } else {\n    target.setTextStyle(newCSSText);\n  }\n  CSS_TO_STYLES.set(newCSSText, newStyles);\n}\n\n/**\n * Applies the provided styles to the TextNodes in the provided Selection.\n * Will update partially selected TextNodes by splitting the TextNode and applying\n * the styles to the appropriate one.\n * @param selection - The selected node(s) to update.\n * @param patch - The patch to apply, which can include multiple styles. \\\\{CSSProperty: value\\\\} . Can also accept a function that returns the new property value.\n */\nfunction $patchStyleText(selection, patch) {\n  if ($isRangeSelection(selection) && selection.isCollapsed()) {\n    $patchStyle(selection, patch);\n    const emptyNode = selection.anchor.getNode();\n    if ($isElementNode(emptyNode) && emptyNode.isEmpty()) {\n      $patchStyle(emptyNode, patch);\n    }\n  }\n  $forEachSelectedTextNode(textNode => {\n    $patchStyle(textNode, patch);\n  });\n}\nfunction $forEachSelectedTextNode(fn) {\n  const selection = $getSelection();\n  if (!selection) {\n    return;\n  }\n  const slicedTextNodes = new Map();\n  const getSliceIndices = node => slicedTextNodes.get(node.getKey()) || [0, node.getTextContentSize()];\n  if ($isRangeSelection(selection)) {\n    for (const slice of $caretRangeFromSelection(selection).getTextSlices()) {\n      if (slice) {\n        slicedTextNodes.set(slice.caret.origin.getKey(), slice.getSliceIndices());\n      }\n    }\n  }\n  const selectedNodes = selection.getNodes();\n  for (const selectedNode of selectedNodes) {\n    if (!($isTextNode(selectedNode) && selectedNode.canHaveFormat())) {\n      continue;\n    }\n    const [startOffset, endOffset] = getSliceIndices(selectedNode);\n    // No actual text is selected, so do nothing.\n    if (endOffset === startOffset) {\n      continue;\n    }\n\n    // The entire node is selected or a token/segment, so just format it\n    if ($isTokenOrSegmented(selectedNode) || startOffset === 0 && endOffset === selectedNode.getTextContentSize()) {\n      fn(selectedNode);\n    } else {\n      // The node is partially selected, so split it into two or three nodes\n      // and style the selected one.\n      const splitNodes = selectedNode.splitText(startOffset, endOffset);\n      const replacement = splitNodes[startOffset === 0 ? 0 : 1];\n      fn(replacement);\n    }\n  }\n  // Prior to NodeCaret #7046 this would have been a side-effect\n  // so we do this for test compatibility.\n  // TODO: we may want to consider simplifying by removing this\n  if ($isRangeSelection(selection) && selection.anchor.type === 'text' && selection.focus.type === 'text' && selection.anchor.key === selection.focus.key) {\n    $ensureForwardRangeSelection(selection);\n  }\n}\n\n/**\n * Ensure that the given RangeSelection is not backwards. If it\n * is backwards, then the anchor and focus points will be swapped\n * in-place. Ensuring that the selection is a writable RangeSelection\n * is the responsibility of the caller (e.g. in a read-only context\n * you will want to clone $getSelection() before using this).\n *\n * @param selection a writable RangeSelection\n */\nfunction $ensureForwardRangeSelection(selection) {\n  if (selection.isBackward()) {\n    const {\n      anchor,\n      focus\n    } = selection;\n    // stash for the in-place swap\n    const {\n      key,\n      offset,\n      type\n    } = anchor;\n    anchor.set(focus.key, focus.offset, focus.type);\n    focus.set(key, offset, type);\n  }\n}\nfunction $copyBlockFormatIndent(srcNode, destNode) {\n  const format = srcNode.getFormatType();\n  const indent = srcNode.getIndent();\n  if (format !== destNode.getFormatType()) {\n    destNode.setFormat(format);\n  }\n  if (indent !== destNode.getIndent()) {\n    destNode.setIndent(indent);\n  }\n}\n\n/**\n * Converts all nodes in the selection that are of one block type to another.\n * @param selection - The selected blocks to be converted.\n * @param $createElement - The function that creates the node. eg. $createParagraphNode.\n * @param $afterCreateElement - The function that updates the new node based on the previous one ($copyBlockFormatIndent by default)\n */\nfunction $setBlocksType(selection, $createElement, $afterCreateElement = $copyBlockFormatIndent) {\n  if (selection === null) {\n    return;\n  }\n  // Selections tend to not include their containing blocks so we effectively\n  // expand it here\n  const anchorAndFocus = selection.getStartEndPoints();\n  const blockMap = new Map();\n  let newSelection = null;\n  if (anchorAndFocus) {\n    const [anchor, focus] = anchorAndFocus;\n    newSelection = $createRangeSelection();\n    newSelection.anchor.set(anchor.key, anchor.offset, anchor.type);\n    newSelection.focus.set(focus.key, focus.offset, focus.type);\n    const anchorBlock = $getAncestor(anchor.getNode(), INTERNAL_$isBlock);\n    const focusBlock = $getAncestor(focus.getNode(), INTERNAL_$isBlock);\n    if ($isElementNode(anchorBlock)) {\n      blockMap.set(anchorBlock.getKey(), anchorBlock);\n    }\n    if ($isElementNode(focusBlock)) {\n      blockMap.set(focusBlock.getKey(), focusBlock);\n    }\n  }\n  for (const node of selection.getNodes()) {\n    if ($isElementNode(node) && INTERNAL_$isBlock(node)) {\n      blockMap.set(node.getKey(), node);\n    } else if (anchorAndFocus === null) {\n      const ancestorBlock = $getAncestor(node, INTERNAL_$isBlock);\n      if ($isElementNode(ancestorBlock)) {\n        blockMap.set(ancestorBlock.getKey(), ancestorBlock);\n      }\n    }\n  }\n  for (const [key, prevNode] of blockMap) {\n    const element = $createElement();\n    $afterCreateElement(prevNode, element);\n    prevNode.replace(element, true);\n    if (newSelection) {\n      if (key === newSelection.anchor.key) {\n        newSelection.anchor.set(element.getKey(), newSelection.anchor.offset, newSelection.anchor.type);\n      }\n      if (key === newSelection.focus.key) {\n        newSelection.focus.set(element.getKey(), newSelection.focus.offset, newSelection.focus.type);\n      }\n    }\n  }\n  if (newSelection && selection.is($getSelection())) {\n    $setSelection(newSelection);\n  }\n}\nfunction isPointAttached(point) {\n  return point.getNode().isAttached();\n}\nfunction $removeParentEmptyElements(startingNode) {\n  let node = startingNode;\n  while (node !== null && !$isRootOrShadowRoot(node)) {\n    const latest = node.getLatest();\n    const parentNode = node.getParent();\n    if (latest.getChildrenSize() === 0) {\n      node.remove(true);\n    }\n    node = parentNode;\n  }\n}\n\n/**\n * @deprecated In favor of $setBlockTypes\n * Wraps all nodes in the selection into another node of the type returned by createElement.\n * @param selection - The selection of nodes to be wrapped.\n * @param createElement - A function that creates the wrapping ElementNode. eg. $createParagraphNode.\n * @param wrappingElement - An element to append the wrapped selection and its children to.\n */\nfunction $wrapNodes(selection, createElement, wrappingElement = null) {\n  const anchorAndFocus = selection.getStartEndPoints();\n  const anchor = anchorAndFocus ? anchorAndFocus[0] : null;\n  const nodes = selection.getNodes();\n  const nodesLength = nodes.length;\n  if (anchor !== null && (nodesLength === 0 || nodesLength === 1 && anchor.type === 'element' && anchor.getNode().getChildrenSize() === 0)) {\n    const target = anchor.type === 'text' ? anchor.getNode().getParentOrThrow() : anchor.getNode();\n    const children = target.getChildren();\n    let element = createElement();\n    element.setFormat(target.getFormatType());\n    element.setIndent(target.getIndent());\n    children.forEach(child => element.append(child));\n    if (wrappingElement) {\n      element = wrappingElement.append(element);\n    }\n    target.replace(element);\n    return;\n  }\n  let topLevelNode = null;\n  let descendants = [];\n  for (let i = 0; i < nodesLength; i++) {\n    const node = nodes[i];\n    // Determine whether wrapping has to be broken down into multiple chunks. This can happen if the\n    // user selected multiple Root-like nodes that have to be treated separately as if they are\n    // their own branch. I.e. you don't want to wrap a whole table, but rather the contents of each\n    // of each of the cell nodes.\n    if ($isRootOrShadowRoot(node)) {\n      $wrapNodesImpl(selection, descendants, descendants.length, createElement, wrappingElement);\n      descendants = [];\n      topLevelNode = node;\n    } else if (topLevelNode === null || topLevelNode !== null && $hasAncestor(node, topLevelNode)) {\n      descendants.push(node);\n    } else {\n      $wrapNodesImpl(selection, descendants, descendants.length, createElement, wrappingElement);\n      descendants = [node];\n    }\n  }\n  $wrapNodesImpl(selection, descendants, descendants.length, createElement, wrappingElement);\n}\n\n/**\n * Wraps each node into a new ElementNode.\n * @param selection - The selection of nodes to wrap.\n * @param nodes - An array of nodes, generally the descendants of the selection.\n * @param nodesLength - The length of nodes.\n * @param createElement - A function that creates the wrapping ElementNode. eg. $createParagraphNode.\n * @param wrappingElement - An element to wrap all the nodes into.\n * @returns\n */\nfunction $wrapNodesImpl(selection, nodes, nodesLength, createElement, wrappingElement = null) {\n  if (nodes.length === 0) {\n    return;\n  }\n  const firstNode = nodes[0];\n  const elementMapping = new Map();\n  const elements = [];\n  // The below logic is to find the right target for us to\n  // either insertAfter/insertBefore/append the corresponding\n  // elements to. This is made more complicated due to nested\n  // structures.\n  let target = $isElementNode(firstNode) ? firstNode : firstNode.getParentOrThrow();\n  if (target.isInline()) {\n    target = target.getParentOrThrow();\n  }\n  let targetIsPrevSibling = false;\n  while (target !== null) {\n    const prevSibling = target.getPreviousSibling();\n    if (prevSibling !== null) {\n      target = prevSibling;\n      targetIsPrevSibling = true;\n      break;\n    }\n    target = target.getParentOrThrow();\n    if ($isRootOrShadowRoot(target)) {\n      break;\n    }\n  }\n  const emptyElements = new Set();\n\n  // Find any top level empty elements\n  for (let i = 0; i < nodesLength; i++) {\n    const node = nodes[i];\n    if ($isElementNode(node) && node.getChildrenSize() === 0) {\n      emptyElements.add(node.getKey());\n    }\n  }\n  const movedNodes = new Set();\n\n  // Move out all leaf nodes into our elements array.\n  // If we find a top level empty element, also move make\n  // an element for that.\n  for (let i = 0; i < nodesLength; i++) {\n    const node = nodes[i];\n    let parent = node.getParent();\n    if (parent !== null && parent.isInline()) {\n      parent = parent.getParent();\n    }\n    if (parent !== null && $isLeafNode(node) && !movedNodes.has(node.getKey())) {\n      const parentKey = parent.getKey();\n      if (elementMapping.get(parentKey) === undefined) {\n        const targetElement = createElement();\n        targetElement.setFormat(parent.getFormatType());\n        targetElement.setIndent(parent.getIndent());\n        elements.push(targetElement);\n        elementMapping.set(parentKey, targetElement);\n        // Move node and its siblings to the new\n        // element.\n        parent.getChildren().forEach(child => {\n          targetElement.append(child);\n          movedNodes.add(child.getKey());\n          if ($isElementNode(child)) {\n            // Skip nested leaf nodes if the parent has already been moved\n            child.getChildrenKeys().forEach(key => movedNodes.add(key));\n          }\n        });\n        $removeParentEmptyElements(parent);\n      }\n    } else if (emptyElements.has(node.getKey())) {\n      if (!$isElementNode(node)) {\n        formatDevErrorMessage(`Expected node in emptyElements to be an ElementNode`);\n      }\n      const targetElement = createElement();\n      targetElement.setFormat(node.getFormatType());\n      targetElement.setIndent(node.getIndent());\n      elements.push(targetElement);\n      node.remove(true);\n    }\n  }\n  if (wrappingElement !== null) {\n    for (let i = 0; i < elements.length; i++) {\n      const element = elements[i];\n      wrappingElement.append(element);\n    }\n  }\n  let lastElement = null;\n\n  // If our target is Root-like, let's see if we can re-adjust\n  // so that the target is the first child instead.\n  if ($isRootOrShadowRoot(target)) {\n    if (targetIsPrevSibling) {\n      if (wrappingElement !== null) {\n        target.insertAfter(wrappingElement);\n      } else {\n        for (let i = elements.length - 1; i >= 0; i--) {\n          const element = elements[i];\n          target.insertAfter(element);\n        }\n      }\n    } else {\n      const firstChild = target.getFirstChild();\n      if ($isElementNode(firstChild)) {\n        target = firstChild;\n      }\n      if (firstChild === null) {\n        if (wrappingElement) {\n          target.append(wrappingElement);\n        } else {\n          for (let i = 0; i < elements.length; i++) {\n            const element = elements[i];\n            target.append(element);\n            lastElement = element;\n          }\n        }\n      } else {\n        if (wrappingElement !== null) {\n          firstChild.insertBefore(wrappingElement);\n        } else {\n          for (let i = 0; i < elements.length; i++) {\n            const element = elements[i];\n            firstChild.insertBefore(element);\n            lastElement = element;\n          }\n        }\n      }\n    }\n  } else {\n    if (wrappingElement) {\n      target.insertAfter(wrappingElement);\n    } else {\n      for (let i = elements.length - 1; i >= 0; i--) {\n        const element = elements[i];\n        target.insertAfter(element);\n        lastElement = element;\n      }\n    }\n  }\n  const prevSelection = $getPreviousSelection();\n  if ($isRangeSelection(prevSelection) && isPointAttached(prevSelection.anchor) && isPointAttached(prevSelection.focus)) {\n    $setSelection(prevSelection.clone());\n  } else if (lastElement !== null) {\n    lastElement.selectEnd();\n  } else {\n    selection.dirty = true;\n  }\n}\n\n/**\n * Tests if the selection's parent element has vertical writing mode.\n * @param selection - The selection whose parent to test.\n * @returns true if the selection's parent has vertical writing mode (writing-mode: vertical-rl), false otherwise.\n */\nfunction $isEditorVerticalOrientation(selection) {\n  const anchorNode = selection.anchor.getNode();\n  const parent = $isRootNode(anchorNode) ? anchorNode : anchorNode.getParentOrThrow();\n  const editor = $getEditor();\n  const domElement = editor.getElementByKey(parent.getKey());\n  if (domElement === null) {\n    return false;\n  }\n  const view = domElement.ownerDocument.defaultView;\n  if (view === null) {\n    return false;\n  }\n  const computedStyle = view.getComputedStyle(domElement);\n  return computedStyle.writingMode === 'vertical-rl';\n}\n\n/**\n * Determines if the default character selection should be overridden. Used with DecoratorNodes\n * @param selection - The selection whose default character selection may need to be overridden.\n * @param isBackward - Is the selection backwards (the focus comes before the anchor)?\n * @returns true if it should be overridden, false if not.\n */\nfunction $shouldOverrideDefaultCharacterSelection(selection, isBackward) {\n  const isVertical = $isEditorVerticalOrientation(selection);\n\n  // In vertical writing mode, we adjust the direction for correct caret movement\n  const adjustedIsBackward = isVertical ? !isBackward : isBackward;\n  const focusCaret = $caretFromPoint(selection.focus, adjustedIsBackward ? 'previous' : 'next');\n  if ($isExtendableTextPointCaret(focusCaret)) {\n    return false;\n  }\n  for (const nextCaret of $extendCaretToRange(focusCaret)) {\n    if ($isChildCaret(nextCaret)) {\n      return !nextCaret.origin.isInline();\n    } else if ($isElementNode(nextCaret.origin)) {\n      continue;\n    } else if ($isDecoratorNode(nextCaret.origin)) {\n      return true;\n    }\n    break;\n  }\n  return false;\n}\n\n/**\n * Moves the selection according to the arguments.\n * @param selection - The selected text or nodes.\n * @param isHoldingShift - Is the shift key being held down during the operation.\n * @param isBackward - Is the selection selected backwards (the focus comes before the anchor)?\n * @param granularity - The distance to adjust the current selection.\n */\nfunction $moveCaretSelection(selection, isHoldingShift, isBackward, granularity) {\n  selection.modify(isHoldingShift ? 'extend' : 'move', isBackward, granularity);\n}\n\n/**\n * Tests a parent element for right to left direction.\n * @param selection - The selection whose parent is to be tested.\n * @returns true if the selections' parent element has a direction of 'rtl' (right to left), false otherwise.\n */\nfunction $isParentElementRTL(selection) {\n  const anchorNode = selection.anchor.getNode();\n  const parent = $isRootNode(anchorNode) ? anchorNode : anchorNode.getParentOrThrow();\n  return parent.getDirection() === 'rtl';\n}\n\n/**\n * Moves selection by character according to arguments.\n * @param selection - The selection of the characters to move.\n * @param isHoldingShift - Is the shift key being held down during the operation.\n * @param isBackward - Is the selection backward (the focus comes before the anchor)?\n */\nfunction $moveCharacter(selection, isHoldingShift, isBackward) {\n  const isRTL = $isParentElementRTL(selection);\n  const isVertical = $isEditorVerticalOrientation(selection);\n\n  // In vertical-rl writing mode, arrow key directions need to be flipped\n  // to match the visual flow of text (top to bottom, right to left)\n  let adjustedIsBackward;\n  if (isVertical) {\n    // In vertical-rl mode, we need to completely invert the direction\n    // Left arrow (backward) should move down (forward)\n    // Right arrow (forward) should move up (backward)\n    adjustedIsBackward = !isBackward;\n  } else if (isRTL) {\n    // In horizontal RTL mode, use the standard RTL behavior\n    adjustedIsBackward = !isBackward;\n  } else {\n    // Standard LTR horizontal text\n    adjustedIsBackward = isBackward;\n  }\n\n  // Apply the direction adjustment to move the caret\n  $moveCaretSelection(selection, isHoldingShift, adjustedIsBackward, 'character');\n}\n\n/**\n * Returns the current value of a CSS property for Nodes, if set. If not set, it returns the defaultValue.\n * @param node - The node whose style value to get.\n * @param styleProperty - The CSS style property.\n * @param defaultValue - The default value for the property.\n * @returns The value of the property for node.\n */\nfunction $getNodeStyleValueForProperty(node, styleProperty, defaultValue) {\n  const css = node.getStyle();\n  const styleObject = getStyleObjectFromCSS(css);\n  if (styleObject !== null) {\n    return styleObject[styleProperty] || defaultValue;\n  }\n  return defaultValue;\n}\n\n/**\n * Returns the current value of a CSS property for TextNodes in the Selection, if set. If not set, it returns the defaultValue.\n * If all TextNodes do not have the same value, it returns an empty string.\n * @param selection - The selection of TextNodes whose value to find.\n * @param styleProperty - The CSS style property.\n * @param defaultValue - The default value for the property, defaults to an empty string.\n * @returns The value of the property for the selected TextNodes.\n */\nfunction $getSelectionStyleValueForProperty(selection, styleProperty, defaultValue = '') {\n  let styleValue = null;\n  const nodes = selection.getNodes();\n  const anchor = selection.anchor;\n  const focus = selection.focus;\n  const isBackward = selection.isBackward();\n  const endOffset = isBackward ? focus.offset : anchor.offset;\n  const endNode = isBackward ? focus.getNode() : anchor.getNode();\n  if ($isRangeSelection(selection) && selection.isCollapsed() && selection.style !== '') {\n    const css = selection.style;\n    const styleObject = getStyleObjectFromCSS(css);\n    if (styleObject !== null && styleProperty in styleObject) {\n      return styleObject[styleProperty];\n    }\n  }\n  for (let i = 0; i < nodes.length; i++) {\n    const node = nodes[i];\n\n    // if no actual characters in the end node are selected, we don't\n    // include it in the selection for purposes of determining style\n    // value\n    if (i !== 0 && endOffset === 0 && node.is(endNode)) {\n      continue;\n    }\n    if ($isTextNode(node)) {\n      const nodeStyleValue = $getNodeStyleValueForProperty(node, styleProperty, defaultValue);\n      if (styleValue === null) {\n        styleValue = nodeStyleValue;\n      } else if (styleValue !== nodeStyleValue) {\n        // multiple text nodes are in the selection and they don't all\n        // have the same style.\n        styleValue = '';\n        break;\n      }\n    }\n  }\n  return styleValue === null ? defaultValue : styleValue;\n}\nfunction $getAncestor(node, predicate) {\n  let parent = node;\n  while (parent !== null && parent.getParent() !== null && !predicate(parent)) {\n    parent = parent.getParentOrThrow();\n  }\n  return predicate(parent) ? parent : null;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/** @deprecated renamed to {@link $trimTextContentFromAnchor} by @lexical/eslint-plugin rules-of-lexical */\nconst trimTextContentFromAnchor = $trimTextContentFromAnchor;\nexport { $addNodeStyle, $copyBlockFormatIndent, $ensureForwardRangeSelection, $forEachSelectedTextNode, $getSelectionStyleValueForProperty, $isAtNodeEnd, $isParentElementRTL, $moveCaretSelection, $moveCharacter, $patchStyleText, $setBlocksType, $shouldOverrideDefaultCharacterSelection, $sliceSelectedTextNodeContent, $trimTextContentFromAnchor, $wrapNodes, createDOMRange, createRectsFromDOMRange, getCSSFromStyleObject, getStyleObjectFromCSS, trimTextContentFromAnchor };","map":{"version":3,"names":["$isTextNode","$isTokenOrSegmented","$getCharacterOffsets","$isElementNode","$isRootNode","$getNodeByKey","$getPreviousSelection","$createTextNode","$isRangeSelection","$getSelection","$caretRangeFromSelection","$createRangeSelection","INTERNAL_$isBlock","$setSelection","$isRootOrShadowRoot","$hasAncestor","$isLeafNode","$caretFromPoint","$isExtendableTextPointCaret","$extendCaretToRange","$isChildCaret","$isDecoratorNode","$getEditor","$cloneWithProperties","$selectAll","formatDevErrorMessage","message","Error","CSS_TO_STYLES","Map","getDOMTextNode","element","node","nodeType","Node","TEXT_NODE","firstChild","getDOMIndexWithinParent","parent","parentNode","Array","from","childNodes","indexOf","createDOMRange","editor","anchorNode","_anchorOffset","focusNode","_focusOffset","anchorKey","getKey","focusKey","range","document","createRange","anchorDOM","getElementByKey","focusDOM","anchorOffset","focusOffset","undefined","nodeName","setStart","setEnd","e","collapsed","createRectsFromDOMRange","rootElement","getRootElement","rootRect","getBoundingClientRect","computedStyle","getComputedStyle","rootPadding","parseFloat","paddingLeft","paddingRight","selectionRects","getClientRects","selectionRectsLength","length","sort","a","b","top","Math","abs","left","prevRect","i","selectionRect","isOverlappingRect","height","width","selectionSpansElement","splice","getStyleObjectFromRawCSS","css","styleObject","styles","split","style","key","value","trim","getStyleObjectFromCSS","get","set","Object","freeze","getCSSFromStyleObject","$sliceSelectedTextNodeContent","selection","textNode","anchorAndFocus","getStartEndPoints","isSelected","anchor","focus","isBackward","getNode","isAnchor","is","isFocus","isSame","isFirst","isLast","startOffset","endOffset","offset","__text","slice","$isAtNodeEnd","point","type","getTextContentSize","getChildrenSize","$trimTextContentFromAnchor","delCount","currentNode","remaining","descendantNode","getDescendantByIndex","lastDescendant","getLastDescendant","nextNode","getPreviousSibling","additionalElementWhitespace","getParentOrThrow","parentSibling","getParent","isInline","text","getTextContent","currentNodeSize","remove","prevTextContent","getEditorState","read","prevNode","isSimpleText","slicedText","prevSelection","target","replace","setTextContent","isCollapsed","prevOffset","select","splitStart","splitEnd","excessNode","splitText","$addNodeStyle","CSSText","getStyle","$patchStyle","patch","prevStyles","getTextStyle","newStyles","entries","reduce","newCSSText","setStyle","setTextStyle","$patchStyleText","emptyNode","isEmpty","$forEachSelectedTextNode","fn","slicedTextNodes","getSliceIndices","getTextSlices","caret","origin","selectedNodes","getNodes","selectedNode","canHaveFormat","splitNodes","replacement","$ensureForwardRangeSelection","$copyBlockFormatIndent","srcNode","destNode","format","getFormatType","indent","getIndent","setFormat","setIndent","$setBlocksType","$createElement","$afterCreateElement","blockMap","newSelection","anchorBlock","$getAncestor","focusBlock","ancestorBlock","isPointAttached","isAttached","$removeParentEmptyElements","startingNode","latest","getLatest","$wrapNodes","createElement","wrappingElement","nodes","nodesLength","children","getChildren","forEach","child","append","topLevelNode","descendants","$wrapNodesImpl","push","firstNode","elementMapping","elements","targetIsPrevSibling","prevSibling","emptyElements","Set","add","movedNodes","has","parentKey","targetElement","getChildrenKeys","lastElement","insertAfter","getFirstChild","insertBefore","clone","selectEnd","dirty","$isEditorVerticalOrientation","domElement","view","ownerDocument","defaultView","writingMode","$shouldOverrideDefaultCharacterSelection","isVertical","adjustedIsBackward","focusCaret","nextCaret","$moveCaretSelection","isHoldingShift","granularity","modify","$isParentElementRTL","getDirection","$moveCharacter","isRTL","$getNodeStyleValueForProperty","styleProperty","defaultValue","$getSelectionStyleValueForProperty","styleValue","endNode","nodeStyleValue","predicate","trimTextContentFromAnchor"],"sources":["C:/Code/beedoo/node_modules/@lexical/selection/LexicalSelection.dev.mjs"],"sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport { $isTextNode, $isTokenOrSegmented, $getCharacterOffsets, $isElementNode, $isRootNode, $getNodeByKey, $getPreviousSelection, $createTextNode, $isRangeSelection, $getSelection, $caretRangeFromSelection, $createRangeSelection, INTERNAL_$isBlock, $setSelection, $isRootOrShadowRoot, $hasAncestor, $isLeafNode, $caretFromPoint, $isExtendableTextPointCaret, $extendCaretToRange, $isChildCaret, $isDecoratorNode, $getEditor } from 'lexical';\nexport { $cloneWithProperties, $selectAll } from 'lexical';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n// Do not require this module directly! Use normal `invariant` calls.\n\nfunction formatDevErrorMessage(message) {\n  throw new Error(message);\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nconst CSS_TO_STYLES = new Map();\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction getDOMTextNode(element) {\n  let node = element;\n  while (node != null) {\n    if (node.nodeType === Node.TEXT_NODE) {\n      return node;\n    }\n    node = node.firstChild;\n  }\n  return null;\n}\nfunction getDOMIndexWithinParent(node) {\n  const parent = node.parentNode;\n  if (parent == null) {\n    throw new Error('Should never happen');\n  }\n  return [parent, Array.from(parent.childNodes).indexOf(node)];\n}\n\n/**\n * Creates a selection range for the DOM.\n * @param editor - The lexical editor.\n * @param anchorNode - The anchor node of a selection.\n * @param _anchorOffset - The amount of space offset from the anchor to the focus.\n * @param focusNode - The current focus.\n * @param _focusOffset - The amount of space offset from the focus to the anchor.\n * @returns The range of selection for the DOM that was created.\n */\nfunction createDOMRange(editor, anchorNode, _anchorOffset, focusNode, _focusOffset) {\n  const anchorKey = anchorNode.getKey();\n  const focusKey = focusNode.getKey();\n  const range = document.createRange();\n  let anchorDOM = editor.getElementByKey(anchorKey);\n  let focusDOM = editor.getElementByKey(focusKey);\n  let anchorOffset = _anchorOffset;\n  let focusOffset = _focusOffset;\n  if ($isTextNode(anchorNode)) {\n    anchorDOM = getDOMTextNode(anchorDOM);\n  }\n  if ($isTextNode(focusNode)) {\n    focusDOM = getDOMTextNode(focusDOM);\n  }\n  if (anchorNode === undefined || focusNode === undefined || anchorDOM === null || focusDOM === null) {\n    return null;\n  }\n  if (anchorDOM.nodeName === 'BR') {\n    [anchorDOM, anchorOffset] = getDOMIndexWithinParent(anchorDOM);\n  }\n  if (focusDOM.nodeName === 'BR') {\n    [focusDOM, focusOffset] = getDOMIndexWithinParent(focusDOM);\n  }\n  const firstChild = anchorDOM.firstChild;\n  if (anchorDOM === focusDOM && firstChild != null && firstChild.nodeName === 'BR' && anchorOffset === 0 && focusOffset === 0) {\n    focusOffset = 1;\n  }\n  try {\n    range.setStart(anchorDOM, anchorOffset);\n    range.setEnd(focusDOM, focusOffset);\n  } catch (e) {\n    return null;\n  }\n  if (range.collapsed && (anchorOffset !== focusOffset || anchorKey !== focusKey)) {\n    // Range is backwards, we need to reverse it\n    range.setStart(focusDOM, focusOffset);\n    range.setEnd(anchorDOM, anchorOffset);\n  }\n  return range;\n}\n\n/**\n * Creates DOMRects, generally used to help the editor find a specific location on the screen.\n * @param editor - The lexical editor\n * @param range - A fragment of a document that can contain nodes and parts of text nodes.\n * @returns The selectionRects as an array.\n */\nfunction createRectsFromDOMRange(editor, range) {\n  const rootElement = editor.getRootElement();\n  if (rootElement === null) {\n    return [];\n  }\n  const rootRect = rootElement.getBoundingClientRect();\n  const computedStyle = getComputedStyle(rootElement);\n  const rootPadding = parseFloat(computedStyle.paddingLeft) + parseFloat(computedStyle.paddingRight);\n  const selectionRects = Array.from(range.getClientRects());\n  let selectionRectsLength = selectionRects.length;\n  //sort rects from top left to bottom right.\n  selectionRects.sort((a, b) => {\n    const top = a.top - b.top;\n    // Some rects match position closely, but not perfectly,\n    // so we give a 3px tolerance.\n    if (Math.abs(top) <= 3) {\n      return a.left - b.left;\n    }\n    return top;\n  });\n  let prevRect;\n  for (let i = 0; i < selectionRectsLength; i++) {\n    const selectionRect = selectionRects[i];\n    // Exclude rects that overlap preceding Rects in the sorted list.\n    const isOverlappingRect = prevRect && prevRect.top <= selectionRect.top && prevRect.top + prevRect.height > selectionRect.top && prevRect.left + prevRect.width > selectionRect.left;\n    // Exclude selections that span the entire element\n    const selectionSpansElement = selectionRect.width + rootPadding === rootRect.width;\n    if (isOverlappingRect || selectionSpansElement) {\n      selectionRects.splice(i--, 1);\n      selectionRectsLength--;\n      continue;\n    }\n    prevRect = selectionRect;\n  }\n  return selectionRects;\n}\n\n/**\n * Creates an object containing all the styles and their values provided in the CSS string.\n * @param css - The CSS string of styles and their values.\n * @returns The styleObject containing all the styles and their values.\n */\nfunction getStyleObjectFromRawCSS(css) {\n  const styleObject = {};\n  if (!css) {\n    return styleObject;\n  }\n  const styles = css.split(';');\n  for (const style of styles) {\n    if (style !== '') {\n      const [key, value] = style.split(/:([^]+)/); // split on first colon\n      if (key && value) {\n        styleObject[key.trim()] = value.trim();\n      }\n    }\n  }\n  return styleObject;\n}\n\n/**\n * Given a CSS string, returns an object from the style cache.\n * @param css - The CSS property as a string.\n * @returns The value of the given CSS property.\n */\nfunction getStyleObjectFromCSS(css) {\n  let value = CSS_TO_STYLES.get(css);\n  if (value === undefined) {\n    value = getStyleObjectFromRawCSS(css);\n    CSS_TO_STYLES.set(css, value);\n  }\n  {\n    // Freeze the value in DEV to prevent accidental mutations\n    Object.freeze(value);\n  }\n  return value;\n}\n\n/**\n * Gets the CSS styles from the style object.\n * @param styles - The style object containing the styles to get.\n * @returns A string containing the CSS styles and their values.\n */\nfunction getCSSFromStyleObject(styles) {\n  let css = '';\n  for (const style in styles) {\n    if (style) {\n      css += `${style}: ${styles[style]};`;\n    }\n  }\n  return css;\n}\n\n/**\n * Generally used to append text content to HTML and JSON. Grabs the text content and \"slices\"\n * it to be generated into the new TextNode.\n * @param selection - The selection containing the node whose TextNode is to be edited.\n * @param textNode - The TextNode to be edited.\n * @returns The updated TextNode.\n */\nfunction $sliceSelectedTextNodeContent(selection, textNode) {\n  const anchorAndFocus = selection.getStartEndPoints();\n  if (textNode.isSelected(selection) && !$isTokenOrSegmented(textNode) && anchorAndFocus !== null) {\n    const [anchor, focus] = anchorAndFocus;\n    const isBackward = selection.isBackward();\n    const anchorNode = anchor.getNode();\n    const focusNode = focus.getNode();\n    const isAnchor = textNode.is(anchorNode);\n    const isFocus = textNode.is(focusNode);\n    if (isAnchor || isFocus) {\n      const [anchorOffset, focusOffset] = $getCharacterOffsets(selection);\n      const isSame = anchorNode.is(focusNode);\n      const isFirst = textNode.is(isBackward ? focusNode : anchorNode);\n      const isLast = textNode.is(isBackward ? anchorNode : focusNode);\n      let startOffset = 0;\n      let endOffset = undefined;\n      if (isSame) {\n        startOffset = anchorOffset > focusOffset ? focusOffset : anchorOffset;\n        endOffset = anchorOffset > focusOffset ? anchorOffset : focusOffset;\n      } else if (isFirst) {\n        const offset = isBackward ? focusOffset : anchorOffset;\n        startOffset = offset;\n        endOffset = undefined;\n      } else if (isLast) {\n        const offset = isBackward ? anchorOffset : focusOffset;\n        startOffset = 0;\n        endOffset = offset;\n      }\n\n      // NOTE: This mutates __text directly because the primary use case is to\n      // modify a $cloneWithProperties node that should never be added\n      // to the EditorState so we must not call getWritable via setTextContent\n      textNode.__text = textNode.__text.slice(startOffset, endOffset);\n    }\n  }\n  return textNode;\n}\n\n/**\n * Determines if the current selection is at the end of the node.\n * @param point - The point of the selection to test.\n * @returns true if the provided point offset is in the last possible position, false otherwise.\n */\nfunction $isAtNodeEnd(point) {\n  if (point.type === 'text') {\n    return point.offset === point.getNode().getTextContentSize();\n  }\n  const node = point.getNode();\n  if (!$isElementNode(node)) {\n    formatDevErrorMessage(`isAtNodeEnd: node must be a TextNode or ElementNode`);\n  }\n  return point.offset === node.getChildrenSize();\n}\n\n/**\n * Trims text from a node in order to shorten it, eg. to enforce a text's max length. If it deletes text\n * that is an ancestor of the anchor then it will leave 2 indents, otherwise, if no text content exists, it deletes\n * the TextNode. It will move the focus to either the end of any left over text or beginning of a new TextNode.\n * @param editor - The lexical editor.\n * @param anchor - The anchor of the current selection, where the selection should be pointing.\n * @param delCount - The amount of characters to delete. Useful as a dynamic variable eg. textContentSize - maxLength;\n */\nfunction $trimTextContentFromAnchor(editor, anchor, delCount) {\n  // Work from the current selection anchor point\n  let currentNode = anchor.getNode();\n  let remaining = delCount;\n  if ($isElementNode(currentNode)) {\n    const descendantNode = currentNode.getDescendantByIndex(anchor.offset);\n    if (descendantNode !== null) {\n      currentNode = descendantNode;\n    }\n  }\n  while (remaining > 0 && currentNode !== null) {\n    if ($isElementNode(currentNode)) {\n      const lastDescendant = currentNode.getLastDescendant();\n      if (lastDescendant !== null) {\n        currentNode = lastDescendant;\n      }\n    }\n    let nextNode = currentNode.getPreviousSibling();\n    let additionalElementWhitespace = 0;\n    if (nextNode === null) {\n      let parent = currentNode.getParentOrThrow();\n      let parentSibling = parent.getPreviousSibling();\n      while (parentSibling === null) {\n        parent = parent.getParent();\n        if (parent === null) {\n          nextNode = null;\n          break;\n        }\n        parentSibling = parent.getPreviousSibling();\n      }\n      if (parent !== null) {\n        additionalElementWhitespace = parent.isInline() ? 0 : 2;\n        nextNode = parentSibling;\n      }\n    }\n    let text = currentNode.getTextContent();\n    // If the text is empty, we need to consider adding in two line breaks to match\n    // the content if we were to get it from its parent.\n    if (text === '' && $isElementNode(currentNode) && !currentNode.isInline()) {\n      // TODO: should this be handled in core?\n      text = '\\n\\n';\n    }\n    const currentNodeSize = text.length;\n    if (!$isTextNode(currentNode) || remaining >= currentNodeSize) {\n      const parent = currentNode.getParent();\n      currentNode.remove();\n      if (parent != null && parent.getChildrenSize() === 0 && !$isRootNode(parent)) {\n        parent.remove();\n      }\n      remaining -= currentNodeSize + additionalElementWhitespace;\n      currentNode = nextNode;\n    } else {\n      const key = currentNode.getKey();\n      // See if we can just revert it to what was in the last editor state\n      const prevTextContent = editor.getEditorState().read(() => {\n        const prevNode = $getNodeByKey(key);\n        if ($isTextNode(prevNode) && prevNode.isSimpleText()) {\n          return prevNode.getTextContent();\n        }\n        return null;\n      });\n      const offset = currentNodeSize - remaining;\n      const slicedText = text.slice(0, offset);\n      if (prevTextContent !== null && prevTextContent !== text) {\n        const prevSelection = $getPreviousSelection();\n        let target = currentNode;\n        if (!currentNode.isSimpleText()) {\n          const textNode = $createTextNode(prevTextContent);\n          currentNode.replace(textNode);\n          target = textNode;\n        } else {\n          currentNode.setTextContent(prevTextContent);\n        }\n        if ($isRangeSelection(prevSelection) && prevSelection.isCollapsed()) {\n          const prevOffset = prevSelection.anchor.offset;\n          target.select(prevOffset, prevOffset);\n        }\n      } else if (currentNode.isSimpleText()) {\n        // Split text\n        const isSelected = anchor.key === key;\n        let anchorOffset = anchor.offset;\n        // Move offset to end if it's less than the remaining number, otherwise\n        // we'll have a negative splitStart.\n        if (anchorOffset < remaining) {\n          anchorOffset = currentNodeSize;\n        }\n        const splitStart = isSelected ? anchorOffset - remaining : 0;\n        const splitEnd = isSelected ? anchorOffset : offset;\n        if (isSelected && splitStart === 0) {\n          const [excessNode] = currentNode.splitText(splitStart, splitEnd);\n          excessNode.remove();\n        } else {\n          const [, excessNode] = currentNode.splitText(splitStart, splitEnd);\n          excessNode.remove();\n        }\n      } else {\n        const textNode = $createTextNode(slicedText);\n        currentNode.replace(textNode);\n      }\n      remaining = 0;\n    }\n  }\n}\n\n/**\n * Gets the TextNode's style object and adds the styles to the CSS.\n * @param node - The TextNode to add styles to.\n */\nfunction $addNodeStyle(node) {\n  const CSSText = node.getStyle();\n  const styles = getStyleObjectFromRawCSS(CSSText);\n  CSS_TO_STYLES.set(CSSText, styles);\n}\n\n/**\n * Applies the provided styles to the given TextNode, ElementNode, or\n * collapsed RangeSelection.\n *\n * @param target - The TextNode, ElementNode, or collapsed RangeSelection to apply the styles to\n * @param patch - The patch to apply, which can include multiple styles. \\\\{CSSProperty: value\\\\} . Can also accept a function that returns the new property value.\n */\nfunction $patchStyle(target, patch) {\n  if (!($isRangeSelection(target) ? target.isCollapsed() : $isTextNode(target) || $isElementNode(target))) {\n    formatDevErrorMessage(`$patchStyle must only be called with a TextNode, ElementNode, or collapsed RangeSelection`);\n  }\n  const prevStyles = getStyleObjectFromCSS($isRangeSelection(target) ? target.style : $isTextNode(target) ? target.getStyle() : target.getTextStyle());\n  const newStyles = Object.entries(patch).reduce((styles, [key, value]) => {\n    if (typeof value === 'function') {\n      styles[key] = value(prevStyles[key], target);\n    } else if (value === null) {\n      delete styles[key];\n    } else {\n      styles[key] = value;\n    }\n    return styles;\n  }, {\n    ...prevStyles\n  });\n  const newCSSText = getCSSFromStyleObject(newStyles);\n  if ($isRangeSelection(target) || $isTextNode(target)) {\n    target.setStyle(newCSSText);\n  } else {\n    target.setTextStyle(newCSSText);\n  }\n  CSS_TO_STYLES.set(newCSSText, newStyles);\n}\n\n/**\n * Applies the provided styles to the TextNodes in the provided Selection.\n * Will update partially selected TextNodes by splitting the TextNode and applying\n * the styles to the appropriate one.\n * @param selection - The selected node(s) to update.\n * @param patch - The patch to apply, which can include multiple styles. \\\\{CSSProperty: value\\\\} . Can also accept a function that returns the new property value.\n */\nfunction $patchStyleText(selection, patch) {\n  if ($isRangeSelection(selection) && selection.isCollapsed()) {\n    $patchStyle(selection, patch);\n    const emptyNode = selection.anchor.getNode();\n    if ($isElementNode(emptyNode) && emptyNode.isEmpty()) {\n      $patchStyle(emptyNode, patch);\n    }\n  }\n  $forEachSelectedTextNode(textNode => {\n    $patchStyle(textNode, patch);\n  });\n}\nfunction $forEachSelectedTextNode(fn) {\n  const selection = $getSelection();\n  if (!selection) {\n    return;\n  }\n  const slicedTextNodes = new Map();\n  const getSliceIndices = node => slicedTextNodes.get(node.getKey()) || [0, node.getTextContentSize()];\n  if ($isRangeSelection(selection)) {\n    for (const slice of $caretRangeFromSelection(selection).getTextSlices()) {\n      if (slice) {\n        slicedTextNodes.set(slice.caret.origin.getKey(), slice.getSliceIndices());\n      }\n    }\n  }\n  const selectedNodes = selection.getNodes();\n  for (const selectedNode of selectedNodes) {\n    if (!($isTextNode(selectedNode) && selectedNode.canHaveFormat())) {\n      continue;\n    }\n    const [startOffset, endOffset] = getSliceIndices(selectedNode);\n    // No actual text is selected, so do nothing.\n    if (endOffset === startOffset) {\n      continue;\n    }\n\n    // The entire node is selected or a token/segment, so just format it\n    if ($isTokenOrSegmented(selectedNode) || startOffset === 0 && endOffset === selectedNode.getTextContentSize()) {\n      fn(selectedNode);\n    } else {\n      // The node is partially selected, so split it into two or three nodes\n      // and style the selected one.\n      const splitNodes = selectedNode.splitText(startOffset, endOffset);\n      const replacement = splitNodes[startOffset === 0 ? 0 : 1];\n      fn(replacement);\n    }\n  }\n  // Prior to NodeCaret #7046 this would have been a side-effect\n  // so we do this for test compatibility.\n  // TODO: we may want to consider simplifying by removing this\n  if ($isRangeSelection(selection) && selection.anchor.type === 'text' && selection.focus.type === 'text' && selection.anchor.key === selection.focus.key) {\n    $ensureForwardRangeSelection(selection);\n  }\n}\n\n/**\n * Ensure that the given RangeSelection is not backwards. If it\n * is backwards, then the anchor and focus points will be swapped\n * in-place. Ensuring that the selection is a writable RangeSelection\n * is the responsibility of the caller (e.g. in a read-only context\n * you will want to clone $getSelection() before using this).\n *\n * @param selection a writable RangeSelection\n */\nfunction $ensureForwardRangeSelection(selection) {\n  if (selection.isBackward()) {\n    const {\n      anchor,\n      focus\n    } = selection;\n    // stash for the in-place swap\n    const {\n      key,\n      offset,\n      type\n    } = anchor;\n    anchor.set(focus.key, focus.offset, focus.type);\n    focus.set(key, offset, type);\n  }\n}\n\nfunction $copyBlockFormatIndent(srcNode, destNode) {\n  const format = srcNode.getFormatType();\n  const indent = srcNode.getIndent();\n  if (format !== destNode.getFormatType()) {\n    destNode.setFormat(format);\n  }\n  if (indent !== destNode.getIndent()) {\n    destNode.setIndent(indent);\n  }\n}\n\n/**\n * Converts all nodes in the selection that are of one block type to another.\n * @param selection - The selected blocks to be converted.\n * @param $createElement - The function that creates the node. eg. $createParagraphNode.\n * @param $afterCreateElement - The function that updates the new node based on the previous one ($copyBlockFormatIndent by default)\n */\nfunction $setBlocksType(selection, $createElement, $afterCreateElement = $copyBlockFormatIndent) {\n  if (selection === null) {\n    return;\n  }\n  // Selections tend to not include their containing blocks so we effectively\n  // expand it here\n  const anchorAndFocus = selection.getStartEndPoints();\n  const blockMap = new Map();\n  let newSelection = null;\n  if (anchorAndFocus) {\n    const [anchor, focus] = anchorAndFocus;\n    newSelection = $createRangeSelection();\n    newSelection.anchor.set(anchor.key, anchor.offset, anchor.type);\n    newSelection.focus.set(focus.key, focus.offset, focus.type);\n    const anchorBlock = $getAncestor(anchor.getNode(), INTERNAL_$isBlock);\n    const focusBlock = $getAncestor(focus.getNode(), INTERNAL_$isBlock);\n    if ($isElementNode(anchorBlock)) {\n      blockMap.set(anchorBlock.getKey(), anchorBlock);\n    }\n    if ($isElementNode(focusBlock)) {\n      blockMap.set(focusBlock.getKey(), focusBlock);\n    }\n  }\n  for (const node of selection.getNodes()) {\n    if ($isElementNode(node) && INTERNAL_$isBlock(node)) {\n      blockMap.set(node.getKey(), node);\n    } else if (anchorAndFocus === null) {\n      const ancestorBlock = $getAncestor(node, INTERNAL_$isBlock);\n      if ($isElementNode(ancestorBlock)) {\n        blockMap.set(ancestorBlock.getKey(), ancestorBlock);\n      }\n    }\n  }\n  for (const [key, prevNode] of blockMap) {\n    const element = $createElement();\n    $afterCreateElement(prevNode, element);\n    prevNode.replace(element, true);\n    if (newSelection) {\n      if (key === newSelection.anchor.key) {\n        newSelection.anchor.set(element.getKey(), newSelection.anchor.offset, newSelection.anchor.type);\n      }\n      if (key === newSelection.focus.key) {\n        newSelection.focus.set(element.getKey(), newSelection.focus.offset, newSelection.focus.type);\n      }\n    }\n  }\n  if (newSelection && selection.is($getSelection())) {\n    $setSelection(newSelection);\n  }\n}\nfunction isPointAttached(point) {\n  return point.getNode().isAttached();\n}\nfunction $removeParentEmptyElements(startingNode) {\n  let node = startingNode;\n  while (node !== null && !$isRootOrShadowRoot(node)) {\n    const latest = node.getLatest();\n    const parentNode = node.getParent();\n    if (latest.getChildrenSize() === 0) {\n      node.remove(true);\n    }\n    node = parentNode;\n  }\n}\n\n/**\n * @deprecated In favor of $setBlockTypes\n * Wraps all nodes in the selection into another node of the type returned by createElement.\n * @param selection - The selection of nodes to be wrapped.\n * @param createElement - A function that creates the wrapping ElementNode. eg. $createParagraphNode.\n * @param wrappingElement - An element to append the wrapped selection and its children to.\n */\nfunction $wrapNodes(selection, createElement, wrappingElement = null) {\n  const anchorAndFocus = selection.getStartEndPoints();\n  const anchor = anchorAndFocus ? anchorAndFocus[0] : null;\n  const nodes = selection.getNodes();\n  const nodesLength = nodes.length;\n  if (anchor !== null && (nodesLength === 0 || nodesLength === 1 && anchor.type === 'element' && anchor.getNode().getChildrenSize() === 0)) {\n    const target = anchor.type === 'text' ? anchor.getNode().getParentOrThrow() : anchor.getNode();\n    const children = target.getChildren();\n    let element = createElement();\n    element.setFormat(target.getFormatType());\n    element.setIndent(target.getIndent());\n    children.forEach(child => element.append(child));\n    if (wrappingElement) {\n      element = wrappingElement.append(element);\n    }\n    target.replace(element);\n    return;\n  }\n  let topLevelNode = null;\n  let descendants = [];\n  for (let i = 0; i < nodesLength; i++) {\n    const node = nodes[i];\n    // Determine whether wrapping has to be broken down into multiple chunks. This can happen if the\n    // user selected multiple Root-like nodes that have to be treated separately as if they are\n    // their own branch. I.e. you don't want to wrap a whole table, but rather the contents of each\n    // of each of the cell nodes.\n    if ($isRootOrShadowRoot(node)) {\n      $wrapNodesImpl(selection, descendants, descendants.length, createElement, wrappingElement);\n      descendants = [];\n      topLevelNode = node;\n    } else if (topLevelNode === null || topLevelNode !== null && $hasAncestor(node, topLevelNode)) {\n      descendants.push(node);\n    } else {\n      $wrapNodesImpl(selection, descendants, descendants.length, createElement, wrappingElement);\n      descendants = [node];\n    }\n  }\n  $wrapNodesImpl(selection, descendants, descendants.length, createElement, wrappingElement);\n}\n\n/**\n * Wraps each node into a new ElementNode.\n * @param selection - The selection of nodes to wrap.\n * @param nodes - An array of nodes, generally the descendants of the selection.\n * @param nodesLength - The length of nodes.\n * @param createElement - A function that creates the wrapping ElementNode. eg. $createParagraphNode.\n * @param wrappingElement - An element to wrap all the nodes into.\n * @returns\n */\nfunction $wrapNodesImpl(selection, nodes, nodesLength, createElement, wrappingElement = null) {\n  if (nodes.length === 0) {\n    return;\n  }\n  const firstNode = nodes[0];\n  const elementMapping = new Map();\n  const elements = [];\n  // The below logic is to find the right target for us to\n  // either insertAfter/insertBefore/append the corresponding\n  // elements to. This is made more complicated due to nested\n  // structures.\n  let target = $isElementNode(firstNode) ? firstNode : firstNode.getParentOrThrow();\n  if (target.isInline()) {\n    target = target.getParentOrThrow();\n  }\n  let targetIsPrevSibling = false;\n  while (target !== null) {\n    const prevSibling = target.getPreviousSibling();\n    if (prevSibling !== null) {\n      target = prevSibling;\n      targetIsPrevSibling = true;\n      break;\n    }\n    target = target.getParentOrThrow();\n    if ($isRootOrShadowRoot(target)) {\n      break;\n    }\n  }\n  const emptyElements = new Set();\n\n  // Find any top level empty elements\n  for (let i = 0; i < nodesLength; i++) {\n    const node = nodes[i];\n    if ($isElementNode(node) && node.getChildrenSize() === 0) {\n      emptyElements.add(node.getKey());\n    }\n  }\n  const movedNodes = new Set();\n\n  // Move out all leaf nodes into our elements array.\n  // If we find a top level empty element, also move make\n  // an element for that.\n  for (let i = 0; i < nodesLength; i++) {\n    const node = nodes[i];\n    let parent = node.getParent();\n    if (parent !== null && parent.isInline()) {\n      parent = parent.getParent();\n    }\n    if (parent !== null && $isLeafNode(node) && !movedNodes.has(node.getKey())) {\n      const parentKey = parent.getKey();\n      if (elementMapping.get(parentKey) === undefined) {\n        const targetElement = createElement();\n        targetElement.setFormat(parent.getFormatType());\n        targetElement.setIndent(parent.getIndent());\n        elements.push(targetElement);\n        elementMapping.set(parentKey, targetElement);\n        // Move node and its siblings to the new\n        // element.\n        parent.getChildren().forEach(child => {\n          targetElement.append(child);\n          movedNodes.add(child.getKey());\n          if ($isElementNode(child)) {\n            // Skip nested leaf nodes if the parent has already been moved\n            child.getChildrenKeys().forEach(key => movedNodes.add(key));\n          }\n        });\n        $removeParentEmptyElements(parent);\n      }\n    } else if (emptyElements.has(node.getKey())) {\n      if (!$isElementNode(node)) {\n        formatDevErrorMessage(`Expected node in emptyElements to be an ElementNode`);\n      }\n      const targetElement = createElement();\n      targetElement.setFormat(node.getFormatType());\n      targetElement.setIndent(node.getIndent());\n      elements.push(targetElement);\n      node.remove(true);\n    }\n  }\n  if (wrappingElement !== null) {\n    for (let i = 0; i < elements.length; i++) {\n      const element = elements[i];\n      wrappingElement.append(element);\n    }\n  }\n  let lastElement = null;\n\n  // If our target is Root-like, let's see if we can re-adjust\n  // so that the target is the first child instead.\n  if ($isRootOrShadowRoot(target)) {\n    if (targetIsPrevSibling) {\n      if (wrappingElement !== null) {\n        target.insertAfter(wrappingElement);\n      } else {\n        for (let i = elements.length - 1; i >= 0; i--) {\n          const element = elements[i];\n          target.insertAfter(element);\n        }\n      }\n    } else {\n      const firstChild = target.getFirstChild();\n      if ($isElementNode(firstChild)) {\n        target = firstChild;\n      }\n      if (firstChild === null) {\n        if (wrappingElement) {\n          target.append(wrappingElement);\n        } else {\n          for (let i = 0; i < elements.length; i++) {\n            const element = elements[i];\n            target.append(element);\n            lastElement = element;\n          }\n        }\n      } else {\n        if (wrappingElement !== null) {\n          firstChild.insertBefore(wrappingElement);\n        } else {\n          for (let i = 0; i < elements.length; i++) {\n            const element = elements[i];\n            firstChild.insertBefore(element);\n            lastElement = element;\n          }\n        }\n      }\n    }\n  } else {\n    if (wrappingElement) {\n      target.insertAfter(wrappingElement);\n    } else {\n      for (let i = elements.length - 1; i >= 0; i--) {\n        const element = elements[i];\n        target.insertAfter(element);\n        lastElement = element;\n      }\n    }\n  }\n  const prevSelection = $getPreviousSelection();\n  if ($isRangeSelection(prevSelection) && isPointAttached(prevSelection.anchor) && isPointAttached(prevSelection.focus)) {\n    $setSelection(prevSelection.clone());\n  } else if (lastElement !== null) {\n    lastElement.selectEnd();\n  } else {\n    selection.dirty = true;\n  }\n}\n\n/**\n * Tests if the selection's parent element has vertical writing mode.\n * @param selection - The selection whose parent to test.\n * @returns true if the selection's parent has vertical writing mode (writing-mode: vertical-rl), false otherwise.\n */\nfunction $isEditorVerticalOrientation(selection) {\n  const anchorNode = selection.anchor.getNode();\n  const parent = $isRootNode(anchorNode) ? anchorNode : anchorNode.getParentOrThrow();\n  const editor = $getEditor();\n  const domElement = editor.getElementByKey(parent.getKey());\n  if (domElement === null) {\n    return false;\n  }\n  const view = domElement.ownerDocument.defaultView;\n  if (view === null) {\n    return false;\n  }\n  const computedStyle = view.getComputedStyle(domElement);\n  return computedStyle.writingMode === 'vertical-rl';\n}\n\n/**\n * Determines if the default character selection should be overridden. Used with DecoratorNodes\n * @param selection - The selection whose default character selection may need to be overridden.\n * @param isBackward - Is the selection backwards (the focus comes before the anchor)?\n * @returns true if it should be overridden, false if not.\n */\nfunction $shouldOverrideDefaultCharacterSelection(selection, isBackward) {\n  const isVertical = $isEditorVerticalOrientation(selection);\n\n  // In vertical writing mode, we adjust the direction for correct caret movement\n  const adjustedIsBackward = isVertical ? !isBackward : isBackward;\n  const focusCaret = $caretFromPoint(selection.focus, adjustedIsBackward ? 'previous' : 'next');\n  if ($isExtendableTextPointCaret(focusCaret)) {\n    return false;\n  }\n  for (const nextCaret of $extendCaretToRange(focusCaret)) {\n    if ($isChildCaret(nextCaret)) {\n      return !nextCaret.origin.isInline();\n    } else if ($isElementNode(nextCaret.origin)) {\n      continue;\n    } else if ($isDecoratorNode(nextCaret.origin)) {\n      return true;\n    }\n    break;\n  }\n  return false;\n}\n\n/**\n * Moves the selection according to the arguments.\n * @param selection - The selected text or nodes.\n * @param isHoldingShift - Is the shift key being held down during the operation.\n * @param isBackward - Is the selection selected backwards (the focus comes before the anchor)?\n * @param granularity - The distance to adjust the current selection.\n */\nfunction $moveCaretSelection(selection, isHoldingShift, isBackward, granularity) {\n  selection.modify(isHoldingShift ? 'extend' : 'move', isBackward, granularity);\n}\n\n/**\n * Tests a parent element for right to left direction.\n * @param selection - The selection whose parent is to be tested.\n * @returns true if the selections' parent element has a direction of 'rtl' (right to left), false otherwise.\n */\nfunction $isParentElementRTL(selection) {\n  const anchorNode = selection.anchor.getNode();\n  const parent = $isRootNode(anchorNode) ? anchorNode : anchorNode.getParentOrThrow();\n  return parent.getDirection() === 'rtl';\n}\n\n/**\n * Moves selection by character according to arguments.\n * @param selection - The selection of the characters to move.\n * @param isHoldingShift - Is the shift key being held down during the operation.\n * @param isBackward - Is the selection backward (the focus comes before the anchor)?\n */\nfunction $moveCharacter(selection, isHoldingShift, isBackward) {\n  const isRTL = $isParentElementRTL(selection);\n  const isVertical = $isEditorVerticalOrientation(selection);\n\n  // In vertical-rl writing mode, arrow key directions need to be flipped\n  // to match the visual flow of text (top to bottom, right to left)\n  let adjustedIsBackward;\n  if (isVertical) {\n    // In vertical-rl mode, we need to completely invert the direction\n    // Left arrow (backward) should move down (forward)\n    // Right arrow (forward) should move up (backward)\n    adjustedIsBackward = !isBackward;\n  } else if (isRTL) {\n    // In horizontal RTL mode, use the standard RTL behavior\n    adjustedIsBackward = !isBackward;\n  } else {\n    // Standard LTR horizontal text\n    adjustedIsBackward = isBackward;\n  }\n\n  // Apply the direction adjustment to move the caret\n  $moveCaretSelection(selection, isHoldingShift, adjustedIsBackward, 'character');\n}\n\n/**\n * Returns the current value of a CSS property for Nodes, if set. If not set, it returns the defaultValue.\n * @param node - The node whose style value to get.\n * @param styleProperty - The CSS style property.\n * @param defaultValue - The default value for the property.\n * @returns The value of the property for node.\n */\nfunction $getNodeStyleValueForProperty(node, styleProperty, defaultValue) {\n  const css = node.getStyle();\n  const styleObject = getStyleObjectFromCSS(css);\n  if (styleObject !== null) {\n    return styleObject[styleProperty] || defaultValue;\n  }\n  return defaultValue;\n}\n\n/**\n * Returns the current value of a CSS property for TextNodes in the Selection, if set. If not set, it returns the defaultValue.\n * If all TextNodes do not have the same value, it returns an empty string.\n * @param selection - The selection of TextNodes whose value to find.\n * @param styleProperty - The CSS style property.\n * @param defaultValue - The default value for the property, defaults to an empty string.\n * @returns The value of the property for the selected TextNodes.\n */\nfunction $getSelectionStyleValueForProperty(selection, styleProperty, defaultValue = '') {\n  let styleValue = null;\n  const nodes = selection.getNodes();\n  const anchor = selection.anchor;\n  const focus = selection.focus;\n  const isBackward = selection.isBackward();\n  const endOffset = isBackward ? focus.offset : anchor.offset;\n  const endNode = isBackward ? focus.getNode() : anchor.getNode();\n  if ($isRangeSelection(selection) && selection.isCollapsed() && selection.style !== '') {\n    const css = selection.style;\n    const styleObject = getStyleObjectFromCSS(css);\n    if (styleObject !== null && styleProperty in styleObject) {\n      return styleObject[styleProperty];\n    }\n  }\n  for (let i = 0; i < nodes.length; i++) {\n    const node = nodes[i];\n\n    // if no actual characters in the end node are selected, we don't\n    // include it in the selection for purposes of determining style\n    // value\n    if (i !== 0 && endOffset === 0 && node.is(endNode)) {\n      continue;\n    }\n    if ($isTextNode(node)) {\n      const nodeStyleValue = $getNodeStyleValueForProperty(node, styleProperty, defaultValue);\n      if (styleValue === null) {\n        styleValue = nodeStyleValue;\n      } else if (styleValue !== nodeStyleValue) {\n        // multiple text nodes are in the selection and they don't all\n        // have the same style.\n        styleValue = '';\n        break;\n      }\n    }\n  }\n  return styleValue === null ? defaultValue : styleValue;\n}\nfunction $getAncestor(node, predicate) {\n  let parent = node;\n  while (parent !== null && parent.getParent() !== null && !predicate(parent)) {\n    parent = parent.getParentOrThrow();\n  }\n  return predicate(parent) ? parent : null;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/** @deprecated renamed to {@link $trimTextContentFromAnchor} by @lexical/eslint-plugin rules-of-lexical */\nconst trimTextContentFromAnchor = $trimTextContentFromAnchor;\n\nexport { $addNodeStyle, $copyBlockFormatIndent, $ensureForwardRangeSelection, $forEachSelectedTextNode, $getSelectionStyleValueForProperty, $isAtNodeEnd, $isParentElementRTL, $moveCaretSelection, $moveCharacter, $patchStyleText, $setBlocksType, $shouldOverrideDefaultCharacterSelection, $sliceSelectedTextNodeContent, $trimTextContentFromAnchor, $wrapNodes, createDOMRange, createRectsFromDOMRange, getCSSFromStyleObject, getStyleObjectFromCSS, trimTextContentFromAnchor };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}