{"ast":null,"code":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport { $insertDataTransferForRichText, copyToClipboard } from '@lexical/clipboard';\nimport { $shouldOverrideDefaultCharacterSelection, $moveCharacter } from '@lexical/selection';\nimport { addClassNamesToElement, isHTMLElement, objectKlassEquals, mergeRegister, $findMatchingParent, $getNearestBlockElementAncestorOrThrow } from '@lexical/utils';\nimport { createCommand, ElementNode, $createParagraphNode, $applyNodeReplacement, setNodeIndentFromDOM, CLICK_COMMAND, $getSelection, $isNodeSelection, COMMAND_PRIORITY_EDITOR, DELETE_CHARACTER_COMMAND, $isRangeSelection, DELETE_WORD_COMMAND, DELETE_LINE_COMMAND, CONTROLLED_TEXT_INSERTION_COMMAND, REMOVE_TEXT_COMMAND, FORMAT_TEXT_COMMAND, FORMAT_ELEMENT_COMMAND, $isElementNode, INSERT_LINE_BREAK_COMMAND, INSERT_PARAGRAPH_COMMAND, INSERT_TAB_COMMAND, $insertNodes, $createTabNode, INDENT_CONTENT_COMMAND, OUTDENT_CONTENT_COMMAND, KEY_ARROW_UP_COMMAND, $getAdjacentNode, $isDecoratorNode, KEY_ARROW_DOWN_COMMAND, KEY_ARROW_LEFT_COMMAND, KEY_ARROW_RIGHT_COMMAND, KEY_BACKSPACE_COMMAND, KEY_DELETE_COMMAND, KEY_ENTER_COMMAND, KEY_ESCAPE_COMMAND, DROP_COMMAND, $getNearestNodeFromDOMNode, $createRangeSelection, $isTextNode, $normalizeSelection__EXPERIMENTAL, $setSelection, DRAGSTART_COMMAND, DRAGOVER_COMMAND, SELECT_ALL_COMMAND, $selectAll, COPY_COMMAND, CUT_COMMAND, PASTE_COMMAND, isDOMNode, isSelectionCapturedInDecoratorInput, KEY_SPACE_COMMAND, KEY_TAB_COMMAND, PASTE_TAG, $getRoot, $isRootNode } from 'lexical';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction caretFromPoint(x, y) {\n  if (typeof document.caretRangeFromPoint !== 'undefined') {\n    const range = document.caretRangeFromPoint(x, y);\n    if (range === null) {\n      return null;\n    }\n    return {\n      node: range.startContainer,\n      offset: range.startOffset\n    };\n    // @ts-ignore\n  } else if (document.caretPositionFromPoint !== 'undefined') {\n    // @ts-ignore FF - no types\n    const range = document.caretPositionFromPoint(x, y);\n    if (range === null) {\n      return null;\n    }\n    return {\n      node: range.offsetNode,\n      offset: range.offset\n    };\n  } else {\n    // Gracefully handle IE\n    return null;\n  }\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst CAN_USE_DOM = typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst documentMode = CAN_USE_DOM && 'documentMode' in document ? document.documentMode : null;\nconst CAN_USE_BEFORE_INPUT = CAN_USE_DOM && 'InputEvent' in window && !documentMode ? 'getTargetRanges' in new window.InputEvent('input') : false;\nconst IS_SAFARI = CAN_USE_DOM && /Version\\/[\\d.]+.*Safari/.test(navigator.userAgent);\nconst IS_IOS = CAN_USE_DOM && /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;\n\n// Keep these in case we need to use them in the future.\n// export const IS_WINDOWS: boolean = CAN_USE_DOM && /Win/.test(navigator.platform);\nconst IS_CHROME = CAN_USE_DOM && /^(?=.*Chrome).*/i.test(navigator.userAgent);\nconst IS_APPLE_WEBKIT = CAN_USE_DOM && /AppleWebKit\\/[\\d.]+/.test(navigator.userAgent) && !IS_CHROME;\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst DRAG_DROP_PASTE = createCommand('DRAG_DROP_PASTE_FILE');\n/** @noInheritDoc */\nclass QuoteNode extends ElementNode {\n  static getType() {\n    return 'quote';\n  }\n  static clone(node) {\n    return new QuoteNode(node.__key);\n  }\n\n  // View\n\n  createDOM(config) {\n    const element = document.createElement('blockquote');\n    addClassNamesToElement(element, config.theme.quote);\n    return element;\n  }\n  updateDOM(prevNode, dom) {\n    return false;\n  }\n  static importDOM() {\n    return {\n      blockquote: node => ({\n        conversion: $convertBlockquoteElement,\n        priority: 0\n      })\n    };\n  }\n  exportDOM(editor) {\n    const {\n      element\n    } = super.exportDOM(editor);\n    if (isHTMLElement(element)) {\n      if (this.isEmpty()) {\n        element.append(document.createElement('br'));\n      }\n      const formatType = this.getFormatType();\n      if (formatType) {\n        element.style.textAlign = formatType;\n      }\n      const direction = this.getDirection();\n      if (direction) {\n        element.dir = direction;\n      }\n    }\n    return {\n      element\n    };\n  }\n  static importJSON(serializedNode) {\n    return $createQuoteNode().updateFromJSON(serializedNode);\n  }\n\n  // Mutation\n\n  insertNewAfter(_, restoreSelection) {\n    const newBlock = $createParagraphNode();\n    const direction = this.getDirection();\n    newBlock.setDirection(direction);\n    this.insertAfter(newBlock, restoreSelection);\n    return newBlock;\n  }\n  collapseAtStart() {\n    const paragraph = $createParagraphNode();\n    const children = this.getChildren();\n    children.forEach(child => paragraph.append(child));\n    this.replace(paragraph);\n    return true;\n  }\n  canMergeWhenEmpty() {\n    return true;\n  }\n}\nfunction $createQuoteNode() {\n  return $applyNodeReplacement(new QuoteNode());\n}\nfunction $isQuoteNode(node) {\n  return node instanceof QuoteNode;\n}\n/** @noInheritDoc */\nclass HeadingNode extends ElementNode {\n  /** @internal */\n\n  static getType() {\n    return 'heading';\n  }\n  static clone(node) {\n    return new HeadingNode(node.__tag, node.__key);\n  }\n  constructor(tag, key) {\n    super(key);\n    this.__tag = tag;\n  }\n  getTag() {\n    return this.__tag;\n  }\n  setTag(tag) {\n    const self = this.getWritable();\n    this.__tag = tag;\n    return self;\n  }\n\n  // View\n\n  createDOM(config) {\n    const tag = this.__tag;\n    const element = document.createElement(tag);\n    const theme = config.theme;\n    const classNames = theme.heading;\n    if (classNames !== undefined) {\n      const className = classNames[tag];\n      addClassNamesToElement(element, className);\n    }\n    return element;\n  }\n  updateDOM(prevNode, dom, config) {\n    return prevNode.__tag !== this.__tag;\n  }\n  static importDOM() {\n    return {\n      h1: node => ({\n        conversion: $convertHeadingElement,\n        priority: 0\n      }),\n      h2: node => ({\n        conversion: $convertHeadingElement,\n        priority: 0\n      }),\n      h3: node => ({\n        conversion: $convertHeadingElement,\n        priority: 0\n      }),\n      h4: node => ({\n        conversion: $convertHeadingElement,\n        priority: 0\n      }),\n      h5: node => ({\n        conversion: $convertHeadingElement,\n        priority: 0\n      }),\n      h6: node => ({\n        conversion: $convertHeadingElement,\n        priority: 0\n      }),\n      p: node => {\n        // domNode is a <p> since we matched it by nodeName\n        const paragraph = node;\n        const firstChild = paragraph.firstChild;\n        if (firstChild !== null && isGoogleDocsTitle(firstChild)) {\n          return {\n            conversion: () => ({\n              node: null\n            }),\n            priority: 3\n          };\n        }\n        return null;\n      },\n      span: node => {\n        if (isGoogleDocsTitle(node)) {\n          return {\n            conversion: domNode => {\n              return {\n                node: $createHeadingNode('h1')\n              };\n            },\n            priority: 3\n          };\n        }\n        return null;\n      }\n    };\n  }\n  exportDOM(editor) {\n    const {\n      element\n    } = super.exportDOM(editor);\n    if (isHTMLElement(element)) {\n      if (this.isEmpty()) {\n        element.append(document.createElement('br'));\n      }\n      const formatType = this.getFormatType();\n      if (formatType) {\n        element.style.textAlign = formatType;\n      }\n      const direction = this.getDirection();\n      if (direction) {\n        element.dir = direction;\n      }\n    }\n    return {\n      element\n    };\n  }\n  static importJSON(serializedNode) {\n    return $createHeadingNode(serializedNode.tag).updateFromJSON(serializedNode);\n  }\n  updateFromJSON(serializedNode) {\n    return super.updateFromJSON(serializedNode).setTag(serializedNode.tag);\n  }\n  exportJSON() {\n    return {\n      ...super.exportJSON(),\n      tag: this.getTag()\n    };\n  }\n\n  // Mutation\n  insertNewAfter(selection, restoreSelection = true) {\n    const anchorOffet = selection ? selection.anchor.offset : 0;\n    const lastDesc = this.getLastDescendant();\n    const isAtEnd = !lastDesc || selection && selection.anchor.key === lastDesc.getKey() && anchorOffet === lastDesc.getTextContentSize();\n    const newElement = isAtEnd || !selection ? $createParagraphNode() : $createHeadingNode(this.getTag());\n    const direction = this.getDirection();\n    newElement.setDirection(direction);\n    this.insertAfter(newElement, restoreSelection);\n    if (anchorOffet === 0 && !this.isEmpty() && selection) {\n      const paragraph = $createParagraphNode();\n      paragraph.select();\n      this.replace(paragraph, true);\n    }\n    return newElement;\n  }\n  collapseAtStart() {\n    const newElement = !this.isEmpty() ? $createHeadingNode(this.getTag()) : $createParagraphNode();\n    const children = this.getChildren();\n    children.forEach(child => newElement.append(child));\n    this.replace(newElement);\n    return true;\n  }\n  extractWithChild() {\n    return true;\n  }\n}\nfunction isGoogleDocsTitle(domNode) {\n  if (domNode.nodeName.toLowerCase() === 'span') {\n    return domNode.style.fontSize === '26pt';\n  }\n  return false;\n}\nfunction $convertHeadingElement(element) {\n  const nodeName = element.nodeName.toLowerCase();\n  let node = null;\n  if (nodeName === 'h1' || nodeName === 'h2' || nodeName === 'h3' || nodeName === 'h4' || nodeName === 'h5' || nodeName === 'h6') {\n    node = $createHeadingNode(nodeName);\n    if (element.style !== null) {\n      setNodeIndentFromDOM(element, node);\n      node.setFormat(element.style.textAlign);\n    }\n  }\n  return {\n    node\n  };\n}\nfunction $convertBlockquoteElement(element) {\n  const node = $createQuoteNode();\n  if (element.style !== null) {\n    node.setFormat(element.style.textAlign);\n    setNodeIndentFromDOM(element, node);\n  }\n  return {\n    node\n  };\n}\nfunction $createHeadingNode(headingTag = 'h1') {\n  return $applyNodeReplacement(new HeadingNode(headingTag));\n}\nfunction $isHeadingNode(node) {\n  return node instanceof HeadingNode;\n}\nfunction onPasteForRichText(event, editor) {\n  event.preventDefault();\n  editor.update(() => {\n    const selection = $getSelection();\n    const clipboardData = objectKlassEquals(event, InputEvent) || objectKlassEquals(event, KeyboardEvent) ? null : event.clipboardData;\n    if (clipboardData != null && selection !== null) {\n      $insertDataTransferForRichText(clipboardData, selection, editor);\n    }\n  }, {\n    tag: PASTE_TAG\n  });\n}\nasync function onCutForRichText(event, editor) {\n  await copyToClipboard(editor, objectKlassEquals(event, ClipboardEvent) ? event : null);\n  editor.update(() => {\n    const selection = $getSelection();\n    if ($isRangeSelection(selection)) {\n      selection.removeText();\n    } else if ($isNodeSelection(selection)) {\n      selection.getNodes().forEach(node => node.remove());\n    }\n  });\n}\n\n// Clipboard may contain files that we aren't allowed to read. While the event is arguably useless,\n// in certain occasions, we want to know whether it was a file transfer, as opposed to text. We\n// control this with the first boolean flag.\nfunction eventFiles(event) {\n  let dataTransfer = null;\n  if (objectKlassEquals(event, DragEvent)) {\n    dataTransfer = event.dataTransfer;\n  } else if (objectKlassEquals(event, ClipboardEvent)) {\n    dataTransfer = event.clipboardData;\n  }\n  if (dataTransfer === null) {\n    return [false, [], false];\n  }\n  const types = dataTransfer.types;\n  const hasFiles = types.includes('Files');\n  const hasContent = types.includes('text/html') || types.includes('text/plain');\n  return [hasFiles, Array.from(dataTransfer.files), hasContent];\n}\nfunction $handleIndentAndOutdent(indentOrOutdent) {\n  const selection = $getSelection();\n  if (!$isRangeSelection(selection)) {\n    return false;\n  }\n  const alreadyHandled = new Set();\n  const nodes = selection.getNodes();\n  for (let i = 0; i < nodes.length; i++) {\n    const node = nodes[i];\n    const key = node.getKey();\n    if (alreadyHandled.has(key)) {\n      continue;\n    }\n    const parentBlock = $findMatchingParent(node, parentNode => $isElementNode(parentNode) && !parentNode.isInline());\n    if (parentBlock === null) {\n      continue;\n    }\n    const parentKey = parentBlock.getKey();\n    if (parentBlock.canIndent() && !alreadyHandled.has(parentKey)) {\n      alreadyHandled.add(parentKey);\n      indentOrOutdent(parentBlock);\n    }\n  }\n  return alreadyHandled.size > 0;\n}\nfunction $isTargetWithinDecorator(target) {\n  const node = $getNearestNodeFromDOMNode(target);\n  return $isDecoratorNode(node);\n}\nfunction $isSelectionAtEndOfRoot(selection) {\n  const focus = selection.focus;\n  return focus.key === 'root' && focus.offset === $getRoot().getChildrenSize();\n}\nfunction $isSelectionCollapsedAtFrontOfIndentedBlock(selection) {\n  if (!selection.isCollapsed()) {\n    return false;\n  }\n  const {\n    anchor\n  } = selection;\n  if (anchor.offset !== 0) {\n    return false;\n  }\n  const anchorNode = anchor.getNode();\n  if ($isRootNode(anchorNode)) {\n    return false;\n  }\n  const element = $getNearestBlockElementAncestorOrThrow(anchorNode);\n  return element.getIndent() > 0 && (element.is(anchorNode) || anchorNode.is(element.getFirstDescendant()));\n}\n\n/**\n * Resets the capitalization of the selection to default.\n * Called when the user presses space, tab, or enter key.\n * @param selection The selection to reset the capitalization of.\n */\nfunction $resetCapitalization(selection) {\n  for (const format of ['lowercase', 'uppercase', 'capitalize']) {\n    if (selection.hasFormat(format)) {\n      selection.toggleFormat(format);\n    }\n  }\n}\nfunction registerRichText(editor) {\n  const removeListener = mergeRegister(editor.registerCommand(CLICK_COMMAND, payload => {\n    const selection = $getSelection();\n    if ($isNodeSelection(selection)) {\n      selection.clear();\n      return true;\n    }\n    return false;\n  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(DELETE_CHARACTER_COMMAND, isBackward => {\n    const selection = $getSelection();\n    if ($isRangeSelection(selection)) {\n      selection.deleteCharacter(isBackward);\n      return true;\n    } else if ($isNodeSelection(selection)) {\n      selection.deleteNodes();\n      return true;\n    }\n    return false;\n  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(DELETE_WORD_COMMAND, isBackward => {\n    const selection = $getSelection();\n    if (!$isRangeSelection(selection)) {\n      return false;\n    }\n    selection.deleteWord(isBackward);\n    return true;\n  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(DELETE_LINE_COMMAND, isBackward => {\n    const selection = $getSelection();\n    if (!$isRangeSelection(selection)) {\n      return false;\n    }\n    selection.deleteLine(isBackward);\n    return true;\n  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(CONTROLLED_TEXT_INSERTION_COMMAND, eventOrText => {\n    const selection = $getSelection();\n    if (typeof eventOrText === 'string') {\n      if (selection !== null) {\n        selection.insertText(eventOrText);\n      }\n    } else {\n      if (selection === null) {\n        return false;\n      }\n      const dataTransfer = eventOrText.dataTransfer;\n      if (dataTransfer != null) {\n        $insertDataTransferForRichText(dataTransfer, selection, editor);\n      } else if ($isRangeSelection(selection)) {\n        const data = eventOrText.data;\n        if (data) {\n          selection.insertText(data);\n        }\n        return true;\n      }\n    }\n    return true;\n  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(REMOVE_TEXT_COMMAND, () => {\n    const selection = $getSelection();\n    if (!$isRangeSelection(selection)) {\n      return false;\n    }\n    selection.removeText();\n    return true;\n  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(FORMAT_TEXT_COMMAND, format => {\n    const selection = $getSelection();\n    if (!$isRangeSelection(selection)) {\n      return false;\n    }\n    selection.formatText(format);\n    return true;\n  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(FORMAT_ELEMENT_COMMAND, format => {\n    const selection = $getSelection();\n    if (!$isRangeSelection(selection) && !$isNodeSelection(selection)) {\n      return false;\n    }\n    const nodes = selection.getNodes();\n    for (const node of nodes) {\n      const element = $findMatchingParent(node, parentNode => $isElementNode(parentNode) && !parentNode.isInline());\n      if (element !== null) {\n        element.setFormat(format);\n      }\n    }\n    return true;\n  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(INSERT_LINE_BREAK_COMMAND, selectStart => {\n    const selection = $getSelection();\n    if (!$isRangeSelection(selection)) {\n      return false;\n    }\n    selection.insertLineBreak(selectStart);\n    return true;\n  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(INSERT_PARAGRAPH_COMMAND, () => {\n    const selection = $getSelection();\n    if (!$isRangeSelection(selection)) {\n      return false;\n    }\n    selection.insertParagraph();\n    return true;\n  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(INSERT_TAB_COMMAND, () => {\n    $insertNodes([$createTabNode()]);\n    return true;\n  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(INDENT_CONTENT_COMMAND, () => {\n    return $handleIndentAndOutdent(block => {\n      const indent = block.getIndent();\n      block.setIndent(indent + 1);\n    });\n  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(OUTDENT_CONTENT_COMMAND, () => {\n    return $handleIndentAndOutdent(block => {\n      const indent = block.getIndent();\n      if (indent > 0) {\n        block.setIndent(Math.max(0, indent - 1));\n      }\n    });\n  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(KEY_ARROW_UP_COMMAND, event => {\n    const selection = $getSelection();\n    if ($isNodeSelection(selection)) {\n      // If selection is on a node, let's try and move selection\n      // back to being a range selection.\n      const nodes = selection.getNodes();\n      if (nodes.length > 0) {\n        nodes[0].selectPrevious();\n        return true;\n      }\n    } else if ($isRangeSelection(selection)) {\n      const possibleNode = $getAdjacentNode(selection.focus, true);\n      if (!event.shiftKey && $isDecoratorNode(possibleNode) && !possibleNode.isIsolated() && !possibleNode.isInline()) {\n        possibleNode.selectPrevious();\n        event.preventDefault();\n        return true;\n      }\n    }\n    return false;\n  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(KEY_ARROW_DOWN_COMMAND, event => {\n    const selection = $getSelection();\n    if ($isNodeSelection(selection)) {\n      // If selection is on a node, let's try and move selection\n      // back to being a range selection.\n      const nodes = selection.getNodes();\n      if (nodes.length > 0) {\n        nodes[0].selectNext(0, 0);\n        return true;\n      }\n    } else if ($isRangeSelection(selection)) {\n      if ($isSelectionAtEndOfRoot(selection)) {\n        event.preventDefault();\n        return true;\n      }\n      const possibleNode = $getAdjacentNode(selection.focus, false);\n      if (!event.shiftKey && $isDecoratorNode(possibleNode) && !possibleNode.isIsolated() && !possibleNode.isInline()) {\n        possibleNode.selectNext();\n        event.preventDefault();\n        return true;\n      }\n    }\n    return false;\n  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(KEY_ARROW_LEFT_COMMAND, event => {\n    const selection = $getSelection();\n    if ($isNodeSelection(selection)) {\n      // If selection is on a node, let's try and move selection\n      // back to being a range selection.\n      const nodes = selection.getNodes();\n      if (nodes.length > 0) {\n        event.preventDefault();\n        nodes[0].selectPrevious();\n        return true;\n      }\n    }\n    if (!$isRangeSelection(selection)) {\n      return false;\n    }\n    if ($shouldOverrideDefaultCharacterSelection(selection, true)) {\n      const isHoldingShift = event.shiftKey;\n      event.preventDefault();\n      $moveCharacter(selection, isHoldingShift, true);\n      return true;\n    }\n    return false;\n  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(KEY_ARROW_RIGHT_COMMAND, event => {\n    const selection = $getSelection();\n    if ($isNodeSelection(selection)) {\n      // If selection is on a node, let's try and move selection\n      // back to being a range selection.\n      const nodes = selection.getNodes();\n      if (nodes.length > 0) {\n        event.preventDefault();\n        nodes[0].selectNext(0, 0);\n        return true;\n      }\n    }\n    if (!$isRangeSelection(selection)) {\n      return false;\n    }\n    const isHoldingShift = event.shiftKey;\n    if ($shouldOverrideDefaultCharacterSelection(selection, false)) {\n      event.preventDefault();\n      $moveCharacter(selection, isHoldingShift, false);\n      return true;\n    }\n    return false;\n  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(KEY_BACKSPACE_COMMAND, event => {\n    if ($isTargetWithinDecorator(event.target)) {\n      return false;\n    }\n    const selection = $getSelection();\n    if ($isRangeSelection(selection)) {\n      if ($isSelectionCollapsedAtFrontOfIndentedBlock(selection)) {\n        event.preventDefault();\n        return editor.dispatchCommand(OUTDENT_CONTENT_COMMAND, undefined);\n      }\n      // Exception handling for iOS native behavior instead of Lexical's behavior when using Korean on iOS devices.\n      // more details - https://github.com/facebook/lexical/issues/5841\n      if (IS_IOS && navigator.language === 'ko-KR') {\n        return false;\n      }\n    } else if (!$isNodeSelection(selection)) {\n      return false;\n    }\n    event.preventDefault();\n    return editor.dispatchCommand(DELETE_CHARACTER_COMMAND, true);\n  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(KEY_DELETE_COMMAND, event => {\n    if ($isTargetWithinDecorator(event.target)) {\n      return false;\n    }\n    const selection = $getSelection();\n    if (!($isRangeSelection(selection) || $isNodeSelection(selection))) {\n      return false;\n    }\n    event.preventDefault();\n    return editor.dispatchCommand(DELETE_CHARACTER_COMMAND, false);\n  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(KEY_ENTER_COMMAND, event => {\n    const selection = $getSelection();\n    if (!$isRangeSelection(selection)) {\n      return false;\n    }\n    $resetCapitalization(selection);\n    if (event !== null) {\n      // If we have beforeinput, then we can avoid blocking\n      // the default behavior. This ensures that the iOS can\n      // intercept that we're actually inserting a paragraph,\n      // and autocomplete, autocapitalize etc work as intended.\n      // This can also cause a strange performance issue in\n      // Safari, where there is a noticeable pause due to\n      // preventing the key down of enter.\n      if ((IS_IOS || IS_SAFARI || IS_APPLE_WEBKIT) && CAN_USE_BEFORE_INPUT) {\n        return false;\n      }\n      event.preventDefault();\n      if (event.shiftKey) {\n        return editor.dispatchCommand(INSERT_LINE_BREAK_COMMAND, false);\n      }\n    }\n    return editor.dispatchCommand(INSERT_PARAGRAPH_COMMAND, undefined);\n  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(KEY_ESCAPE_COMMAND, () => {\n    const selection = $getSelection();\n    if (!$isRangeSelection(selection)) {\n      return false;\n    }\n    editor.blur();\n    return true;\n  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(DROP_COMMAND, event => {\n    const [, files] = eventFiles(event);\n    if (files.length > 0) {\n      const x = event.clientX;\n      const y = event.clientY;\n      const eventRange = caretFromPoint(x, y);\n      if (eventRange !== null) {\n        const {\n          offset: domOffset,\n          node: domNode\n        } = eventRange;\n        const node = $getNearestNodeFromDOMNode(domNode);\n        if (node !== null) {\n          const selection = $createRangeSelection();\n          if ($isTextNode(node)) {\n            selection.anchor.set(node.getKey(), domOffset, 'text');\n            selection.focus.set(node.getKey(), domOffset, 'text');\n          } else {\n            const parentKey = node.getParentOrThrow().getKey();\n            const offset = node.getIndexWithinParent() + 1;\n            selection.anchor.set(parentKey, offset, 'element');\n            selection.focus.set(parentKey, offset, 'element');\n          }\n          const normalizedSelection = $normalizeSelection__EXPERIMENTAL(selection);\n          $setSelection(normalizedSelection);\n        }\n        editor.dispatchCommand(DRAG_DROP_PASTE, files);\n      }\n      event.preventDefault();\n      return true;\n    }\n    const selection = $getSelection();\n    if ($isRangeSelection(selection)) {\n      return true;\n    }\n    return false;\n  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(DRAGSTART_COMMAND, event => {\n    const [isFileTransfer] = eventFiles(event);\n    const selection = $getSelection();\n    if (isFileTransfer && !$isRangeSelection(selection)) {\n      return false;\n    }\n    return true;\n  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(DRAGOVER_COMMAND, event => {\n    const [isFileTransfer] = eventFiles(event);\n    const selection = $getSelection();\n    if (isFileTransfer && !$isRangeSelection(selection)) {\n      return false;\n    }\n    const x = event.clientX;\n    const y = event.clientY;\n    const eventRange = caretFromPoint(x, y);\n    if (eventRange !== null) {\n      const node = $getNearestNodeFromDOMNode(eventRange.node);\n      if ($isDecoratorNode(node)) {\n        // Show browser caret as the user is dragging the media across the screen. Won't work\n        // for DecoratorNode nor it's relevant.\n        event.preventDefault();\n      }\n    }\n    return true;\n  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(SELECT_ALL_COMMAND, () => {\n    $selectAll();\n    return true;\n  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(COPY_COMMAND, event => {\n    copyToClipboard(editor, objectKlassEquals(event, ClipboardEvent) ? event : null);\n    return true;\n  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(CUT_COMMAND, event => {\n    onCutForRichText(event, editor);\n    return true;\n  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(PASTE_COMMAND, event => {\n    const [, files, hasTextContent] = eventFiles(event);\n    if (files.length > 0 && !hasTextContent) {\n      editor.dispatchCommand(DRAG_DROP_PASTE, files);\n      return true;\n    }\n\n    // if inputs then paste within the input ignore creating a new node on paste event\n    if (isDOMNode(event.target) && isSelectionCapturedInDecoratorInput(event.target)) {\n      return false;\n    }\n    const selection = $getSelection();\n    if (selection !== null) {\n      onPasteForRichText(event, editor);\n      return true;\n    }\n    return false;\n  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(KEY_SPACE_COMMAND, _ => {\n    const selection = $getSelection();\n    if ($isRangeSelection(selection)) {\n      $resetCapitalization(selection);\n    }\n    return false;\n  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(KEY_TAB_COMMAND, _ => {\n    const selection = $getSelection();\n    if ($isRangeSelection(selection)) {\n      $resetCapitalization(selection);\n    }\n    return false;\n  }, COMMAND_PRIORITY_EDITOR));\n  return removeListener;\n}\nexport { $createHeadingNode, $createQuoteNode, $isHeadingNode, $isQuoteNode, DRAG_DROP_PASTE, HeadingNode, QuoteNode, eventFiles, registerRichText };","map":{"version":3,"names":["$insertDataTransferForRichText","copyToClipboard","$shouldOverrideDefaultCharacterSelection","$moveCharacter","addClassNamesToElement","isHTMLElement","objectKlassEquals","mergeRegister","$findMatchingParent","$getNearestBlockElementAncestorOrThrow","createCommand","ElementNode","$createParagraphNode","$applyNodeReplacement","setNodeIndentFromDOM","CLICK_COMMAND","$getSelection","$isNodeSelection","COMMAND_PRIORITY_EDITOR","DELETE_CHARACTER_COMMAND","$isRangeSelection","DELETE_WORD_COMMAND","DELETE_LINE_COMMAND","CONTROLLED_TEXT_INSERTION_COMMAND","REMOVE_TEXT_COMMAND","FORMAT_TEXT_COMMAND","FORMAT_ELEMENT_COMMAND","$isElementNode","INSERT_LINE_BREAK_COMMAND","INSERT_PARAGRAPH_COMMAND","INSERT_TAB_COMMAND","$insertNodes","$createTabNode","INDENT_CONTENT_COMMAND","OUTDENT_CONTENT_COMMAND","KEY_ARROW_UP_COMMAND","$getAdjacentNode","$isDecoratorNode","KEY_ARROW_DOWN_COMMAND","KEY_ARROW_LEFT_COMMAND","KEY_ARROW_RIGHT_COMMAND","KEY_BACKSPACE_COMMAND","KEY_DELETE_COMMAND","KEY_ENTER_COMMAND","KEY_ESCAPE_COMMAND","DROP_COMMAND","$getNearestNodeFromDOMNode","$createRangeSelection","$isTextNode","$normalizeSelection__EXPERIMENTAL","$setSelection","DRAGSTART_COMMAND","DRAGOVER_COMMAND","SELECT_ALL_COMMAND","$selectAll","COPY_COMMAND","CUT_COMMAND","PASTE_COMMAND","isDOMNode","isSelectionCapturedInDecoratorInput","KEY_SPACE_COMMAND","KEY_TAB_COMMAND","PASTE_TAG","$getRoot","$isRootNode","caretFromPoint","x","y","document","caretRangeFromPoint","range","node","startContainer","offset","startOffset","caretPositionFromPoint","offsetNode","CAN_USE_DOM","window","createElement","documentMode","CAN_USE_BEFORE_INPUT","InputEvent","IS_SAFARI","test","navigator","userAgent","IS_IOS","MSStream","IS_CHROME","IS_APPLE_WEBKIT","DRAG_DROP_PASTE","QuoteNode","getType","clone","__key","createDOM","config","element","theme","quote","updateDOM","prevNode","dom","importDOM","blockquote","conversion","$convertBlockquoteElement","priority","exportDOM","editor","isEmpty","append","formatType","getFormatType","style","textAlign","direction","getDirection","dir","importJSON","serializedNode","$createQuoteNode","updateFromJSON","insertNewAfter","_","restoreSelection","newBlock","setDirection","insertAfter","collapseAtStart","paragraph","children","getChildren","forEach","child","replace","canMergeWhenEmpty","$isQuoteNode","HeadingNode","__tag","constructor","tag","key","getTag","setTag","self","getWritable","classNames","heading","undefined","className","h1","$convertHeadingElement","h2","h3","h4","h5","h6","p","firstChild","isGoogleDocsTitle","span","domNode","$createHeadingNode","exportJSON","selection","anchorOffet","anchor","lastDesc","getLastDescendant","isAtEnd","getKey","getTextContentSize","newElement","select","extractWithChild","nodeName","toLowerCase","fontSize","setFormat","headingTag","$isHeadingNode","onPasteForRichText","event","preventDefault","update","clipboardData","KeyboardEvent","onCutForRichText","ClipboardEvent","removeText","getNodes","remove","eventFiles","dataTransfer","DragEvent","types","hasFiles","includes","hasContent","Array","from","files","$handleIndentAndOutdent","indentOrOutdent","alreadyHandled","Set","nodes","i","length","has","parentBlock","parentNode","isInline","parentKey","canIndent","add","size","$isTargetWithinDecorator","target","$isSelectionAtEndOfRoot","focus","getChildrenSize","$isSelectionCollapsedAtFrontOfIndentedBlock","isCollapsed","anchorNode","getNode","getIndent","is","getFirstDescendant","$resetCapitalization","format","hasFormat","toggleFormat","registerRichText","removeListener","registerCommand","payload","clear","isBackward","deleteCharacter","deleteNodes","deleteWord","deleteLine","eventOrText","insertText","data","formatText","selectStart","insertLineBreak","insertParagraph","block","indent","setIndent","Math","max","selectPrevious","possibleNode","shiftKey","isIsolated","selectNext","isHoldingShift","dispatchCommand","language","blur","clientX","clientY","eventRange","domOffset","set","getParentOrThrow","getIndexWithinParent","normalizedSelection","isFileTransfer","hasTextContent"],"sources":["C:/Code/beedoo/node_modules/@lexical/rich-text/LexicalRichText.dev.mjs"],"sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport { $insertDataTransferForRichText, copyToClipboard } from '@lexical/clipboard';\nimport { $shouldOverrideDefaultCharacterSelection, $moveCharacter } from '@lexical/selection';\nimport { addClassNamesToElement, isHTMLElement, objectKlassEquals, mergeRegister, $findMatchingParent, $getNearestBlockElementAncestorOrThrow } from '@lexical/utils';\nimport { createCommand, ElementNode, $createParagraphNode, $applyNodeReplacement, setNodeIndentFromDOM, CLICK_COMMAND, $getSelection, $isNodeSelection, COMMAND_PRIORITY_EDITOR, DELETE_CHARACTER_COMMAND, $isRangeSelection, DELETE_WORD_COMMAND, DELETE_LINE_COMMAND, CONTROLLED_TEXT_INSERTION_COMMAND, REMOVE_TEXT_COMMAND, FORMAT_TEXT_COMMAND, FORMAT_ELEMENT_COMMAND, $isElementNode, INSERT_LINE_BREAK_COMMAND, INSERT_PARAGRAPH_COMMAND, INSERT_TAB_COMMAND, $insertNodes, $createTabNode, INDENT_CONTENT_COMMAND, OUTDENT_CONTENT_COMMAND, KEY_ARROW_UP_COMMAND, $getAdjacentNode, $isDecoratorNode, KEY_ARROW_DOWN_COMMAND, KEY_ARROW_LEFT_COMMAND, KEY_ARROW_RIGHT_COMMAND, KEY_BACKSPACE_COMMAND, KEY_DELETE_COMMAND, KEY_ENTER_COMMAND, KEY_ESCAPE_COMMAND, DROP_COMMAND, $getNearestNodeFromDOMNode, $createRangeSelection, $isTextNode, $normalizeSelection__EXPERIMENTAL, $setSelection, DRAGSTART_COMMAND, DRAGOVER_COMMAND, SELECT_ALL_COMMAND, $selectAll, COPY_COMMAND, CUT_COMMAND, PASTE_COMMAND, isDOMNode, isSelectionCapturedInDecoratorInput, KEY_SPACE_COMMAND, KEY_TAB_COMMAND, PASTE_TAG, $getRoot, $isRootNode } from 'lexical';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction caretFromPoint(x, y) {\n  if (typeof document.caretRangeFromPoint !== 'undefined') {\n    const range = document.caretRangeFromPoint(x, y);\n    if (range === null) {\n      return null;\n    }\n    return {\n      node: range.startContainer,\n      offset: range.startOffset\n    };\n    // @ts-ignore\n  } else if (document.caretPositionFromPoint !== 'undefined') {\n    // @ts-ignore FF - no types\n    const range = document.caretPositionFromPoint(x, y);\n    if (range === null) {\n      return null;\n    }\n    return {\n      node: range.offsetNode,\n      offset: range.offset\n    };\n  } else {\n    // Gracefully handle IE\n    return null;\n  }\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst CAN_USE_DOM = typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst documentMode = CAN_USE_DOM && 'documentMode' in document ? document.documentMode : null;\nconst CAN_USE_BEFORE_INPUT = CAN_USE_DOM && 'InputEvent' in window && !documentMode ? 'getTargetRanges' in new window.InputEvent('input') : false;\nconst IS_SAFARI = CAN_USE_DOM && /Version\\/[\\d.]+.*Safari/.test(navigator.userAgent);\nconst IS_IOS = CAN_USE_DOM && /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;\n\n// Keep these in case we need to use them in the future.\n// export const IS_WINDOWS: boolean = CAN_USE_DOM && /Win/.test(navigator.platform);\nconst IS_CHROME = CAN_USE_DOM && /^(?=.*Chrome).*/i.test(navigator.userAgent);\nconst IS_APPLE_WEBKIT = CAN_USE_DOM && /AppleWebKit\\/[\\d.]+/.test(navigator.userAgent) && !IS_CHROME;\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst DRAG_DROP_PASTE = createCommand('DRAG_DROP_PASTE_FILE');\n/** @noInheritDoc */\nclass QuoteNode extends ElementNode {\n  static getType() {\n    return 'quote';\n  }\n  static clone(node) {\n    return new QuoteNode(node.__key);\n  }\n\n  // View\n\n  createDOM(config) {\n    const element = document.createElement('blockquote');\n    addClassNamesToElement(element, config.theme.quote);\n    return element;\n  }\n  updateDOM(prevNode, dom) {\n    return false;\n  }\n  static importDOM() {\n    return {\n      blockquote: node => ({\n        conversion: $convertBlockquoteElement,\n        priority: 0\n      })\n    };\n  }\n  exportDOM(editor) {\n    const {\n      element\n    } = super.exportDOM(editor);\n    if (isHTMLElement(element)) {\n      if (this.isEmpty()) {\n        element.append(document.createElement('br'));\n      }\n      const formatType = this.getFormatType();\n      if (formatType) {\n        element.style.textAlign = formatType;\n      }\n      const direction = this.getDirection();\n      if (direction) {\n        element.dir = direction;\n      }\n    }\n    return {\n      element\n    };\n  }\n  static importJSON(serializedNode) {\n    return $createQuoteNode().updateFromJSON(serializedNode);\n  }\n\n  // Mutation\n\n  insertNewAfter(_, restoreSelection) {\n    const newBlock = $createParagraphNode();\n    const direction = this.getDirection();\n    newBlock.setDirection(direction);\n    this.insertAfter(newBlock, restoreSelection);\n    return newBlock;\n  }\n  collapseAtStart() {\n    const paragraph = $createParagraphNode();\n    const children = this.getChildren();\n    children.forEach(child => paragraph.append(child));\n    this.replace(paragraph);\n    return true;\n  }\n  canMergeWhenEmpty() {\n    return true;\n  }\n}\nfunction $createQuoteNode() {\n  return $applyNodeReplacement(new QuoteNode());\n}\nfunction $isQuoteNode(node) {\n  return node instanceof QuoteNode;\n}\n/** @noInheritDoc */\nclass HeadingNode extends ElementNode {\n  /** @internal */\n\n  static getType() {\n    return 'heading';\n  }\n  static clone(node) {\n    return new HeadingNode(node.__tag, node.__key);\n  }\n  constructor(tag, key) {\n    super(key);\n    this.__tag = tag;\n  }\n  getTag() {\n    return this.__tag;\n  }\n  setTag(tag) {\n    const self = this.getWritable();\n    this.__tag = tag;\n    return self;\n  }\n\n  // View\n\n  createDOM(config) {\n    const tag = this.__tag;\n    const element = document.createElement(tag);\n    const theme = config.theme;\n    const classNames = theme.heading;\n    if (classNames !== undefined) {\n      const className = classNames[tag];\n      addClassNamesToElement(element, className);\n    }\n    return element;\n  }\n  updateDOM(prevNode, dom, config) {\n    return prevNode.__tag !== this.__tag;\n  }\n  static importDOM() {\n    return {\n      h1: node => ({\n        conversion: $convertHeadingElement,\n        priority: 0\n      }),\n      h2: node => ({\n        conversion: $convertHeadingElement,\n        priority: 0\n      }),\n      h3: node => ({\n        conversion: $convertHeadingElement,\n        priority: 0\n      }),\n      h4: node => ({\n        conversion: $convertHeadingElement,\n        priority: 0\n      }),\n      h5: node => ({\n        conversion: $convertHeadingElement,\n        priority: 0\n      }),\n      h6: node => ({\n        conversion: $convertHeadingElement,\n        priority: 0\n      }),\n      p: node => {\n        // domNode is a <p> since we matched it by nodeName\n        const paragraph = node;\n        const firstChild = paragraph.firstChild;\n        if (firstChild !== null && isGoogleDocsTitle(firstChild)) {\n          return {\n            conversion: () => ({\n              node: null\n            }),\n            priority: 3\n          };\n        }\n        return null;\n      },\n      span: node => {\n        if (isGoogleDocsTitle(node)) {\n          return {\n            conversion: domNode => {\n              return {\n                node: $createHeadingNode('h1')\n              };\n            },\n            priority: 3\n          };\n        }\n        return null;\n      }\n    };\n  }\n  exportDOM(editor) {\n    const {\n      element\n    } = super.exportDOM(editor);\n    if (isHTMLElement(element)) {\n      if (this.isEmpty()) {\n        element.append(document.createElement('br'));\n      }\n      const formatType = this.getFormatType();\n      if (formatType) {\n        element.style.textAlign = formatType;\n      }\n      const direction = this.getDirection();\n      if (direction) {\n        element.dir = direction;\n      }\n    }\n    return {\n      element\n    };\n  }\n  static importJSON(serializedNode) {\n    return $createHeadingNode(serializedNode.tag).updateFromJSON(serializedNode);\n  }\n  updateFromJSON(serializedNode) {\n    return super.updateFromJSON(serializedNode).setTag(serializedNode.tag);\n  }\n  exportJSON() {\n    return {\n      ...super.exportJSON(),\n      tag: this.getTag()\n    };\n  }\n\n  // Mutation\n  insertNewAfter(selection, restoreSelection = true) {\n    const anchorOffet = selection ? selection.anchor.offset : 0;\n    const lastDesc = this.getLastDescendant();\n    const isAtEnd = !lastDesc || selection && selection.anchor.key === lastDesc.getKey() && anchorOffet === lastDesc.getTextContentSize();\n    const newElement = isAtEnd || !selection ? $createParagraphNode() : $createHeadingNode(this.getTag());\n    const direction = this.getDirection();\n    newElement.setDirection(direction);\n    this.insertAfter(newElement, restoreSelection);\n    if (anchorOffet === 0 && !this.isEmpty() && selection) {\n      const paragraph = $createParagraphNode();\n      paragraph.select();\n      this.replace(paragraph, true);\n    }\n    return newElement;\n  }\n  collapseAtStart() {\n    const newElement = !this.isEmpty() ? $createHeadingNode(this.getTag()) : $createParagraphNode();\n    const children = this.getChildren();\n    children.forEach(child => newElement.append(child));\n    this.replace(newElement);\n    return true;\n  }\n  extractWithChild() {\n    return true;\n  }\n}\nfunction isGoogleDocsTitle(domNode) {\n  if (domNode.nodeName.toLowerCase() === 'span') {\n    return domNode.style.fontSize === '26pt';\n  }\n  return false;\n}\nfunction $convertHeadingElement(element) {\n  const nodeName = element.nodeName.toLowerCase();\n  let node = null;\n  if (nodeName === 'h1' || nodeName === 'h2' || nodeName === 'h3' || nodeName === 'h4' || nodeName === 'h5' || nodeName === 'h6') {\n    node = $createHeadingNode(nodeName);\n    if (element.style !== null) {\n      setNodeIndentFromDOM(element, node);\n      node.setFormat(element.style.textAlign);\n    }\n  }\n  return {\n    node\n  };\n}\nfunction $convertBlockquoteElement(element) {\n  const node = $createQuoteNode();\n  if (element.style !== null) {\n    node.setFormat(element.style.textAlign);\n    setNodeIndentFromDOM(element, node);\n  }\n  return {\n    node\n  };\n}\nfunction $createHeadingNode(headingTag = 'h1') {\n  return $applyNodeReplacement(new HeadingNode(headingTag));\n}\nfunction $isHeadingNode(node) {\n  return node instanceof HeadingNode;\n}\nfunction onPasteForRichText(event, editor) {\n  event.preventDefault();\n  editor.update(() => {\n    const selection = $getSelection();\n    const clipboardData = objectKlassEquals(event, InputEvent) || objectKlassEquals(event, KeyboardEvent) ? null : event.clipboardData;\n    if (clipboardData != null && selection !== null) {\n      $insertDataTransferForRichText(clipboardData, selection, editor);\n    }\n  }, {\n    tag: PASTE_TAG\n  });\n}\nasync function onCutForRichText(event, editor) {\n  await copyToClipboard(editor, objectKlassEquals(event, ClipboardEvent) ? event : null);\n  editor.update(() => {\n    const selection = $getSelection();\n    if ($isRangeSelection(selection)) {\n      selection.removeText();\n    } else if ($isNodeSelection(selection)) {\n      selection.getNodes().forEach(node => node.remove());\n    }\n  });\n}\n\n// Clipboard may contain files that we aren't allowed to read. While the event is arguably useless,\n// in certain occasions, we want to know whether it was a file transfer, as opposed to text. We\n// control this with the first boolean flag.\nfunction eventFiles(event) {\n  let dataTransfer = null;\n  if (objectKlassEquals(event, DragEvent)) {\n    dataTransfer = event.dataTransfer;\n  } else if (objectKlassEquals(event, ClipboardEvent)) {\n    dataTransfer = event.clipboardData;\n  }\n  if (dataTransfer === null) {\n    return [false, [], false];\n  }\n  const types = dataTransfer.types;\n  const hasFiles = types.includes('Files');\n  const hasContent = types.includes('text/html') || types.includes('text/plain');\n  return [hasFiles, Array.from(dataTransfer.files), hasContent];\n}\nfunction $handleIndentAndOutdent(indentOrOutdent) {\n  const selection = $getSelection();\n  if (!$isRangeSelection(selection)) {\n    return false;\n  }\n  const alreadyHandled = new Set();\n  const nodes = selection.getNodes();\n  for (let i = 0; i < nodes.length; i++) {\n    const node = nodes[i];\n    const key = node.getKey();\n    if (alreadyHandled.has(key)) {\n      continue;\n    }\n    const parentBlock = $findMatchingParent(node, parentNode => $isElementNode(parentNode) && !parentNode.isInline());\n    if (parentBlock === null) {\n      continue;\n    }\n    const parentKey = parentBlock.getKey();\n    if (parentBlock.canIndent() && !alreadyHandled.has(parentKey)) {\n      alreadyHandled.add(parentKey);\n      indentOrOutdent(parentBlock);\n    }\n  }\n  return alreadyHandled.size > 0;\n}\nfunction $isTargetWithinDecorator(target) {\n  const node = $getNearestNodeFromDOMNode(target);\n  return $isDecoratorNode(node);\n}\nfunction $isSelectionAtEndOfRoot(selection) {\n  const focus = selection.focus;\n  return focus.key === 'root' && focus.offset === $getRoot().getChildrenSize();\n}\nfunction $isSelectionCollapsedAtFrontOfIndentedBlock(selection) {\n  if (!selection.isCollapsed()) {\n    return false;\n  }\n  const {\n    anchor\n  } = selection;\n  if (anchor.offset !== 0) {\n    return false;\n  }\n  const anchorNode = anchor.getNode();\n  if ($isRootNode(anchorNode)) {\n    return false;\n  }\n  const element = $getNearestBlockElementAncestorOrThrow(anchorNode);\n  return element.getIndent() > 0 && (element.is(anchorNode) || anchorNode.is(element.getFirstDescendant()));\n}\n\n/**\n * Resets the capitalization of the selection to default.\n * Called when the user presses space, tab, or enter key.\n * @param selection The selection to reset the capitalization of.\n */\nfunction $resetCapitalization(selection) {\n  for (const format of ['lowercase', 'uppercase', 'capitalize']) {\n    if (selection.hasFormat(format)) {\n      selection.toggleFormat(format);\n    }\n  }\n}\nfunction registerRichText(editor) {\n  const removeListener = mergeRegister(editor.registerCommand(CLICK_COMMAND, payload => {\n    const selection = $getSelection();\n    if ($isNodeSelection(selection)) {\n      selection.clear();\n      return true;\n    }\n    return false;\n  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(DELETE_CHARACTER_COMMAND, isBackward => {\n    const selection = $getSelection();\n    if ($isRangeSelection(selection)) {\n      selection.deleteCharacter(isBackward);\n      return true;\n    } else if ($isNodeSelection(selection)) {\n      selection.deleteNodes();\n      return true;\n    }\n    return false;\n  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(DELETE_WORD_COMMAND, isBackward => {\n    const selection = $getSelection();\n    if (!$isRangeSelection(selection)) {\n      return false;\n    }\n    selection.deleteWord(isBackward);\n    return true;\n  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(DELETE_LINE_COMMAND, isBackward => {\n    const selection = $getSelection();\n    if (!$isRangeSelection(selection)) {\n      return false;\n    }\n    selection.deleteLine(isBackward);\n    return true;\n  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(CONTROLLED_TEXT_INSERTION_COMMAND, eventOrText => {\n    const selection = $getSelection();\n    if (typeof eventOrText === 'string') {\n      if (selection !== null) {\n        selection.insertText(eventOrText);\n      }\n    } else {\n      if (selection === null) {\n        return false;\n      }\n      const dataTransfer = eventOrText.dataTransfer;\n      if (dataTransfer != null) {\n        $insertDataTransferForRichText(dataTransfer, selection, editor);\n      } else if ($isRangeSelection(selection)) {\n        const data = eventOrText.data;\n        if (data) {\n          selection.insertText(data);\n        }\n        return true;\n      }\n    }\n    return true;\n  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(REMOVE_TEXT_COMMAND, () => {\n    const selection = $getSelection();\n    if (!$isRangeSelection(selection)) {\n      return false;\n    }\n    selection.removeText();\n    return true;\n  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(FORMAT_TEXT_COMMAND, format => {\n    const selection = $getSelection();\n    if (!$isRangeSelection(selection)) {\n      return false;\n    }\n    selection.formatText(format);\n    return true;\n  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(FORMAT_ELEMENT_COMMAND, format => {\n    const selection = $getSelection();\n    if (!$isRangeSelection(selection) && !$isNodeSelection(selection)) {\n      return false;\n    }\n    const nodes = selection.getNodes();\n    for (const node of nodes) {\n      const element = $findMatchingParent(node, parentNode => $isElementNode(parentNode) && !parentNode.isInline());\n      if (element !== null) {\n        element.setFormat(format);\n      }\n    }\n    return true;\n  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(INSERT_LINE_BREAK_COMMAND, selectStart => {\n    const selection = $getSelection();\n    if (!$isRangeSelection(selection)) {\n      return false;\n    }\n    selection.insertLineBreak(selectStart);\n    return true;\n  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(INSERT_PARAGRAPH_COMMAND, () => {\n    const selection = $getSelection();\n    if (!$isRangeSelection(selection)) {\n      return false;\n    }\n    selection.insertParagraph();\n    return true;\n  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(INSERT_TAB_COMMAND, () => {\n    $insertNodes([$createTabNode()]);\n    return true;\n  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(INDENT_CONTENT_COMMAND, () => {\n    return $handleIndentAndOutdent(block => {\n      const indent = block.getIndent();\n      block.setIndent(indent + 1);\n    });\n  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(OUTDENT_CONTENT_COMMAND, () => {\n    return $handleIndentAndOutdent(block => {\n      const indent = block.getIndent();\n      if (indent > 0) {\n        block.setIndent(Math.max(0, indent - 1));\n      }\n    });\n  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(KEY_ARROW_UP_COMMAND, event => {\n    const selection = $getSelection();\n    if ($isNodeSelection(selection)) {\n      // If selection is on a node, let's try and move selection\n      // back to being a range selection.\n      const nodes = selection.getNodes();\n      if (nodes.length > 0) {\n        nodes[0].selectPrevious();\n        return true;\n      }\n    } else if ($isRangeSelection(selection)) {\n      const possibleNode = $getAdjacentNode(selection.focus, true);\n      if (!event.shiftKey && $isDecoratorNode(possibleNode) && !possibleNode.isIsolated() && !possibleNode.isInline()) {\n        possibleNode.selectPrevious();\n        event.preventDefault();\n        return true;\n      }\n    }\n    return false;\n  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(KEY_ARROW_DOWN_COMMAND, event => {\n    const selection = $getSelection();\n    if ($isNodeSelection(selection)) {\n      // If selection is on a node, let's try and move selection\n      // back to being a range selection.\n      const nodes = selection.getNodes();\n      if (nodes.length > 0) {\n        nodes[0].selectNext(0, 0);\n        return true;\n      }\n    } else if ($isRangeSelection(selection)) {\n      if ($isSelectionAtEndOfRoot(selection)) {\n        event.preventDefault();\n        return true;\n      }\n      const possibleNode = $getAdjacentNode(selection.focus, false);\n      if (!event.shiftKey && $isDecoratorNode(possibleNode) && !possibleNode.isIsolated() && !possibleNode.isInline()) {\n        possibleNode.selectNext();\n        event.preventDefault();\n        return true;\n      }\n    }\n    return false;\n  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(KEY_ARROW_LEFT_COMMAND, event => {\n    const selection = $getSelection();\n    if ($isNodeSelection(selection)) {\n      // If selection is on a node, let's try and move selection\n      // back to being a range selection.\n      const nodes = selection.getNodes();\n      if (nodes.length > 0) {\n        event.preventDefault();\n        nodes[0].selectPrevious();\n        return true;\n      }\n    }\n    if (!$isRangeSelection(selection)) {\n      return false;\n    }\n    if ($shouldOverrideDefaultCharacterSelection(selection, true)) {\n      const isHoldingShift = event.shiftKey;\n      event.preventDefault();\n      $moveCharacter(selection, isHoldingShift, true);\n      return true;\n    }\n    return false;\n  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(KEY_ARROW_RIGHT_COMMAND, event => {\n    const selection = $getSelection();\n    if ($isNodeSelection(selection)) {\n      // If selection is on a node, let's try and move selection\n      // back to being a range selection.\n      const nodes = selection.getNodes();\n      if (nodes.length > 0) {\n        event.preventDefault();\n        nodes[0].selectNext(0, 0);\n        return true;\n      }\n    }\n    if (!$isRangeSelection(selection)) {\n      return false;\n    }\n    const isHoldingShift = event.shiftKey;\n    if ($shouldOverrideDefaultCharacterSelection(selection, false)) {\n      event.preventDefault();\n      $moveCharacter(selection, isHoldingShift, false);\n      return true;\n    }\n    return false;\n  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(KEY_BACKSPACE_COMMAND, event => {\n    if ($isTargetWithinDecorator(event.target)) {\n      return false;\n    }\n    const selection = $getSelection();\n    if ($isRangeSelection(selection)) {\n      if ($isSelectionCollapsedAtFrontOfIndentedBlock(selection)) {\n        event.preventDefault();\n        return editor.dispatchCommand(OUTDENT_CONTENT_COMMAND, undefined);\n      }\n      // Exception handling for iOS native behavior instead of Lexical's behavior when using Korean on iOS devices.\n      // more details - https://github.com/facebook/lexical/issues/5841\n      if (IS_IOS && navigator.language === 'ko-KR') {\n        return false;\n      }\n    } else if (!$isNodeSelection(selection)) {\n      return false;\n    }\n    event.preventDefault();\n    return editor.dispatchCommand(DELETE_CHARACTER_COMMAND, true);\n  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(KEY_DELETE_COMMAND, event => {\n    if ($isTargetWithinDecorator(event.target)) {\n      return false;\n    }\n    const selection = $getSelection();\n    if (!($isRangeSelection(selection) || $isNodeSelection(selection))) {\n      return false;\n    }\n    event.preventDefault();\n    return editor.dispatchCommand(DELETE_CHARACTER_COMMAND, false);\n  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(KEY_ENTER_COMMAND, event => {\n    const selection = $getSelection();\n    if (!$isRangeSelection(selection)) {\n      return false;\n    }\n    $resetCapitalization(selection);\n    if (event !== null) {\n      // If we have beforeinput, then we can avoid blocking\n      // the default behavior. This ensures that the iOS can\n      // intercept that we're actually inserting a paragraph,\n      // and autocomplete, autocapitalize etc work as intended.\n      // This can also cause a strange performance issue in\n      // Safari, where there is a noticeable pause due to\n      // preventing the key down of enter.\n      if ((IS_IOS || IS_SAFARI || IS_APPLE_WEBKIT) && CAN_USE_BEFORE_INPUT) {\n        return false;\n      }\n      event.preventDefault();\n      if (event.shiftKey) {\n        return editor.dispatchCommand(INSERT_LINE_BREAK_COMMAND, false);\n      }\n    }\n    return editor.dispatchCommand(INSERT_PARAGRAPH_COMMAND, undefined);\n  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(KEY_ESCAPE_COMMAND, () => {\n    const selection = $getSelection();\n    if (!$isRangeSelection(selection)) {\n      return false;\n    }\n    editor.blur();\n    return true;\n  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(DROP_COMMAND, event => {\n    const [, files] = eventFiles(event);\n    if (files.length > 0) {\n      const x = event.clientX;\n      const y = event.clientY;\n      const eventRange = caretFromPoint(x, y);\n      if (eventRange !== null) {\n        const {\n          offset: domOffset,\n          node: domNode\n        } = eventRange;\n        const node = $getNearestNodeFromDOMNode(domNode);\n        if (node !== null) {\n          const selection = $createRangeSelection();\n          if ($isTextNode(node)) {\n            selection.anchor.set(node.getKey(), domOffset, 'text');\n            selection.focus.set(node.getKey(), domOffset, 'text');\n          } else {\n            const parentKey = node.getParentOrThrow().getKey();\n            const offset = node.getIndexWithinParent() + 1;\n            selection.anchor.set(parentKey, offset, 'element');\n            selection.focus.set(parentKey, offset, 'element');\n          }\n          const normalizedSelection = $normalizeSelection__EXPERIMENTAL(selection);\n          $setSelection(normalizedSelection);\n        }\n        editor.dispatchCommand(DRAG_DROP_PASTE, files);\n      }\n      event.preventDefault();\n      return true;\n    }\n    const selection = $getSelection();\n    if ($isRangeSelection(selection)) {\n      return true;\n    }\n    return false;\n  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(DRAGSTART_COMMAND, event => {\n    const [isFileTransfer] = eventFiles(event);\n    const selection = $getSelection();\n    if (isFileTransfer && !$isRangeSelection(selection)) {\n      return false;\n    }\n    return true;\n  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(DRAGOVER_COMMAND, event => {\n    const [isFileTransfer] = eventFiles(event);\n    const selection = $getSelection();\n    if (isFileTransfer && !$isRangeSelection(selection)) {\n      return false;\n    }\n    const x = event.clientX;\n    const y = event.clientY;\n    const eventRange = caretFromPoint(x, y);\n    if (eventRange !== null) {\n      const node = $getNearestNodeFromDOMNode(eventRange.node);\n      if ($isDecoratorNode(node)) {\n        // Show browser caret as the user is dragging the media across the screen. Won't work\n        // for DecoratorNode nor it's relevant.\n        event.preventDefault();\n      }\n    }\n    return true;\n  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(SELECT_ALL_COMMAND, () => {\n    $selectAll();\n    return true;\n  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(COPY_COMMAND, event => {\n    copyToClipboard(editor, objectKlassEquals(event, ClipboardEvent) ? event : null);\n    return true;\n  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(CUT_COMMAND, event => {\n    onCutForRichText(event, editor);\n    return true;\n  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(PASTE_COMMAND, event => {\n    const [, files, hasTextContent] = eventFiles(event);\n    if (files.length > 0 && !hasTextContent) {\n      editor.dispatchCommand(DRAG_DROP_PASTE, files);\n      return true;\n    }\n\n    // if inputs then paste within the input ignore creating a new node on paste event\n    if (isDOMNode(event.target) && isSelectionCapturedInDecoratorInput(event.target)) {\n      return false;\n    }\n    const selection = $getSelection();\n    if (selection !== null) {\n      onPasteForRichText(event, editor);\n      return true;\n    }\n    return false;\n  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(KEY_SPACE_COMMAND, _ => {\n    const selection = $getSelection();\n    if ($isRangeSelection(selection)) {\n      $resetCapitalization(selection);\n    }\n    return false;\n  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(KEY_TAB_COMMAND, _ => {\n    const selection = $getSelection();\n    if ($isRangeSelection(selection)) {\n      $resetCapitalization(selection);\n    }\n    return false;\n  }, COMMAND_PRIORITY_EDITOR));\n  return removeListener;\n}\n\nexport { $createHeadingNode, $createQuoteNode, $isHeadingNode, $isQuoteNode, DRAG_DROP_PASTE, HeadingNode, QuoteNode, eventFiles, registerRichText };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}