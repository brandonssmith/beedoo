{"ast":null,"code":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport { $getNearestNodeOfType, removeClassNamesFromElement, addClassNamesToElement, isHTMLElement, mergeRegister, $findMatchingParent, calculateZoomLevel } from '@lexical/utils';\nimport { $getSelection, $isRangeSelection, $isRootOrShadowRoot, $createParagraphNode, $isElementNode, $isLeafNode, $setPointFromCaret, $normalizeCaret, $getChildCaret, ElementNode, buildImportMap, $isParagraphNode, $applyNodeReplacement, $createTextNode, createCommand, COMMAND_PRIORITY_LOW, KEY_ARROW_DOWN_COMMAND, KEY_ARROW_UP_COMMAND, KEY_ESCAPE_COMMAND, KEY_SPACE_COMMAND, $getNearestNodeFromDOMNode, KEY_ARROW_LEFT_COMMAND, getNearestEditorFromDOMNode, $getNodeByKey, INSERT_PARAGRAPH_COMMAND, $isTextNode, TextNode } from 'lexical';\nimport { getStyleObjectFromCSS } from '@lexical/selection';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n// Do not require this module directly! Use normal `invariant` calls.\n\nfunction formatDevErrorMessage(message) {\n  throw new Error(message);\n}\n\n/**\n * Checks the depth of listNode from the root node.\n * @param listNode - The ListNode to be checked.\n * @returns The depth of the ListNode.\n */\nfunction $getListDepth(listNode) {\n  let depth = 1;\n  let parent = listNode.getParent();\n  while (parent != null) {\n    if ($isListItemNode(parent)) {\n      const parentList = parent.getParent();\n      if ($isListNode(parentList)) {\n        depth++;\n        parent = parentList.getParent();\n        continue;\n      }\n      {\n        formatDevErrorMessage(`A ListItemNode must have a ListNode for a parent.`);\n      }\n    }\n    return depth;\n  }\n  return depth;\n}\n\n/**\n * Finds the nearest ancestral ListNode and returns it, throws an invariant if listItem is not a ListItemNode.\n * @param listItem - The node to be checked.\n * @returns The ListNode found.\n */\nfunction $getTopListNode(listItem) {\n  let list = listItem.getParent();\n  if (!$isListNode(list)) {\n    {\n      formatDevErrorMessage(`A ListItemNode must have a ListNode for a parent.`);\n    }\n  }\n  let parent = list;\n  while (parent !== null) {\n    parent = parent.getParent();\n    if ($isListNode(parent)) {\n      list = parent;\n    }\n  }\n  return list;\n}\n\n/**\n * A recursive Depth-First Search (Postorder Traversal) that finds all of a node's children\n * that are of type ListItemNode and returns them in an array.\n * @param node - The ListNode to start the search.\n * @returns An array containing all nodes of type ListItemNode found.\n */\n// This should probably be $getAllChildrenOfType\nfunction $getAllListItems(node) {\n  let listItemNodes = [];\n  const listChildren = node.getChildren().filter($isListItemNode);\n  for (let i = 0; i < listChildren.length; i++) {\n    const listItemNode = listChildren[i];\n    const firstChild = listItemNode.getFirstChild();\n    if ($isListNode(firstChild)) {\n      listItemNodes = listItemNodes.concat($getAllListItems(firstChild));\n    } else {\n      listItemNodes.push(listItemNode);\n    }\n  }\n  return listItemNodes;\n}\n\n/**\n * Checks to see if the passed node is a ListItemNode and has a ListNode as a child.\n * @param node - The node to be checked.\n * @returns true if the node is a ListItemNode and has a ListNode child, false otherwise.\n */\nfunction isNestedListNode(node) {\n  return $isListItemNode(node) && $isListNode(node.getFirstChild());\n}\n\n/**\n * Takes a deeply nested ListNode or ListItemNode and traverses up the branch to delete the first\n * ancestral ListNode (which could be the root ListNode) or ListItemNode with siblings, essentially\n * bringing the deeply nested node up the branch once. Would remove sublist if it has siblings.\n * Should not break ListItem -> List -> ListItem chain as empty List/ItemNodes should be removed on .remove().\n * @param sublist - The nested ListNode or ListItemNode to be brought up the branch.\n */\nfunction $removeHighestEmptyListParent(sublist) {\n  // Nodes may be repeatedly indented, to create deeply nested lists that each\n  // contain just one bullet.\n  // Our goal is to remove these (empty) deeply nested lists. The easiest\n  // way to do that is crawl back up the tree until we find a node that has siblings\n  // (e.g. is actually part of the list contents) and delete that, or delete\n  // the root of the list (if no list nodes have siblings.)\n  let emptyListPtr = sublist;\n  while (emptyListPtr.getNextSibling() == null && emptyListPtr.getPreviousSibling() == null) {\n    const parent = emptyListPtr.getParent();\n    if (parent == null || !($isListItemNode(parent) || $isListNode(parent))) {\n      break;\n    }\n    emptyListPtr = parent;\n  }\n  emptyListPtr.remove();\n}\n\n/**\n * Wraps a node into a ListItemNode.\n * @param node - The node to be wrapped into a ListItemNode\n * @returns The ListItemNode which the passed node is wrapped in.\n */\nfunction $wrapInListItem(node) {\n  const listItemWrapper = $createListItemNode();\n  return listItemWrapper.append(node);\n}\nfunction $isSelectingEmptyListItem(anchorNode, nodes) {\n  return $isListItemNode(anchorNode) && (nodes.length === 0 || nodes.length === 1 && anchorNode.is(nodes[0]) && anchorNode.getChildrenSize() === 0);\n}\n\n/**\n * Inserts a new ListNode. If the selection's anchor node is an empty ListItemNode and is a child of\n * the root/shadow root, it will replace the ListItemNode with a ListNode and the old ListItemNode.\n * Otherwise it will replace its parent with a new ListNode and re-insert the ListItemNode and any previous children.\n * If the selection's anchor node is not an empty ListItemNode, it will add a new ListNode or merge an existing ListNode,\n * unless the the node is a leaf node, in which case it will attempt to find a ListNode up the branch and replace it with\n * a new ListNode, or create a new ListNode at the nearest root/shadow root.\n * @param listType - The type of list, \"number\" | \"bullet\" | \"check\".\n */\nfunction $insertList(listType) {\n  const selection = $getSelection();\n  if (selection !== null) {\n    let nodes = selection.getNodes();\n    if ($isRangeSelection(selection)) {\n      const anchorAndFocus = selection.getStartEndPoints();\n      if (!(anchorAndFocus !== null)) {\n        formatDevErrorMessage(`insertList: anchor should be defined`);\n      }\n      const [anchor] = anchorAndFocus;\n      const anchorNode = anchor.getNode();\n      const anchorNodeParent = anchorNode.getParent();\n      if ($isRootOrShadowRoot(anchorNode)) {\n        const firstChild = anchorNode.getFirstChild();\n        if (firstChild) {\n          nodes = firstChild.selectStart().getNodes();\n        } else {\n          const paragraph = $createParagraphNode();\n          anchorNode.append(paragraph);\n          nodes = paragraph.select().getNodes();\n        }\n      } else if ($isSelectingEmptyListItem(anchorNode, nodes)) {\n        const list = $createListNode(listType);\n        if ($isRootOrShadowRoot(anchorNodeParent)) {\n          anchorNode.replace(list);\n          const listItem = $createListItemNode();\n          if ($isElementNode(anchorNode)) {\n            listItem.setFormat(anchorNode.getFormatType());\n            listItem.setIndent(anchorNode.getIndent());\n          }\n          list.append(listItem);\n        } else if ($isListItemNode(anchorNode)) {\n          const parent = anchorNode.getParentOrThrow();\n          append(list, parent.getChildren());\n          parent.replace(list);\n        }\n        return;\n      }\n    }\n    const handled = new Set();\n    for (let i = 0; i < nodes.length; i++) {\n      const node = nodes[i];\n      if ($isElementNode(node) && node.isEmpty() && !$isListItemNode(node) && !handled.has(node.getKey())) {\n        $createListOrMerge(node, listType);\n        continue;\n      }\n      let parent = $isLeafNode(node) ? node.getParent() : $isListItemNode(node) && node.isEmpty() ? node : null;\n      while (parent != null) {\n        const parentKey = parent.getKey();\n        if ($isListNode(parent)) {\n          if (!handled.has(parentKey)) {\n            const newListNode = $createListNode(listType);\n            append(newListNode, parent.getChildren());\n            parent.replace(newListNode);\n            handled.add(parentKey);\n          }\n          break;\n        } else {\n          const nextParent = parent.getParent();\n          if ($isRootOrShadowRoot(nextParent) && !handled.has(parentKey)) {\n            handled.add(parentKey);\n            $createListOrMerge(parent, listType);\n            break;\n          }\n          parent = nextParent;\n        }\n      }\n    }\n  }\n}\nfunction append(node, nodesToAppend) {\n  node.splice(node.getChildrenSize(), 0, nodesToAppend);\n}\nfunction $createListOrMerge(node, listType) {\n  if ($isListNode(node)) {\n    return node;\n  }\n  const previousSibling = node.getPreviousSibling();\n  const nextSibling = node.getNextSibling();\n  const listItem = $createListItemNode();\n  append(listItem, node.getChildren());\n  let targetList;\n  if ($isListNode(previousSibling) && listType === previousSibling.getListType()) {\n    previousSibling.append(listItem);\n    // if the same type of list is on both sides, merge them.\n    if ($isListNode(nextSibling) && listType === nextSibling.getListType()) {\n      append(previousSibling, nextSibling.getChildren());\n      nextSibling.remove();\n    }\n    targetList = previousSibling;\n  } else if ($isListNode(nextSibling) && listType === nextSibling.getListType()) {\n    nextSibling.getFirstChildOrThrow().insertBefore(listItem);\n    targetList = nextSibling;\n  } else {\n    const list = $createListNode(listType);\n    list.append(listItem);\n    node.replace(list);\n    targetList = list;\n  }\n  // listItem needs to be attached to root prior to setting indent\n  listItem.setFormat(node.getFormatType());\n  listItem.setIndent(node.getIndent());\n  node.remove();\n  return targetList;\n}\n\n/**\n * A recursive function that goes through each list and their children, including nested lists,\n * appending list2 children after list1 children and updating ListItemNode values.\n * @param list1 - The first list to be merged.\n * @param list2 - The second list to be merged.\n */\nfunction mergeLists(list1, list2) {\n  const listItem1 = list1.getLastChild();\n  const listItem2 = list2.getFirstChild();\n  if (listItem1 && listItem2 && isNestedListNode(listItem1) && isNestedListNode(listItem2)) {\n    mergeLists(listItem1.getFirstChild(), listItem2.getFirstChild());\n    listItem2.remove();\n  }\n  const toMerge = list2.getChildren();\n  if (toMerge.length > 0) {\n    list1.append(...toMerge);\n  }\n  list2.remove();\n}\n\n/**\n * Searches for the nearest ancestral ListNode and removes it. If selection is an empty ListItemNode\n * it will remove the whole list, including the ListItemNode. For each ListItemNode in the ListNode,\n * removeList will also generate new ParagraphNodes in the removed ListNode's place. Any child node\n * inside a ListItemNode will be appended to the new ParagraphNodes.\n */\nfunction $removeList() {\n  const selection = $getSelection();\n  if ($isRangeSelection(selection)) {\n    const listNodes = new Set();\n    const nodes = selection.getNodes();\n    const anchorNode = selection.anchor.getNode();\n    if ($isSelectingEmptyListItem(anchorNode, nodes)) {\n      listNodes.add($getTopListNode(anchorNode));\n    } else {\n      for (let i = 0; i < nodes.length; i++) {\n        const node = nodes[i];\n        if ($isLeafNode(node)) {\n          const listItemNode = $getNearestNodeOfType(node, ListItemNode);\n          if (listItemNode != null) {\n            listNodes.add($getTopListNode(listItemNode));\n          }\n        }\n      }\n    }\n    for (const listNode of listNodes) {\n      let insertionPoint = listNode;\n      const listItems = $getAllListItems(listNode);\n      for (const listItemNode of listItems) {\n        const paragraph = $createParagraphNode().setTextStyle(selection.style).setTextFormat(selection.format);\n        append(paragraph, listItemNode.getChildren());\n        insertionPoint.insertAfter(paragraph);\n        insertionPoint = paragraph;\n\n        // When the anchor and focus fall on the textNode\n        // we don't have to change the selection because the textNode will be appended to\n        // the newly generated paragraph.\n        // When selection is in empty nested list item, selection is actually on the listItemNode.\n        // When the corresponding listItemNode is deleted and replaced by the newly generated paragraph\n        // we should manually set the selection's focus and anchor to the newly generated paragraph.\n        if (listItemNode.__key === selection.anchor.key) {\n          $setPointFromCaret(selection.anchor, $normalizeCaret($getChildCaret(paragraph, 'next')));\n        }\n        if (listItemNode.__key === selection.focus.key) {\n          $setPointFromCaret(selection.focus, $normalizeCaret($getChildCaret(paragraph, 'next')));\n        }\n        listItemNode.remove();\n      }\n      listNode.remove();\n    }\n  }\n}\n\n/**\n * Takes the value of a child ListItemNode and makes it the value the ListItemNode\n * should be if it isn't already. Also ensures that checked is undefined if the\n * parent does not have a list type of 'check'.\n * @param list - The list whose children are updated.\n */\nfunction updateChildrenListItemValue(list) {\n  const isNotChecklist = list.getListType() !== 'check';\n  let value = list.getStart();\n  for (const child of list.getChildren()) {\n    if ($isListItemNode(child)) {\n      if (child.getValue() !== value) {\n        child.setValue(value);\n      }\n      if (isNotChecklist && child.getLatest().__checked != null) {\n        child.setChecked(undefined);\n      }\n      if (!$isListNode(child.getFirstChild())) {\n        value++;\n      }\n    }\n  }\n}\n\n/**\n * Merge the next sibling list if same type.\n * <ul> will merge with <ul>, but NOT <ul> with <ol>.\n * @param list - The list whose next sibling should be potentially merged\n */\nfunction mergeNextSiblingListIfSameType(list) {\n  const nextSibling = list.getNextSibling();\n  if ($isListNode(nextSibling) && list.getListType() === nextSibling.getListType()) {\n    mergeLists(list, nextSibling);\n  }\n}\n\n/**\n * Adds an empty ListNode/ListItemNode chain at listItemNode, so as to\n * create an indent effect. Won't indent ListItemNodes that have a ListNode as\n * a child, but does merge sibling ListItemNodes if one has a nested ListNode.\n * @param listItemNode - The ListItemNode to be indented.\n */\nfunction $handleIndent(listItemNode) {\n  // go through each node and decide where to move it.\n  const removed = new Set();\n  if (isNestedListNode(listItemNode) || removed.has(listItemNode.getKey())) {\n    return;\n  }\n  const parent = listItemNode.getParent();\n\n  // We can cast both of the below `isNestedListNode` only returns a boolean type instead of a user-defined type guards\n  const nextSibling = listItemNode.getNextSibling();\n  const previousSibling = listItemNode.getPreviousSibling();\n  // if there are nested lists on either side, merge them all together.\n\n  if (isNestedListNode(nextSibling) && isNestedListNode(previousSibling)) {\n    const innerList = previousSibling.getFirstChild();\n    if ($isListNode(innerList)) {\n      innerList.append(listItemNode);\n      const nextInnerList = nextSibling.getFirstChild();\n      if ($isListNode(nextInnerList)) {\n        const children = nextInnerList.getChildren();\n        append(innerList, children);\n        nextSibling.remove();\n        removed.add(nextSibling.getKey());\n      }\n    }\n  } else if (isNestedListNode(nextSibling)) {\n    // if the ListItemNode is next to a nested ListNode, merge them\n    const innerList = nextSibling.getFirstChild();\n    if ($isListNode(innerList)) {\n      const firstChild = innerList.getFirstChild();\n      if (firstChild !== null) {\n        firstChild.insertBefore(listItemNode);\n      }\n    }\n  } else if (isNestedListNode(previousSibling)) {\n    const innerList = previousSibling.getFirstChild();\n    if ($isListNode(innerList)) {\n      innerList.append(listItemNode);\n    }\n  } else {\n    // otherwise, we need to create a new nested ListNode\n\n    if ($isListNode(parent)) {\n      const newListItem = $createListItemNode().setTextFormat(listItemNode.getTextFormat()).setTextStyle(listItemNode.getTextStyle());\n      const newList = $createListNode(parent.getListType()).setTextFormat(parent.getTextFormat()).setTextStyle(parent.getTextStyle());\n      newListItem.append(newList);\n      newList.append(listItemNode);\n      if (previousSibling) {\n        previousSibling.insertAfter(newListItem);\n      } else if (nextSibling) {\n        nextSibling.insertBefore(newListItem);\n      } else {\n        parent.append(newListItem);\n      }\n    }\n  }\n}\n\n/**\n * Removes an indent by removing an empty ListNode/ListItemNode chain. An indented ListItemNode\n * has a great grandparent node of type ListNode, which is where the ListItemNode will reside\n * within as a child.\n * @param listItemNode - The ListItemNode to remove the indent (outdent).\n */\nfunction $handleOutdent(listItemNode) {\n  // go through each node and decide where to move it.\n\n  if (isNestedListNode(listItemNode)) {\n    return;\n  }\n  const parentList = listItemNode.getParent();\n  const grandparentListItem = parentList ? parentList.getParent() : undefined;\n  const greatGrandparentList = grandparentListItem ? grandparentListItem.getParent() : undefined;\n  // If it doesn't have these ancestors, it's not indented.\n\n  if ($isListNode(greatGrandparentList) && $isListItemNode(grandparentListItem) && $isListNode(parentList)) {\n    // if it's the first child in it's parent list, insert it into the\n    // great grandparent list before the grandparent\n    const firstChild = parentList ? parentList.getFirstChild() : undefined;\n    const lastChild = parentList ? parentList.getLastChild() : undefined;\n    if (listItemNode.is(firstChild)) {\n      grandparentListItem.insertBefore(listItemNode);\n      if (parentList.isEmpty()) {\n        grandparentListItem.remove();\n      }\n      // if it's the last child in it's parent list, insert it into the\n      // great grandparent list after the grandparent.\n    } else if (listItemNode.is(lastChild)) {\n      grandparentListItem.insertAfter(listItemNode);\n      if (parentList.isEmpty()) {\n        grandparentListItem.remove();\n      }\n    } else {\n      // otherwise, we need to split the siblings into two new nested lists\n      const listType = parentList.getListType();\n      const previousSiblingsListItem = $createListItemNode();\n      const previousSiblingsList = $createListNode(listType);\n      previousSiblingsListItem.append(previousSiblingsList);\n      listItemNode.getPreviousSiblings().forEach(sibling => previousSiblingsList.append(sibling));\n      const nextSiblingsListItem = $createListItemNode();\n      const nextSiblingsList = $createListNode(listType);\n      nextSiblingsListItem.append(nextSiblingsList);\n      append(nextSiblingsList, listItemNode.getNextSiblings());\n      // put the sibling nested lists on either side of the grandparent list item in the great grandparent.\n      grandparentListItem.insertBefore(previousSiblingsListItem);\n      grandparentListItem.insertAfter(nextSiblingsListItem);\n      // replace the grandparent list item (now between the siblings) with the outdented list item.\n      grandparentListItem.replace(listItemNode);\n    }\n  }\n}\n\n/**\n * Attempts to insert a ParagraphNode at selection and selects the new node. The selection must contain a ListItemNode\n * or a node that does not already contain text. If its grandparent is the root/shadow root, it will get the ListNode\n * (which should be the parent node) and insert the ParagraphNode as a sibling to the ListNode. If the ListNode is\n * nested in a ListItemNode instead, it will add the ParagraphNode after the grandparent ListItemNode.\n * Throws an invariant if the selection is not a child of a ListNode.\n * @returns true if a ParagraphNode was inserted successfully, false if there is no selection\n * or the selection does not contain a ListItemNode or the node already holds text.\n */\nfunction $handleListInsertParagraph() {\n  const selection = $getSelection();\n  if (!$isRangeSelection(selection) || !selection.isCollapsed()) {\n    return false;\n  }\n  // Only run this code on empty list items\n  const anchor = selection.anchor.getNode();\n  if (!$isListItemNode(anchor) || anchor.getChildrenSize() !== 0) {\n    return false;\n  }\n  const topListNode = $getTopListNode(anchor);\n  const parent = anchor.getParent();\n  if (!$isListNode(parent)) {\n    formatDevErrorMessage(`A ListItemNode must have a ListNode for a parent.`);\n  }\n  const grandparent = parent.getParent();\n  let replacementNode;\n  if ($isRootOrShadowRoot(grandparent)) {\n    replacementNode = $createParagraphNode();\n    topListNode.insertAfter(replacementNode);\n  } else if ($isListItemNode(grandparent)) {\n    replacementNode = $createListItemNode();\n    grandparent.insertAfter(replacementNode);\n  } else {\n    return false;\n  }\n  replacementNode.setTextStyle(selection.style).setTextFormat(selection.format).select();\n  const nextSiblings = anchor.getNextSiblings();\n  if (nextSiblings.length > 0) {\n    const newList = $createListNode(parent.getListType());\n    if ($isListItemNode(replacementNode)) {\n      const newListItem = $createListItemNode();\n      newListItem.append(newList);\n      replacementNode.insertAfter(newListItem);\n    } else {\n      replacementNode.insertAfter(newList);\n    }\n    newList.append(...nextSiblings);\n  }\n\n  // Don't leave hanging nested empty lists\n  $removeHighestEmptyListParent(anchor);\n  return true;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction normalizeClassNames(...classNames) {\n  const rval = [];\n  for (const className of classNames) {\n    if (className && typeof className === 'string') {\n      for (const [s] of className.matchAll(/\\S+/g)) {\n        rval.push(s);\n      }\n    }\n  }\n  return rval;\n}\nfunction applyMarkerStyles(dom, node, prevNode) {\n  const styles = getStyleObjectFromCSS(node.__textStyle);\n  for (const k in styles) {\n    dom.style.setProperty(`--listitem-marker-${k}`, styles[k]);\n  }\n  if (prevNode) {\n    for (const k in getStyleObjectFromCSS(prevNode.__textStyle)) {\n      if (!(k in styles)) {\n        dom.style.removeProperty(`--listitem-marker-${k}`);\n      }\n    }\n  }\n}\n\n/** @noInheritDoc */\nclass ListItemNode extends ElementNode {\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n  $config() {\n    return this.config('listitem', {\n      $transform: node => {\n        if (node.__checked == null) {\n          return;\n        }\n        const parent = node.getParent();\n        if ($isListNode(parent)) {\n          if (parent.getListType() !== 'check' && node.getChecked() != null) {\n            node.setChecked(undefined);\n          }\n        }\n      },\n      extends: ElementNode,\n      importDOM: buildImportMap({\n        li: () => ({\n          conversion: $convertListItemElement,\n          priority: 0\n        })\n      })\n    });\n  }\n  constructor(value = 1, checked = undefined, key) {\n    super(key);\n    this.__value = value === undefined ? 1 : value;\n    this.__checked = checked;\n  }\n  afterCloneFrom(prevNode) {\n    super.afterCloneFrom(prevNode);\n    this.__value = prevNode.__value;\n    this.__checked = prevNode.__checked;\n  }\n  createDOM(config) {\n    const element = document.createElement('li');\n    this.updateListItemDOM(null, element, config);\n    return element;\n  }\n  updateListItemDOM(prevNode, dom, config) {\n    const parent = this.getParent();\n    if ($isListNode(parent) && parent.getListType() === 'check') {\n      updateListItemChecked(dom, this, prevNode);\n    }\n    dom.value = this.__value;\n    $setListItemThemeClassNames(dom, config.theme, this);\n    const prevStyle = prevNode ? prevNode.__style : '';\n    const nextStyle = this.__style;\n    if (prevStyle !== nextStyle) {\n      if (nextStyle === '') {\n        dom.removeAttribute('style');\n      } else {\n        dom.style.cssText = nextStyle;\n      }\n    }\n    applyMarkerStyles(dom, this, prevNode);\n  }\n  updateDOM(prevNode, dom, config) {\n    // @ts-expect-error - this is always HTMLListItemElement\n    const element = dom;\n    this.updateListItemDOM(prevNode, element, config);\n    return false;\n  }\n  updateFromJSON(serializedNode) {\n    return super.updateFromJSON(serializedNode).setValue(serializedNode.value).setChecked(serializedNode.checked);\n  }\n  exportDOM(editor) {\n    const element = this.createDOM(editor._config);\n    const formatType = this.getFormatType();\n    if (formatType) {\n      element.style.textAlign = formatType;\n    }\n    const direction = this.getDirection();\n    if (direction) {\n      element.dir = direction;\n    }\n    return {\n      element\n    };\n  }\n  exportJSON() {\n    return {\n      ...super.exportJSON(),\n      checked: this.getChecked(),\n      value: this.getValue()\n    };\n  }\n  append(...nodes) {\n    for (let i = 0; i < nodes.length; i++) {\n      const node = nodes[i];\n      if ($isElementNode(node) && this.canMergeWith(node)) {\n        const children = node.getChildren();\n        this.append(...children);\n        node.remove();\n      } else {\n        super.append(node);\n      }\n    }\n    return this;\n  }\n  replace(replaceWithNode, includeChildren) {\n    if ($isListItemNode(replaceWithNode)) {\n      return super.replace(replaceWithNode);\n    }\n    this.setIndent(0);\n    const list = this.getParentOrThrow();\n    if (!$isListNode(list)) {\n      return replaceWithNode;\n    }\n    if (list.__first === this.getKey()) {\n      list.insertBefore(replaceWithNode);\n    } else if (list.__last === this.getKey()) {\n      list.insertAfter(replaceWithNode);\n    } else {\n      // Split the list\n      const newList = $createListNode(list.getListType());\n      let nextSibling = this.getNextSibling();\n      while (nextSibling) {\n        const nodeToAppend = nextSibling;\n        nextSibling = nextSibling.getNextSibling();\n        newList.append(nodeToAppend);\n      }\n      list.insertAfter(replaceWithNode);\n      replaceWithNode.insertAfter(newList);\n    }\n    if (includeChildren) {\n      if (!$isElementNode(replaceWithNode)) {\n        formatDevErrorMessage(`includeChildren should only be true for ElementNodes`);\n      }\n      this.getChildren().forEach(child => {\n        replaceWithNode.append(child);\n      });\n    }\n    this.remove();\n    if (list.getChildrenSize() === 0) {\n      list.remove();\n    }\n    return replaceWithNode;\n  }\n  insertAfter(node, restoreSelection = true) {\n    const listNode = this.getParentOrThrow();\n    if (!$isListNode(listNode)) {\n      {\n        formatDevErrorMessage(`insertAfter: list node is not parent of list item node`);\n      }\n    }\n    if ($isListItemNode(node)) {\n      return super.insertAfter(node, restoreSelection);\n    }\n    const siblings = this.getNextSiblings();\n\n    // Split the lists and insert the node in between them\n    listNode.insertAfter(node, restoreSelection);\n    if (siblings.length !== 0) {\n      const newListNode = $createListNode(listNode.getListType());\n      siblings.forEach(sibling => newListNode.append(sibling));\n      node.insertAfter(newListNode, restoreSelection);\n    }\n    return node;\n  }\n  remove(preserveEmptyParent) {\n    const prevSibling = this.getPreviousSibling();\n    const nextSibling = this.getNextSibling();\n    super.remove(preserveEmptyParent);\n    if (prevSibling && nextSibling && isNestedListNode(prevSibling) && isNestedListNode(nextSibling)) {\n      mergeLists(prevSibling.getFirstChild(), nextSibling.getFirstChild());\n      nextSibling.remove();\n    }\n  }\n  insertNewAfter(_, restoreSelection = true) {\n    const newElement = $createListItemNode().updateFromJSON(this.exportJSON()).setChecked(this.getChecked() ? false : undefined);\n    this.insertAfter(newElement, restoreSelection);\n    return newElement;\n  }\n  collapseAtStart(selection) {\n    const paragraph = $createParagraphNode();\n    const children = this.getChildren();\n    children.forEach(child => paragraph.append(child));\n    const listNode = this.getParentOrThrow();\n    const listNodeParent = listNode.getParentOrThrow();\n    const isIndented = $isListItemNode(listNodeParent);\n    if (listNode.getChildrenSize() === 1) {\n      if (isIndented) {\n        // if the list node is nested, we just want to remove it,\n        // effectively unindenting it.\n        listNode.remove();\n        listNodeParent.select();\n      } else {\n        listNode.insertBefore(paragraph);\n        listNode.remove();\n        // If we have selection on the list item, we'll need to move it\n        // to the paragraph\n        const anchor = selection.anchor;\n        const focus = selection.focus;\n        const key = paragraph.getKey();\n        if (anchor.type === 'element' && anchor.getNode().is(this)) {\n          anchor.set(key, anchor.offset, 'element');\n        }\n        if (focus.type === 'element' && focus.getNode().is(this)) {\n          focus.set(key, focus.offset, 'element');\n        }\n      }\n    } else {\n      listNode.insertBefore(paragraph);\n      this.remove();\n    }\n    return true;\n  }\n  getValue() {\n    const self = this.getLatest();\n    return self.__value;\n  }\n  setValue(value) {\n    const self = this.getWritable();\n    self.__value = value;\n    return self;\n  }\n  getChecked() {\n    const self = this.getLatest();\n    let listType;\n    const parent = this.getParent();\n    if ($isListNode(parent)) {\n      listType = parent.getListType();\n    }\n    return listType === 'check' ? Boolean(self.__checked) : undefined;\n  }\n  setChecked(checked) {\n    const self = this.getWritable();\n    self.__checked = checked;\n    return self;\n  }\n  toggleChecked() {\n    const self = this.getWritable();\n    return self.setChecked(!self.__checked);\n  }\n  getIndent() {\n    // If we don't have a parent, we are likely serializing\n    const parent = this.getParent();\n    if (parent === null || !this.isAttached()) {\n      return this.getLatest().__indent;\n    }\n    // ListItemNode should always have a ListNode for a parent.\n    let listNodeParent = parent.getParentOrThrow();\n    let indentLevel = 0;\n    while ($isListItemNode(listNodeParent)) {\n      listNodeParent = listNodeParent.getParentOrThrow().getParentOrThrow();\n      indentLevel++;\n    }\n    return indentLevel;\n  }\n  setIndent(indent) {\n    if (!(typeof indent === 'number')) {\n      formatDevErrorMessage(`Invalid indent value.`);\n    }\n    indent = Math.floor(indent);\n    if (!(indent >= 0)) {\n      formatDevErrorMessage(`Indent value must be non-negative.`);\n    }\n    let currentIndent = this.getIndent();\n    while (currentIndent !== indent) {\n      if (currentIndent < indent) {\n        $handleIndent(this);\n        currentIndent++;\n      } else {\n        $handleOutdent(this);\n        currentIndent--;\n      }\n    }\n    return this;\n  }\n\n  /** @deprecated @internal */\n  canInsertAfter(node) {\n    return $isListItemNode(node);\n  }\n\n  /** @deprecated @internal */\n  canReplaceWith(replacement) {\n    return $isListItemNode(replacement);\n  }\n  canMergeWith(node) {\n    return $isListItemNode(node) || $isParagraphNode(node);\n  }\n  extractWithChild(child, selection) {\n    if (!$isRangeSelection(selection)) {\n      return false;\n    }\n    const anchorNode = selection.anchor.getNode();\n    const focusNode = selection.focus.getNode();\n    return this.isParentOf(anchorNode) && this.isParentOf(focusNode) && this.getTextContent().length === selection.getTextContent().length;\n  }\n  isParentRequired() {\n    return true;\n  }\n  createParentElementNode() {\n    return $createListNode('bullet');\n  }\n  canMergeWhenEmpty() {\n    return true;\n  }\n}\nfunction $setListItemThemeClassNames(dom, editorThemeClasses, node) {\n  const classesToAdd = [];\n  const classesToRemove = [];\n  const listTheme = editorThemeClasses.list;\n  const listItemClassName = listTheme ? listTheme.listitem : undefined;\n  let nestedListItemClassName;\n  if (listTheme && listTheme.nested) {\n    nestedListItemClassName = listTheme.nested.listitem;\n  }\n  if (listItemClassName !== undefined) {\n    classesToAdd.push(...normalizeClassNames(listItemClassName));\n  }\n  if (listTheme) {\n    const parentNode = node.getParent();\n    const isCheckList = $isListNode(parentNode) && parentNode.getListType() === 'check';\n    const checked = node.getChecked();\n    if (!isCheckList || checked) {\n      classesToRemove.push(listTheme.listitemUnchecked);\n    }\n    if (!isCheckList || !checked) {\n      classesToRemove.push(listTheme.listitemChecked);\n    }\n    if (isCheckList) {\n      classesToAdd.push(checked ? listTheme.listitemChecked : listTheme.listitemUnchecked);\n    }\n  }\n  if (nestedListItemClassName !== undefined) {\n    const nestedListItemClasses = normalizeClassNames(nestedListItemClassName);\n    if (node.getChildren().some(child => $isListNode(child))) {\n      classesToAdd.push(...nestedListItemClasses);\n    } else {\n      classesToRemove.push(...nestedListItemClasses);\n    }\n  }\n  if (classesToRemove.length > 0) {\n    removeClassNamesFromElement(dom, ...classesToRemove);\n  }\n  if (classesToAdd.length > 0) {\n    addClassNamesToElement(dom, ...classesToAdd);\n  }\n}\nfunction updateListItemChecked(dom, listItemNode, prevListItemNode, listNode) {\n  // Only add attributes for leaf list items\n  if ($isListNode(listItemNode.getFirstChild())) {\n    dom.removeAttribute('role');\n    dom.removeAttribute('tabIndex');\n    dom.removeAttribute('aria-checked');\n  } else {\n    dom.setAttribute('role', 'checkbox');\n    dom.setAttribute('tabIndex', '-1');\n    if (!prevListItemNode || listItemNode.__checked !== prevListItemNode.__checked) {\n      dom.setAttribute('aria-checked', listItemNode.getChecked() ? 'true' : 'false');\n    }\n  }\n}\nfunction $convertListItemElement(domNode) {\n  const isGitHubCheckList = domNode.classList.contains('task-list-item');\n  if (isGitHubCheckList) {\n    for (const child of domNode.children) {\n      if (child.tagName === 'INPUT') {\n        return $convertCheckboxInput(child);\n      }\n    }\n  }\n  const ariaCheckedAttr = domNode.getAttribute('aria-checked');\n  const checked = ariaCheckedAttr === 'true' ? true : ariaCheckedAttr === 'false' ? false : undefined;\n  return {\n    node: $createListItemNode(checked)\n  };\n}\nfunction $convertCheckboxInput(domNode) {\n  const isCheckboxInput = domNode.getAttribute('type') === 'checkbox';\n  if (!isCheckboxInput) {\n    return {\n      node: null\n    };\n  }\n  const checked = domNode.hasAttribute('checked');\n  return {\n    node: $createListItemNode(checked)\n  };\n}\n\n/**\n * Creates a new List Item node, passing true/false will convert it to a checkbox input.\n * @param checked - Is the List Item a checkbox and, if so, is it checked? undefined/null: not a checkbox, true/false is a checkbox and checked/unchecked, respectively.\n * @returns The new List Item.\n */\nfunction $createListItemNode(checked) {\n  return $applyNodeReplacement(new ListItemNode(undefined, checked));\n}\n\n/**\n * Checks to see if the node is a ListItemNode.\n * @param node - The node to be checked.\n * @returns true if the node is a ListItemNode, false otherwise.\n */\nfunction $isListItemNode(node) {\n  return node instanceof ListItemNode;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/** @noInheritDoc */\nclass ListNode extends ElementNode {\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n  $config() {\n    return this.config('list', {\n      $transform: node => {\n        mergeNextSiblingListIfSameType(node);\n        updateChildrenListItemValue(node);\n      },\n      extends: ElementNode,\n      importDOM: buildImportMap({\n        ol: () => ({\n          conversion: $convertListNode,\n          priority: 0\n        }),\n        ul: () => ({\n          conversion: $convertListNode,\n          priority: 0\n        })\n      })\n    });\n  }\n  constructor(listType = 'number', start = 1, key) {\n    super(key);\n    const _listType = TAG_TO_LIST_TYPE[listType] || listType;\n    this.__listType = _listType;\n    this.__tag = _listType === 'number' ? 'ol' : 'ul';\n    this.__start = start;\n  }\n  afterCloneFrom(prevNode) {\n    super.afterCloneFrom(prevNode);\n    this.__listType = prevNode.__listType;\n    this.__tag = prevNode.__tag;\n    this.__start = prevNode.__start;\n  }\n  getTag() {\n    return this.getLatest().__tag;\n  }\n  setListType(type) {\n    const writable = this.getWritable();\n    writable.__listType = type;\n    writable.__tag = type === 'number' ? 'ol' : 'ul';\n    return writable;\n  }\n  getListType() {\n    return this.getLatest().__listType;\n  }\n  getStart() {\n    return this.getLatest().__start;\n  }\n  setStart(start) {\n    const self = this.getWritable();\n    self.__start = start;\n    return self;\n  }\n\n  // View\n\n  createDOM(config, _editor) {\n    const tag = this.__tag;\n    const dom = document.createElement(tag);\n    if (this.__start !== 1) {\n      dom.setAttribute('start', String(this.__start));\n    }\n    // @ts-expect-error Internal field.\n    dom.__lexicalListType = this.__listType;\n    $setListThemeClassNames(dom, config.theme, this);\n    return dom;\n  }\n  updateDOM(prevNode, dom, config) {\n    if (prevNode.__tag !== this.__tag) {\n      return true;\n    }\n    $setListThemeClassNames(dom, config.theme, this);\n    return false;\n  }\n  updateFromJSON(serializedNode) {\n    return super.updateFromJSON(serializedNode).setListType(serializedNode.listType).setStart(serializedNode.start);\n  }\n  exportDOM(editor) {\n    const element = this.createDOM(editor._config, editor);\n    if (isHTMLElement(element)) {\n      if (this.__start !== 1) {\n        element.setAttribute('start', String(this.__start));\n      }\n      if (this.__listType === 'check') {\n        element.setAttribute('__lexicalListType', 'check');\n      }\n    }\n    return {\n      element\n    };\n  }\n  exportJSON() {\n    return {\n      ...super.exportJSON(),\n      listType: this.getListType(),\n      start: this.getStart(),\n      tag: this.getTag()\n    };\n  }\n  canBeEmpty() {\n    return false;\n  }\n  canIndent() {\n    return false;\n  }\n  splice(start, deleteCount, nodesToInsert) {\n    let listItemNodesToInsert = nodesToInsert;\n    for (let i = 0; i < nodesToInsert.length; i++) {\n      const node = nodesToInsert[i];\n      if (!$isListItemNode(node)) {\n        if (listItemNodesToInsert === nodesToInsert) {\n          listItemNodesToInsert = [...nodesToInsert];\n        }\n        listItemNodesToInsert[i] = $createListItemNode().append($isElementNode(node) && !($isListNode(node) || node.isInline()) ? $createTextNode(node.getTextContent()) : node);\n      }\n    }\n    return super.splice(start, deleteCount, listItemNodesToInsert);\n  }\n  extractWithChild(child) {\n    return $isListItemNode(child);\n  }\n}\nfunction $setListThemeClassNames(dom, editorThemeClasses, node) {\n  const classesToAdd = [];\n  const classesToRemove = [];\n  const listTheme = editorThemeClasses.list;\n  if (listTheme !== undefined) {\n    const listLevelsClassNames = listTheme[`${node.__tag}Depth`] || [];\n    const listDepth = $getListDepth(node) - 1;\n    const normalizedListDepth = listDepth % listLevelsClassNames.length;\n    const listLevelClassName = listLevelsClassNames[normalizedListDepth];\n    const listClassName = listTheme[node.__tag];\n    let nestedListClassName;\n    const nestedListTheme = listTheme.nested;\n    const checklistClassName = listTheme.checklist;\n    if (nestedListTheme !== undefined && nestedListTheme.list) {\n      nestedListClassName = nestedListTheme.list;\n    }\n    if (listClassName !== undefined) {\n      classesToAdd.push(listClassName);\n    }\n    if (checklistClassName !== undefined && node.__listType === 'check') {\n      classesToAdd.push(checklistClassName);\n    }\n    if (listLevelClassName !== undefined) {\n      classesToAdd.push(...normalizeClassNames(listLevelClassName));\n      for (let i = 0; i < listLevelsClassNames.length; i++) {\n        if (i !== normalizedListDepth) {\n          classesToRemove.push(node.__tag + i);\n        }\n      }\n    }\n    if (nestedListClassName !== undefined) {\n      const nestedListItemClasses = normalizeClassNames(nestedListClassName);\n      if (listDepth > 1) {\n        classesToAdd.push(...nestedListItemClasses);\n      } else {\n        classesToRemove.push(...nestedListItemClasses);\n      }\n    }\n  }\n  if (classesToRemove.length > 0) {\n    removeClassNamesFromElement(dom, ...classesToRemove);\n  }\n  if (classesToAdd.length > 0) {\n    addClassNamesToElement(dom, ...classesToAdd);\n  }\n}\n\n/*\n * This function normalizes the children of a ListNode after the conversion from HTML,\n * ensuring that they are all ListItemNodes and contain either a single nested ListNode\n * or some other inline content.\n */\nfunction $normalizeChildren(nodes) {\n  const normalizedListItems = [];\n  for (let i = 0; i < nodes.length; i++) {\n    const node = nodes[i];\n    if ($isListItemNode(node)) {\n      normalizedListItems.push(node);\n      const children = node.getChildren();\n      if (children.length > 1) {\n        children.forEach(child => {\n          if ($isListNode(child)) {\n            normalizedListItems.push($wrapInListItem(child));\n          }\n        });\n      }\n    } else {\n      normalizedListItems.push($wrapInListItem(node));\n    }\n  }\n  return normalizedListItems;\n}\nfunction isDomChecklist(domNode) {\n  if (domNode.getAttribute('__lexicallisttype') === 'check' ||\n  // is github checklist\n  domNode.classList.contains('contains-task-list')) {\n    return true;\n  }\n  // if children are checklist items, the node is a checklist ul. Applicable for googledoc checklist pasting.\n  for (const child of domNode.childNodes) {\n    if (isHTMLElement(child) && child.hasAttribute('aria-checked')) {\n      return true;\n    }\n  }\n  return false;\n}\nfunction $convertListNode(domNode) {\n  const nodeName = domNode.nodeName.toLowerCase();\n  let node = null;\n  if (nodeName === 'ol') {\n    // @ts-ignore\n    const start = domNode.start;\n    node = $createListNode('number', start);\n  } else if (nodeName === 'ul') {\n    if (isDomChecklist(domNode)) {\n      node = $createListNode('check');\n    } else {\n      node = $createListNode('bullet');\n    }\n  }\n  return {\n    after: $normalizeChildren,\n    node\n  };\n}\nconst TAG_TO_LIST_TYPE = {\n  ol: 'number',\n  ul: 'bullet'\n};\n\n/**\n * Creates a ListNode of listType.\n * @param listType - The type of list to be created. Can be 'number', 'bullet', or 'check'.\n * @param start - Where an ordered list starts its count, start = 1 if left undefined.\n * @returns The new ListNode\n */\nfunction $createListNode(listType = 'number', start = 1) {\n  return $applyNodeReplacement(new ListNode(listType, start));\n}\n\n/**\n * Checks to see if the node is a ListNode.\n * @param node - The node to be checked.\n * @returns true if the node is a ListNode, false otherwise.\n */\nfunction $isListNode(node) {\n  return node instanceof ListNode;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst INSERT_CHECK_LIST_COMMAND = createCommand('INSERT_CHECK_LIST_COMMAND');\nfunction registerCheckList(editor) {\n  return mergeRegister(editor.registerCommand(INSERT_CHECK_LIST_COMMAND, () => {\n    $insertList('check');\n    return true;\n  }, COMMAND_PRIORITY_LOW), editor.registerCommand(KEY_ARROW_DOWN_COMMAND, event => {\n    return handleArrowUpOrDown(event, editor, false);\n  }, COMMAND_PRIORITY_LOW), editor.registerCommand(KEY_ARROW_UP_COMMAND, event => {\n    return handleArrowUpOrDown(event, editor, true);\n  }, COMMAND_PRIORITY_LOW), editor.registerCommand(KEY_ESCAPE_COMMAND, () => {\n    const activeItem = getActiveCheckListItem();\n    if (activeItem != null) {\n      const rootElement = editor.getRootElement();\n      if (rootElement != null) {\n        rootElement.focus();\n      }\n      return true;\n    }\n    return false;\n  }, COMMAND_PRIORITY_LOW), editor.registerCommand(KEY_SPACE_COMMAND, event => {\n    const activeItem = getActiveCheckListItem();\n    if (activeItem != null && editor.isEditable()) {\n      editor.update(() => {\n        const listItemNode = $getNearestNodeFromDOMNode(activeItem);\n        if ($isListItemNode(listItemNode)) {\n          event.preventDefault();\n          listItemNode.toggleChecked();\n        }\n      });\n      return true;\n    }\n    return false;\n  }, COMMAND_PRIORITY_LOW), editor.registerCommand(KEY_ARROW_LEFT_COMMAND, event => {\n    return editor.getEditorState().read(() => {\n      const selection = $getSelection();\n      if ($isRangeSelection(selection) && selection.isCollapsed()) {\n        const {\n          anchor\n        } = selection;\n        const isElement = anchor.type === 'element';\n        if (isElement || anchor.offset === 0) {\n          const anchorNode = anchor.getNode();\n          const elementNode = $findMatchingParent(anchorNode, node => $isElementNode(node) && !node.isInline());\n          if ($isListItemNode(elementNode)) {\n            const parent = elementNode.getParent();\n            if ($isListNode(parent) && parent.getListType() === 'check' && (isElement || elementNode.getFirstDescendant() === anchorNode)) {\n              const domNode = editor.getElementByKey(elementNode.__key);\n              if (domNode != null && document.activeElement !== domNode) {\n                domNode.focus();\n                event.preventDefault();\n                return true;\n              }\n            }\n          }\n        }\n      }\n      return false;\n    });\n  }, COMMAND_PRIORITY_LOW), editor.registerRootListener((rootElement, prevElement) => {\n    if (rootElement !== null) {\n      rootElement.addEventListener('click', handleClick);\n      rootElement.addEventListener('pointerdown', handlePointerDown);\n    }\n    if (prevElement !== null) {\n      prevElement.removeEventListener('click', handleClick);\n      prevElement.removeEventListener('pointerdown', handlePointerDown);\n    }\n  }));\n}\nfunction handleCheckItemEvent(event, callback) {\n  const target = event.target;\n  if (!isHTMLElement(target)) {\n    return;\n  }\n\n  // Ignore clicks on LI that have nested lists\n  const firstChild = target.firstChild;\n  if (isHTMLElement(firstChild) && (firstChild.tagName === 'UL' || firstChild.tagName === 'OL')) {\n    return;\n  }\n  const parentNode = target.parentNode;\n\n  // @ts-ignore internal field\n  if (!parentNode || parentNode.__lexicalListType !== 'check') {\n    return;\n  }\n  const rect = target.getBoundingClientRect();\n  const zoom = calculateZoomLevel(target);\n  const clientX = event.clientX / zoom;\n\n  // Use getComputedStyle if available, otherwise fallback to 0px width\n  const beforeStyles = window.getComputedStyle ? window.getComputedStyle(target, '::before') : {\n    width: '0px'\n  };\n  const beforeWidthInPixels = parseFloat(beforeStyles.width);\n\n  // Make click area slightly larger for touch devices to improve accessibility\n  const isTouchEvent = event.pointerType === 'touch';\n  const clickAreaPadding = isTouchEvent ? 32 : 0; // Add 32px padding for touch events\n\n  if (target.dir === 'rtl' ? clientX < rect.right + clickAreaPadding && clientX > rect.right - beforeWidthInPixels - clickAreaPadding : clientX > rect.left - clickAreaPadding && clientX < rect.left + beforeWidthInPixels + clickAreaPadding) {\n    callback();\n  }\n}\nfunction handleClick(event) {\n  handleCheckItemEvent(event, () => {\n    if (isHTMLElement(event.target)) {\n      const domNode = event.target;\n      const editor = getNearestEditorFromDOMNode(domNode);\n      if (editor != null && editor.isEditable()) {\n        editor.update(() => {\n          const node = $getNearestNodeFromDOMNode(domNode);\n          if ($isListItemNode(node)) {\n            domNode.focus();\n            node.toggleChecked();\n          }\n        });\n      }\n    }\n  });\n}\nfunction handlePointerDown(event) {\n  handleCheckItemEvent(event, () => {\n    // Prevents caret moving when clicking on check mark\n    event.preventDefault();\n  });\n}\nfunction getActiveCheckListItem() {\n  const activeElement = document.activeElement;\n  return isHTMLElement(activeElement) && activeElement.tagName === 'LI' && activeElement.parentNode != null &&\n  // @ts-ignore internal field\n  activeElement.parentNode.__lexicalListType === 'check' ? activeElement : null;\n}\nfunction findCheckListItemSibling(node, backward) {\n  let sibling = backward ? node.getPreviousSibling() : node.getNextSibling();\n  let parent = node;\n\n  // Going up in a tree to get non-null sibling\n  while (sibling == null && $isListItemNode(parent)) {\n    // Get li -> parent ul/ol -> parent li\n    parent = parent.getParentOrThrow().getParent();\n    if (parent != null) {\n      sibling = backward ? parent.getPreviousSibling() : parent.getNextSibling();\n    }\n  }\n\n  // Going down in a tree to get first non-nested list item\n  while ($isListItemNode(sibling)) {\n    const firstChild = backward ? sibling.getLastChild() : sibling.getFirstChild();\n    if (!$isListNode(firstChild)) {\n      return sibling;\n    }\n    sibling = backward ? firstChild.getLastChild() : firstChild.getFirstChild();\n  }\n  return null;\n}\nfunction handleArrowUpOrDown(event, editor, backward) {\n  const activeItem = getActiveCheckListItem();\n  if (activeItem != null) {\n    editor.update(() => {\n      const listItem = $getNearestNodeFromDOMNode(activeItem);\n      if (!$isListItemNode(listItem)) {\n        return;\n      }\n      const nextListItem = findCheckListItemSibling(listItem, backward);\n      if (nextListItem != null) {\n        nextListItem.selectStart();\n        const dom = editor.getElementByKey(nextListItem.__key);\n        if (dom != null) {\n          event.preventDefault();\n          setTimeout(() => {\n            dom.focus();\n          }, 0);\n        }\n      }\n    });\n  }\n  return false;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst UPDATE_LIST_START_COMMAND = createCommand('UPDATE_LIST_START_COMMAND');\nconst INSERT_UNORDERED_LIST_COMMAND = createCommand('INSERT_UNORDERED_LIST_COMMAND');\nconst INSERT_ORDERED_LIST_COMMAND = createCommand('INSERT_ORDERED_LIST_COMMAND');\nconst REMOVE_LIST_COMMAND = createCommand('REMOVE_LIST_COMMAND');\nfunction registerList(editor) {\n  const removeListener = mergeRegister(editor.registerCommand(INSERT_ORDERED_LIST_COMMAND, () => {\n    $insertList('number');\n    return true;\n  }, COMMAND_PRIORITY_LOW), editor.registerCommand(UPDATE_LIST_START_COMMAND, payload => {\n    const {\n      listNodeKey,\n      newStart\n    } = payload;\n    const listNode = $getNodeByKey(listNodeKey);\n    if (!$isListNode(listNode)) {\n      return false;\n    }\n    if (listNode.getListType() === 'number') {\n      listNode.setStart(newStart);\n      updateChildrenListItemValue(listNode);\n    }\n    return true;\n  }, COMMAND_PRIORITY_LOW), editor.registerCommand(INSERT_UNORDERED_LIST_COMMAND, () => {\n    $insertList('bullet');\n    return true;\n  }, COMMAND_PRIORITY_LOW), editor.registerCommand(REMOVE_LIST_COMMAND, () => {\n    $removeList();\n    return true;\n  }, COMMAND_PRIORITY_LOW), editor.registerCommand(INSERT_PARAGRAPH_COMMAND, () => $handleListInsertParagraph(), COMMAND_PRIORITY_LOW), editor.registerNodeTransform(ListItemNode, node => {\n    const firstChild = node.getFirstChild();\n    if (firstChild) {\n      if ($isTextNode(firstChild)) {\n        const style = firstChild.getStyle();\n        const format = firstChild.getFormat();\n        if (node.getTextStyle() !== style) {\n          node.setTextStyle(style);\n        }\n        if (node.getTextFormat() !== format) {\n          node.setTextFormat(format);\n        }\n      }\n    } else {\n      // If it's empty, check the selection\n      const selection = $getSelection();\n      if ($isRangeSelection(selection) && (selection.style !== node.getTextStyle() || selection.format !== node.getTextFormat()) && selection.isCollapsed() && node.is(selection.anchor.getNode())) {\n        node.setTextStyle(selection.style).setTextFormat(selection.format);\n      }\n    }\n  }), editor.registerNodeTransform(TextNode, node => {\n    const listItemParentNode = node.getParent();\n    if ($isListItemNode(listItemParentNode) && node.is(listItemParentNode.getFirstChild())) {\n      const style = node.getStyle();\n      const format = node.getFormat();\n      if (style !== listItemParentNode.getTextStyle() || format !== listItemParentNode.getTextFormat()) {\n        listItemParentNode.setTextStyle(style).setTextFormat(format);\n      }\n    }\n  }));\n  return removeListener;\n}\nfunction registerListStrictIndentTransform(editor) {\n  const $formatListIndentStrict = listItemNode => {\n    const listNode = listItemNode.getParent();\n    if ($isListNode(listItemNode.getFirstChild()) || !$isListNode(listNode)) {\n      return;\n    }\n    const startingListItemNode = $findMatchingParent(listItemNode, node => $isListItemNode(node) && $isListNode(node.getParent()) && $isListItemNode(node.getPreviousSibling()));\n    if (startingListItemNode === null && listItemNode.getIndent() > 0) {\n      listItemNode.setIndent(0);\n    } else if ($isListItemNode(startingListItemNode)) {\n      const prevListItemNode = startingListItemNode.getPreviousSibling();\n      if ($isListItemNode(prevListItemNode)) {\n        const endListItemNode = $findChildrenEndListItemNode(prevListItemNode);\n        const endListNode = endListItemNode.getParent();\n        if ($isListNode(endListNode)) {\n          const prevDepth = $getListDepth(endListNode);\n          const depth = $getListDepth(listNode);\n          if (prevDepth + 1 < depth) {\n            listItemNode.setIndent(prevDepth);\n          }\n        }\n      }\n    }\n  };\n  const $processListWithStrictIndent = listNode => {\n    const queue = [listNode];\n    while (queue.length > 0) {\n      const node = queue.shift();\n      if (!$isListNode(node)) {\n        continue;\n      }\n      for (const child of node.getChildren()) {\n        if ($isListItemNode(child)) {\n          $formatListIndentStrict(child);\n          const firstChild = child.getFirstChild();\n          if ($isListNode(firstChild)) {\n            queue.push(firstChild);\n          }\n        }\n      }\n    }\n  };\n  return editor.registerNodeTransform(ListNode, $processListWithStrictIndent);\n}\nfunction $findChildrenEndListItemNode(listItemNode) {\n  let current = listItemNode;\n  let firstChild = current.getFirstChild();\n  while ($isListNode(firstChild)) {\n    const lastChild = firstChild.getLastChild();\n    if ($isListItemNode(lastChild)) {\n      current = lastChild;\n      firstChild = current.getFirstChild();\n    } else {\n      break;\n    }\n  }\n  return current;\n}\n\n/**\n * @deprecated use {@link $insertList} from an update or command listener.\n *\n * Inserts a new ListNode. If the selection's anchor node is an empty ListItemNode and is a child of\n * the root/shadow root, it will replace the ListItemNode with a ListNode and the old ListItemNode.\n * Otherwise it will replace its parent with a new ListNode and re-insert the ListItemNode and any previous children.\n * If the selection's anchor node is not an empty ListItemNode, it will add a new ListNode or merge an existing ListNode,\n * unless the the node is a leaf node, in which case it will attempt to find a ListNode up the branch and replace it with\n * a new ListNode, or create a new ListNode at the nearest root/shadow root.\n * @param editor - The lexical editor.\n * @param listType - The type of list, \"number\" | \"bullet\" | \"check\".\n */\nfunction insertList(editor, listType) {\n  editor.update(() => $insertList(listType));\n}\n\n/**\n * @deprecated use {@link $removeList} from an update or command listener.\n *\n * Searches for the nearest ancestral ListNode and removes it. If selection is an empty ListItemNode\n * it will remove the whole list, including the ListItemNode. For each ListItemNode in the ListNode,\n * removeList will also generate new ParagraphNodes in the removed ListNode's place. Any child node\n * inside a ListItemNode will be appended to the new ParagraphNodes.\n * @param editor - The lexical editor.\n */\nfunction removeList(editor) {\n  editor.update(() => $removeList());\n}\nexport { $createListItemNode, $createListNode, $getListDepth, $handleListInsertParagraph, $insertList, $isListItemNode, $isListNode, $removeList, INSERT_CHECK_LIST_COMMAND, INSERT_ORDERED_LIST_COMMAND, INSERT_UNORDERED_LIST_COMMAND, ListItemNode, ListNode, REMOVE_LIST_COMMAND, UPDATE_LIST_START_COMMAND, insertList, registerCheckList, registerList, registerListStrictIndentTransform, removeList };","map":{"version":3,"names":["$getNearestNodeOfType","removeClassNamesFromElement","addClassNamesToElement","isHTMLElement","mergeRegister","$findMatchingParent","calculateZoomLevel","$getSelection","$isRangeSelection","$isRootOrShadowRoot","$createParagraphNode","$isElementNode","$isLeafNode","$setPointFromCaret","$normalizeCaret","$getChildCaret","ElementNode","buildImportMap","$isParagraphNode","$applyNodeReplacement","$createTextNode","createCommand","COMMAND_PRIORITY_LOW","KEY_ARROW_DOWN_COMMAND","KEY_ARROW_UP_COMMAND","KEY_ESCAPE_COMMAND","KEY_SPACE_COMMAND","$getNearestNodeFromDOMNode","KEY_ARROW_LEFT_COMMAND","getNearestEditorFromDOMNode","$getNodeByKey","INSERT_PARAGRAPH_COMMAND","$isTextNode","TextNode","getStyleObjectFromCSS","formatDevErrorMessage","message","Error","$getListDepth","listNode","depth","parent","getParent","$isListItemNode","parentList","$isListNode","$getTopListNode","listItem","list","$getAllListItems","node","listItemNodes","listChildren","getChildren","filter","i","length","listItemNode","firstChild","getFirstChild","concat","push","isNestedListNode","$removeHighestEmptyListParent","sublist","emptyListPtr","getNextSibling","getPreviousSibling","remove","$wrapInListItem","listItemWrapper","$createListItemNode","append","$isSelectingEmptyListItem","anchorNode","nodes","is","getChildrenSize","$insertList","listType","selection","getNodes","anchorAndFocus","getStartEndPoints","anchor","getNode","anchorNodeParent","selectStart","paragraph","select","$createListNode","replace","setFormat","getFormatType","setIndent","getIndent","getParentOrThrow","handled","Set","isEmpty","has","getKey","$createListOrMerge","parentKey","newListNode","add","nextParent","nodesToAppend","splice","previousSibling","nextSibling","targetList","getListType","getFirstChildOrThrow","insertBefore","mergeLists","list1","list2","listItem1","getLastChild","listItem2","toMerge","$removeList","listNodes","ListItemNode","insertionPoint","listItems","setTextStyle","style","setTextFormat","format","insertAfter","__key","key","focus","updateChildrenListItemValue","isNotChecklist","value","getStart","child","getValue","setValue","getLatest","__checked","setChecked","undefined","mergeNextSiblingListIfSameType","$handleIndent","removed","innerList","nextInnerList","children","newListItem","getTextFormat","getTextStyle","newList","$handleOutdent","grandparentListItem","greatGrandparentList","lastChild","previousSiblingsListItem","previousSiblingsList","getPreviousSiblings","forEach","sibling","nextSiblingsListItem","nextSiblingsList","getNextSiblings","$handleListInsertParagraph","isCollapsed","topListNode","grandparent","replacementNode","nextSiblings","normalizeClassNames","classNames","rval","className","s","matchAll","applyMarkerStyles","dom","prevNode","styles","__textStyle","k","setProperty","removeProperty","$config","config","$transform","getChecked","extends","importDOM","li","conversion","$convertListItemElement","priority","constructor","checked","__value","afterCloneFrom","createDOM","element","document","createElement","updateListItemDOM","updateListItemChecked","$setListItemThemeClassNames","theme","prevStyle","__style","nextStyle","removeAttribute","cssText","updateDOM","updateFromJSON","serializedNode","exportDOM","editor","_config","formatType","textAlign","direction","getDirection","dir","exportJSON","canMergeWith","replaceWithNode","includeChildren","__first","__last","nodeToAppend","restoreSelection","siblings","preserveEmptyParent","prevSibling","insertNewAfter","_","newElement","collapseAtStart","listNodeParent","isIndented","type","set","offset","self","getWritable","Boolean","toggleChecked","isAttached","__indent","indentLevel","indent","Math","floor","currentIndent","canInsertAfter","canReplaceWith","replacement","extractWithChild","focusNode","isParentOf","getTextContent","isParentRequired","createParentElementNode","canMergeWhenEmpty","editorThemeClasses","classesToAdd","classesToRemove","listTheme","listItemClassName","listitem","nestedListItemClassName","nested","parentNode","isCheckList","listitemUnchecked","listitemChecked","nestedListItemClasses","some","prevListItemNode","setAttribute","domNode","isGitHubCheckList","classList","contains","tagName","$convertCheckboxInput","ariaCheckedAttr","getAttribute","isCheckboxInput","hasAttribute","ListNode","ol","$convertListNode","ul","start","_listType","TAG_TO_LIST_TYPE","__listType","__tag","__start","getTag","setListType","writable","setStart","_editor","tag","String","__lexicalListType","$setListThemeClassNames","canBeEmpty","canIndent","deleteCount","nodesToInsert","listItemNodesToInsert","isInline","listLevelsClassNames","listDepth","normalizedListDepth","listLevelClassName","listClassName","nestedListClassName","nestedListTheme","checklistClassName","checklist","$normalizeChildren","normalizedListItems","isDomChecklist","childNodes","nodeName","toLowerCase","after","INSERT_CHECK_LIST_COMMAND","registerCheckList","registerCommand","event","handleArrowUpOrDown","activeItem","getActiveCheckListItem","rootElement","getRootElement","isEditable","update","preventDefault","getEditorState","read","isElement","elementNode","getFirstDescendant","getElementByKey","activeElement","registerRootListener","prevElement","addEventListener","handleClick","handlePointerDown","removeEventListener","handleCheckItemEvent","callback","target","rect","getBoundingClientRect","zoom","clientX","beforeStyles","window","getComputedStyle","width","beforeWidthInPixels","parseFloat","isTouchEvent","pointerType","clickAreaPadding","right","left","findCheckListItemSibling","backward","nextListItem","setTimeout","UPDATE_LIST_START_COMMAND","INSERT_UNORDERED_LIST_COMMAND","INSERT_ORDERED_LIST_COMMAND","REMOVE_LIST_COMMAND","registerList","removeListener","payload","listNodeKey","newStart","registerNodeTransform","getStyle","getFormat","listItemParentNode","registerListStrictIndentTransform","$formatListIndentStrict","startingListItemNode","endListItemNode","$findChildrenEndListItemNode","endListNode","prevDepth","$processListWithStrictIndent","queue","shift","current","insertList","removeList"],"sources":["C:/Code/beedoo/node_modules/@lexical/list/LexicalList.dev.mjs"],"sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport { $getNearestNodeOfType, removeClassNamesFromElement, addClassNamesToElement, isHTMLElement, mergeRegister, $findMatchingParent, calculateZoomLevel } from '@lexical/utils';\nimport { $getSelection, $isRangeSelection, $isRootOrShadowRoot, $createParagraphNode, $isElementNode, $isLeafNode, $setPointFromCaret, $normalizeCaret, $getChildCaret, ElementNode, buildImportMap, $isParagraphNode, $applyNodeReplacement, $createTextNode, createCommand, COMMAND_PRIORITY_LOW, KEY_ARROW_DOWN_COMMAND, KEY_ARROW_UP_COMMAND, KEY_ESCAPE_COMMAND, KEY_SPACE_COMMAND, $getNearestNodeFromDOMNode, KEY_ARROW_LEFT_COMMAND, getNearestEditorFromDOMNode, $getNodeByKey, INSERT_PARAGRAPH_COMMAND, $isTextNode, TextNode } from 'lexical';\nimport { getStyleObjectFromCSS } from '@lexical/selection';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n// Do not require this module directly! Use normal `invariant` calls.\n\nfunction formatDevErrorMessage(message) {\n  throw new Error(message);\n}\n\n/**\n * Checks the depth of listNode from the root node.\n * @param listNode - The ListNode to be checked.\n * @returns The depth of the ListNode.\n */\nfunction $getListDepth(listNode) {\n  let depth = 1;\n  let parent = listNode.getParent();\n  while (parent != null) {\n    if ($isListItemNode(parent)) {\n      const parentList = parent.getParent();\n      if ($isListNode(parentList)) {\n        depth++;\n        parent = parentList.getParent();\n        continue;\n      }\n      {\n        formatDevErrorMessage(`A ListItemNode must have a ListNode for a parent.`);\n      }\n    }\n    return depth;\n  }\n  return depth;\n}\n\n/**\n * Finds the nearest ancestral ListNode and returns it, throws an invariant if listItem is not a ListItemNode.\n * @param listItem - The node to be checked.\n * @returns The ListNode found.\n */\nfunction $getTopListNode(listItem) {\n  let list = listItem.getParent();\n  if (!$isListNode(list)) {\n    {\n      formatDevErrorMessage(`A ListItemNode must have a ListNode for a parent.`);\n    }\n  }\n  let parent = list;\n  while (parent !== null) {\n    parent = parent.getParent();\n    if ($isListNode(parent)) {\n      list = parent;\n    }\n  }\n  return list;\n}\n\n/**\n * A recursive Depth-First Search (Postorder Traversal) that finds all of a node's children\n * that are of type ListItemNode and returns them in an array.\n * @param node - The ListNode to start the search.\n * @returns An array containing all nodes of type ListItemNode found.\n */\n// This should probably be $getAllChildrenOfType\nfunction $getAllListItems(node) {\n  let listItemNodes = [];\n  const listChildren = node.getChildren().filter($isListItemNode);\n  for (let i = 0; i < listChildren.length; i++) {\n    const listItemNode = listChildren[i];\n    const firstChild = listItemNode.getFirstChild();\n    if ($isListNode(firstChild)) {\n      listItemNodes = listItemNodes.concat($getAllListItems(firstChild));\n    } else {\n      listItemNodes.push(listItemNode);\n    }\n  }\n  return listItemNodes;\n}\n\n/**\n * Checks to see if the passed node is a ListItemNode and has a ListNode as a child.\n * @param node - The node to be checked.\n * @returns true if the node is a ListItemNode and has a ListNode child, false otherwise.\n */\nfunction isNestedListNode(node) {\n  return $isListItemNode(node) && $isListNode(node.getFirstChild());\n}\n\n/**\n * Takes a deeply nested ListNode or ListItemNode and traverses up the branch to delete the first\n * ancestral ListNode (which could be the root ListNode) or ListItemNode with siblings, essentially\n * bringing the deeply nested node up the branch once. Would remove sublist if it has siblings.\n * Should not break ListItem -> List -> ListItem chain as empty List/ItemNodes should be removed on .remove().\n * @param sublist - The nested ListNode or ListItemNode to be brought up the branch.\n */\nfunction $removeHighestEmptyListParent(sublist) {\n  // Nodes may be repeatedly indented, to create deeply nested lists that each\n  // contain just one bullet.\n  // Our goal is to remove these (empty) deeply nested lists. The easiest\n  // way to do that is crawl back up the tree until we find a node that has siblings\n  // (e.g. is actually part of the list contents) and delete that, or delete\n  // the root of the list (if no list nodes have siblings.)\n  let emptyListPtr = sublist;\n  while (emptyListPtr.getNextSibling() == null && emptyListPtr.getPreviousSibling() == null) {\n    const parent = emptyListPtr.getParent();\n    if (parent == null || !($isListItemNode(parent) || $isListNode(parent))) {\n      break;\n    }\n    emptyListPtr = parent;\n  }\n  emptyListPtr.remove();\n}\n\n/**\n * Wraps a node into a ListItemNode.\n * @param node - The node to be wrapped into a ListItemNode\n * @returns The ListItemNode which the passed node is wrapped in.\n */\nfunction $wrapInListItem(node) {\n  const listItemWrapper = $createListItemNode();\n  return listItemWrapper.append(node);\n}\n\nfunction $isSelectingEmptyListItem(anchorNode, nodes) {\n  return $isListItemNode(anchorNode) && (nodes.length === 0 || nodes.length === 1 && anchorNode.is(nodes[0]) && anchorNode.getChildrenSize() === 0);\n}\n\n/**\n * Inserts a new ListNode. If the selection's anchor node is an empty ListItemNode and is a child of\n * the root/shadow root, it will replace the ListItemNode with a ListNode and the old ListItemNode.\n * Otherwise it will replace its parent with a new ListNode and re-insert the ListItemNode and any previous children.\n * If the selection's anchor node is not an empty ListItemNode, it will add a new ListNode or merge an existing ListNode,\n * unless the the node is a leaf node, in which case it will attempt to find a ListNode up the branch and replace it with\n * a new ListNode, or create a new ListNode at the nearest root/shadow root.\n * @param listType - The type of list, \"number\" | \"bullet\" | \"check\".\n */\nfunction $insertList(listType) {\n  const selection = $getSelection();\n  if (selection !== null) {\n    let nodes = selection.getNodes();\n    if ($isRangeSelection(selection)) {\n      const anchorAndFocus = selection.getStartEndPoints();\n      if (!(anchorAndFocus !== null)) {\n        formatDevErrorMessage(`insertList: anchor should be defined`);\n      }\n      const [anchor] = anchorAndFocus;\n      const anchorNode = anchor.getNode();\n      const anchorNodeParent = anchorNode.getParent();\n      if ($isRootOrShadowRoot(anchorNode)) {\n        const firstChild = anchorNode.getFirstChild();\n        if (firstChild) {\n          nodes = firstChild.selectStart().getNodes();\n        } else {\n          const paragraph = $createParagraphNode();\n          anchorNode.append(paragraph);\n          nodes = paragraph.select().getNodes();\n        }\n      } else if ($isSelectingEmptyListItem(anchorNode, nodes)) {\n        const list = $createListNode(listType);\n        if ($isRootOrShadowRoot(anchorNodeParent)) {\n          anchorNode.replace(list);\n          const listItem = $createListItemNode();\n          if ($isElementNode(anchorNode)) {\n            listItem.setFormat(anchorNode.getFormatType());\n            listItem.setIndent(anchorNode.getIndent());\n          }\n          list.append(listItem);\n        } else if ($isListItemNode(anchorNode)) {\n          const parent = anchorNode.getParentOrThrow();\n          append(list, parent.getChildren());\n          parent.replace(list);\n        }\n        return;\n      }\n    }\n    const handled = new Set();\n    for (let i = 0; i < nodes.length; i++) {\n      const node = nodes[i];\n      if ($isElementNode(node) && node.isEmpty() && !$isListItemNode(node) && !handled.has(node.getKey())) {\n        $createListOrMerge(node, listType);\n        continue;\n      }\n      let parent = $isLeafNode(node) ? node.getParent() : $isListItemNode(node) && node.isEmpty() ? node : null;\n      while (parent != null) {\n        const parentKey = parent.getKey();\n        if ($isListNode(parent)) {\n          if (!handled.has(parentKey)) {\n            const newListNode = $createListNode(listType);\n            append(newListNode, parent.getChildren());\n            parent.replace(newListNode);\n            handled.add(parentKey);\n          }\n          break;\n        } else {\n          const nextParent = parent.getParent();\n          if ($isRootOrShadowRoot(nextParent) && !handled.has(parentKey)) {\n            handled.add(parentKey);\n            $createListOrMerge(parent, listType);\n            break;\n          }\n          parent = nextParent;\n        }\n      }\n    }\n  }\n}\nfunction append(node, nodesToAppend) {\n  node.splice(node.getChildrenSize(), 0, nodesToAppend);\n}\nfunction $createListOrMerge(node, listType) {\n  if ($isListNode(node)) {\n    return node;\n  }\n  const previousSibling = node.getPreviousSibling();\n  const nextSibling = node.getNextSibling();\n  const listItem = $createListItemNode();\n  append(listItem, node.getChildren());\n  let targetList;\n  if ($isListNode(previousSibling) && listType === previousSibling.getListType()) {\n    previousSibling.append(listItem);\n    // if the same type of list is on both sides, merge them.\n    if ($isListNode(nextSibling) && listType === nextSibling.getListType()) {\n      append(previousSibling, nextSibling.getChildren());\n      nextSibling.remove();\n    }\n    targetList = previousSibling;\n  } else if ($isListNode(nextSibling) && listType === nextSibling.getListType()) {\n    nextSibling.getFirstChildOrThrow().insertBefore(listItem);\n    targetList = nextSibling;\n  } else {\n    const list = $createListNode(listType);\n    list.append(listItem);\n    node.replace(list);\n    targetList = list;\n  }\n  // listItem needs to be attached to root prior to setting indent\n  listItem.setFormat(node.getFormatType());\n  listItem.setIndent(node.getIndent());\n  node.remove();\n  return targetList;\n}\n\n/**\n * A recursive function that goes through each list and their children, including nested lists,\n * appending list2 children after list1 children and updating ListItemNode values.\n * @param list1 - The first list to be merged.\n * @param list2 - The second list to be merged.\n */\nfunction mergeLists(list1, list2) {\n  const listItem1 = list1.getLastChild();\n  const listItem2 = list2.getFirstChild();\n  if (listItem1 && listItem2 && isNestedListNode(listItem1) && isNestedListNode(listItem2)) {\n    mergeLists(listItem1.getFirstChild(), listItem2.getFirstChild());\n    listItem2.remove();\n  }\n  const toMerge = list2.getChildren();\n  if (toMerge.length > 0) {\n    list1.append(...toMerge);\n  }\n  list2.remove();\n}\n\n/**\n * Searches for the nearest ancestral ListNode and removes it. If selection is an empty ListItemNode\n * it will remove the whole list, including the ListItemNode. For each ListItemNode in the ListNode,\n * removeList will also generate new ParagraphNodes in the removed ListNode's place. Any child node\n * inside a ListItemNode will be appended to the new ParagraphNodes.\n */\nfunction $removeList() {\n  const selection = $getSelection();\n  if ($isRangeSelection(selection)) {\n    const listNodes = new Set();\n    const nodes = selection.getNodes();\n    const anchorNode = selection.anchor.getNode();\n    if ($isSelectingEmptyListItem(anchorNode, nodes)) {\n      listNodes.add($getTopListNode(anchorNode));\n    } else {\n      for (let i = 0; i < nodes.length; i++) {\n        const node = nodes[i];\n        if ($isLeafNode(node)) {\n          const listItemNode = $getNearestNodeOfType(node, ListItemNode);\n          if (listItemNode != null) {\n            listNodes.add($getTopListNode(listItemNode));\n          }\n        }\n      }\n    }\n    for (const listNode of listNodes) {\n      let insertionPoint = listNode;\n      const listItems = $getAllListItems(listNode);\n      for (const listItemNode of listItems) {\n        const paragraph = $createParagraphNode().setTextStyle(selection.style).setTextFormat(selection.format);\n        append(paragraph, listItemNode.getChildren());\n        insertionPoint.insertAfter(paragraph);\n        insertionPoint = paragraph;\n\n        // When the anchor and focus fall on the textNode\n        // we don't have to change the selection because the textNode will be appended to\n        // the newly generated paragraph.\n        // When selection is in empty nested list item, selection is actually on the listItemNode.\n        // When the corresponding listItemNode is deleted and replaced by the newly generated paragraph\n        // we should manually set the selection's focus and anchor to the newly generated paragraph.\n        if (listItemNode.__key === selection.anchor.key) {\n          $setPointFromCaret(selection.anchor, $normalizeCaret($getChildCaret(paragraph, 'next')));\n        }\n        if (listItemNode.__key === selection.focus.key) {\n          $setPointFromCaret(selection.focus, $normalizeCaret($getChildCaret(paragraph, 'next')));\n        }\n        listItemNode.remove();\n      }\n      listNode.remove();\n    }\n  }\n}\n\n/**\n * Takes the value of a child ListItemNode and makes it the value the ListItemNode\n * should be if it isn't already. Also ensures that checked is undefined if the\n * parent does not have a list type of 'check'.\n * @param list - The list whose children are updated.\n */\nfunction updateChildrenListItemValue(list) {\n  const isNotChecklist = list.getListType() !== 'check';\n  let value = list.getStart();\n  for (const child of list.getChildren()) {\n    if ($isListItemNode(child)) {\n      if (child.getValue() !== value) {\n        child.setValue(value);\n      }\n      if (isNotChecklist && child.getLatest().__checked != null) {\n        child.setChecked(undefined);\n      }\n      if (!$isListNode(child.getFirstChild())) {\n        value++;\n      }\n    }\n  }\n}\n\n/**\n * Merge the next sibling list if same type.\n * <ul> will merge with <ul>, but NOT <ul> with <ol>.\n * @param list - The list whose next sibling should be potentially merged\n */\nfunction mergeNextSiblingListIfSameType(list) {\n  const nextSibling = list.getNextSibling();\n  if ($isListNode(nextSibling) && list.getListType() === nextSibling.getListType()) {\n    mergeLists(list, nextSibling);\n  }\n}\n\n/**\n * Adds an empty ListNode/ListItemNode chain at listItemNode, so as to\n * create an indent effect. Won't indent ListItemNodes that have a ListNode as\n * a child, but does merge sibling ListItemNodes if one has a nested ListNode.\n * @param listItemNode - The ListItemNode to be indented.\n */\nfunction $handleIndent(listItemNode) {\n  // go through each node and decide where to move it.\n  const removed = new Set();\n  if (isNestedListNode(listItemNode) || removed.has(listItemNode.getKey())) {\n    return;\n  }\n  const parent = listItemNode.getParent();\n\n  // We can cast both of the below `isNestedListNode` only returns a boolean type instead of a user-defined type guards\n  const nextSibling = listItemNode.getNextSibling();\n  const previousSibling = listItemNode.getPreviousSibling();\n  // if there are nested lists on either side, merge them all together.\n\n  if (isNestedListNode(nextSibling) && isNestedListNode(previousSibling)) {\n    const innerList = previousSibling.getFirstChild();\n    if ($isListNode(innerList)) {\n      innerList.append(listItemNode);\n      const nextInnerList = nextSibling.getFirstChild();\n      if ($isListNode(nextInnerList)) {\n        const children = nextInnerList.getChildren();\n        append(innerList, children);\n        nextSibling.remove();\n        removed.add(nextSibling.getKey());\n      }\n    }\n  } else if (isNestedListNode(nextSibling)) {\n    // if the ListItemNode is next to a nested ListNode, merge them\n    const innerList = nextSibling.getFirstChild();\n    if ($isListNode(innerList)) {\n      const firstChild = innerList.getFirstChild();\n      if (firstChild !== null) {\n        firstChild.insertBefore(listItemNode);\n      }\n    }\n  } else if (isNestedListNode(previousSibling)) {\n    const innerList = previousSibling.getFirstChild();\n    if ($isListNode(innerList)) {\n      innerList.append(listItemNode);\n    }\n  } else {\n    // otherwise, we need to create a new nested ListNode\n\n    if ($isListNode(parent)) {\n      const newListItem = $createListItemNode().setTextFormat(listItemNode.getTextFormat()).setTextStyle(listItemNode.getTextStyle());\n      const newList = $createListNode(parent.getListType()).setTextFormat(parent.getTextFormat()).setTextStyle(parent.getTextStyle());\n      newListItem.append(newList);\n      newList.append(listItemNode);\n      if (previousSibling) {\n        previousSibling.insertAfter(newListItem);\n      } else if (nextSibling) {\n        nextSibling.insertBefore(newListItem);\n      } else {\n        parent.append(newListItem);\n      }\n    }\n  }\n}\n\n/**\n * Removes an indent by removing an empty ListNode/ListItemNode chain. An indented ListItemNode\n * has a great grandparent node of type ListNode, which is where the ListItemNode will reside\n * within as a child.\n * @param listItemNode - The ListItemNode to remove the indent (outdent).\n */\nfunction $handleOutdent(listItemNode) {\n  // go through each node and decide where to move it.\n\n  if (isNestedListNode(listItemNode)) {\n    return;\n  }\n  const parentList = listItemNode.getParent();\n  const grandparentListItem = parentList ? parentList.getParent() : undefined;\n  const greatGrandparentList = grandparentListItem ? grandparentListItem.getParent() : undefined;\n  // If it doesn't have these ancestors, it's not indented.\n\n  if ($isListNode(greatGrandparentList) && $isListItemNode(grandparentListItem) && $isListNode(parentList)) {\n    // if it's the first child in it's parent list, insert it into the\n    // great grandparent list before the grandparent\n    const firstChild = parentList ? parentList.getFirstChild() : undefined;\n    const lastChild = parentList ? parentList.getLastChild() : undefined;\n    if (listItemNode.is(firstChild)) {\n      grandparentListItem.insertBefore(listItemNode);\n      if (parentList.isEmpty()) {\n        grandparentListItem.remove();\n      }\n      // if it's the last child in it's parent list, insert it into the\n      // great grandparent list after the grandparent.\n    } else if (listItemNode.is(lastChild)) {\n      grandparentListItem.insertAfter(listItemNode);\n      if (parentList.isEmpty()) {\n        grandparentListItem.remove();\n      }\n    } else {\n      // otherwise, we need to split the siblings into two new nested lists\n      const listType = parentList.getListType();\n      const previousSiblingsListItem = $createListItemNode();\n      const previousSiblingsList = $createListNode(listType);\n      previousSiblingsListItem.append(previousSiblingsList);\n      listItemNode.getPreviousSiblings().forEach(sibling => previousSiblingsList.append(sibling));\n      const nextSiblingsListItem = $createListItemNode();\n      const nextSiblingsList = $createListNode(listType);\n      nextSiblingsListItem.append(nextSiblingsList);\n      append(nextSiblingsList, listItemNode.getNextSiblings());\n      // put the sibling nested lists on either side of the grandparent list item in the great grandparent.\n      grandparentListItem.insertBefore(previousSiblingsListItem);\n      grandparentListItem.insertAfter(nextSiblingsListItem);\n      // replace the grandparent list item (now between the siblings) with the outdented list item.\n      grandparentListItem.replace(listItemNode);\n    }\n  }\n}\n\n/**\n * Attempts to insert a ParagraphNode at selection and selects the new node. The selection must contain a ListItemNode\n * or a node that does not already contain text. If its grandparent is the root/shadow root, it will get the ListNode\n * (which should be the parent node) and insert the ParagraphNode as a sibling to the ListNode. If the ListNode is\n * nested in a ListItemNode instead, it will add the ParagraphNode after the grandparent ListItemNode.\n * Throws an invariant if the selection is not a child of a ListNode.\n * @returns true if a ParagraphNode was inserted successfully, false if there is no selection\n * or the selection does not contain a ListItemNode or the node already holds text.\n */\nfunction $handleListInsertParagraph() {\n  const selection = $getSelection();\n  if (!$isRangeSelection(selection) || !selection.isCollapsed()) {\n    return false;\n  }\n  // Only run this code on empty list items\n  const anchor = selection.anchor.getNode();\n  if (!$isListItemNode(anchor) || anchor.getChildrenSize() !== 0) {\n    return false;\n  }\n  const topListNode = $getTopListNode(anchor);\n  const parent = anchor.getParent();\n  if (!$isListNode(parent)) {\n    formatDevErrorMessage(`A ListItemNode must have a ListNode for a parent.`);\n  }\n  const grandparent = parent.getParent();\n  let replacementNode;\n  if ($isRootOrShadowRoot(grandparent)) {\n    replacementNode = $createParagraphNode();\n    topListNode.insertAfter(replacementNode);\n  } else if ($isListItemNode(grandparent)) {\n    replacementNode = $createListItemNode();\n    grandparent.insertAfter(replacementNode);\n  } else {\n    return false;\n  }\n  replacementNode.setTextStyle(selection.style).setTextFormat(selection.format).select();\n  const nextSiblings = anchor.getNextSiblings();\n  if (nextSiblings.length > 0) {\n    const newList = $createListNode(parent.getListType());\n    if ($isListItemNode(replacementNode)) {\n      const newListItem = $createListItemNode();\n      newListItem.append(newList);\n      replacementNode.insertAfter(newListItem);\n    } else {\n      replacementNode.insertAfter(newList);\n    }\n    newList.append(...nextSiblings);\n  }\n\n  // Don't leave hanging nested empty lists\n  $removeHighestEmptyListParent(anchor);\n  return true;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction normalizeClassNames(...classNames) {\n  const rval = [];\n  for (const className of classNames) {\n    if (className && typeof className === 'string') {\n      for (const [s] of className.matchAll(/\\S+/g)) {\n        rval.push(s);\n      }\n    }\n  }\n  return rval;\n}\n\nfunction applyMarkerStyles(dom, node, prevNode) {\n  const styles = getStyleObjectFromCSS(node.__textStyle);\n  for (const k in styles) {\n    dom.style.setProperty(`--listitem-marker-${k}`, styles[k]);\n  }\n  if (prevNode) {\n    for (const k in getStyleObjectFromCSS(prevNode.__textStyle)) {\n      if (!(k in styles)) {\n        dom.style.removeProperty(`--listitem-marker-${k}`);\n      }\n    }\n  }\n}\n\n/** @noInheritDoc */\nclass ListItemNode extends ElementNode {\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n  $config() {\n    return this.config('listitem', {\n      $transform: node => {\n        if (node.__checked == null) {\n          return;\n        }\n        const parent = node.getParent();\n        if ($isListNode(parent)) {\n          if (parent.getListType() !== 'check' && node.getChecked() != null) {\n            node.setChecked(undefined);\n          }\n        }\n      },\n      extends: ElementNode,\n      importDOM: buildImportMap({\n        li: () => ({\n          conversion: $convertListItemElement,\n          priority: 0\n        })\n      })\n    });\n  }\n  constructor(value = 1, checked = undefined, key) {\n    super(key);\n    this.__value = value === undefined ? 1 : value;\n    this.__checked = checked;\n  }\n  afterCloneFrom(prevNode) {\n    super.afterCloneFrom(prevNode);\n    this.__value = prevNode.__value;\n    this.__checked = prevNode.__checked;\n  }\n  createDOM(config) {\n    const element = document.createElement('li');\n    this.updateListItemDOM(null, element, config);\n    return element;\n  }\n  updateListItemDOM(prevNode, dom, config) {\n    const parent = this.getParent();\n    if ($isListNode(parent) && parent.getListType() === 'check') {\n      updateListItemChecked(dom, this, prevNode);\n    }\n    dom.value = this.__value;\n    $setListItemThemeClassNames(dom, config.theme, this);\n    const prevStyle = prevNode ? prevNode.__style : '';\n    const nextStyle = this.__style;\n    if (prevStyle !== nextStyle) {\n      if (nextStyle === '') {\n        dom.removeAttribute('style');\n      } else {\n        dom.style.cssText = nextStyle;\n      }\n    }\n    applyMarkerStyles(dom, this, prevNode);\n  }\n  updateDOM(prevNode, dom, config) {\n    // @ts-expect-error - this is always HTMLListItemElement\n    const element = dom;\n    this.updateListItemDOM(prevNode, element, config);\n    return false;\n  }\n  updateFromJSON(serializedNode) {\n    return super.updateFromJSON(serializedNode).setValue(serializedNode.value).setChecked(serializedNode.checked);\n  }\n  exportDOM(editor) {\n    const element = this.createDOM(editor._config);\n    const formatType = this.getFormatType();\n    if (formatType) {\n      element.style.textAlign = formatType;\n    }\n    const direction = this.getDirection();\n    if (direction) {\n      element.dir = direction;\n    }\n    return {\n      element\n    };\n  }\n  exportJSON() {\n    return {\n      ...super.exportJSON(),\n      checked: this.getChecked(),\n      value: this.getValue()\n    };\n  }\n  append(...nodes) {\n    for (let i = 0; i < nodes.length; i++) {\n      const node = nodes[i];\n      if ($isElementNode(node) && this.canMergeWith(node)) {\n        const children = node.getChildren();\n        this.append(...children);\n        node.remove();\n      } else {\n        super.append(node);\n      }\n    }\n    return this;\n  }\n  replace(replaceWithNode, includeChildren) {\n    if ($isListItemNode(replaceWithNode)) {\n      return super.replace(replaceWithNode);\n    }\n    this.setIndent(0);\n    const list = this.getParentOrThrow();\n    if (!$isListNode(list)) {\n      return replaceWithNode;\n    }\n    if (list.__first === this.getKey()) {\n      list.insertBefore(replaceWithNode);\n    } else if (list.__last === this.getKey()) {\n      list.insertAfter(replaceWithNode);\n    } else {\n      // Split the list\n      const newList = $createListNode(list.getListType());\n      let nextSibling = this.getNextSibling();\n      while (nextSibling) {\n        const nodeToAppend = nextSibling;\n        nextSibling = nextSibling.getNextSibling();\n        newList.append(nodeToAppend);\n      }\n      list.insertAfter(replaceWithNode);\n      replaceWithNode.insertAfter(newList);\n    }\n    if (includeChildren) {\n      if (!$isElementNode(replaceWithNode)) {\n        formatDevErrorMessage(`includeChildren should only be true for ElementNodes`);\n      }\n      this.getChildren().forEach(child => {\n        replaceWithNode.append(child);\n      });\n    }\n    this.remove();\n    if (list.getChildrenSize() === 0) {\n      list.remove();\n    }\n    return replaceWithNode;\n  }\n  insertAfter(node, restoreSelection = true) {\n    const listNode = this.getParentOrThrow();\n    if (!$isListNode(listNode)) {\n      {\n        formatDevErrorMessage(`insertAfter: list node is not parent of list item node`);\n      }\n    }\n    if ($isListItemNode(node)) {\n      return super.insertAfter(node, restoreSelection);\n    }\n    const siblings = this.getNextSiblings();\n\n    // Split the lists and insert the node in between them\n    listNode.insertAfter(node, restoreSelection);\n    if (siblings.length !== 0) {\n      const newListNode = $createListNode(listNode.getListType());\n      siblings.forEach(sibling => newListNode.append(sibling));\n      node.insertAfter(newListNode, restoreSelection);\n    }\n    return node;\n  }\n  remove(preserveEmptyParent) {\n    const prevSibling = this.getPreviousSibling();\n    const nextSibling = this.getNextSibling();\n    super.remove(preserveEmptyParent);\n    if (prevSibling && nextSibling && isNestedListNode(prevSibling) && isNestedListNode(nextSibling)) {\n      mergeLists(prevSibling.getFirstChild(), nextSibling.getFirstChild());\n      nextSibling.remove();\n    }\n  }\n  insertNewAfter(_, restoreSelection = true) {\n    const newElement = $createListItemNode().updateFromJSON(this.exportJSON()).setChecked(this.getChecked() ? false : undefined);\n    this.insertAfter(newElement, restoreSelection);\n    return newElement;\n  }\n  collapseAtStart(selection) {\n    const paragraph = $createParagraphNode();\n    const children = this.getChildren();\n    children.forEach(child => paragraph.append(child));\n    const listNode = this.getParentOrThrow();\n    const listNodeParent = listNode.getParentOrThrow();\n    const isIndented = $isListItemNode(listNodeParent);\n    if (listNode.getChildrenSize() === 1) {\n      if (isIndented) {\n        // if the list node is nested, we just want to remove it,\n        // effectively unindenting it.\n        listNode.remove();\n        listNodeParent.select();\n      } else {\n        listNode.insertBefore(paragraph);\n        listNode.remove();\n        // If we have selection on the list item, we'll need to move it\n        // to the paragraph\n        const anchor = selection.anchor;\n        const focus = selection.focus;\n        const key = paragraph.getKey();\n        if (anchor.type === 'element' && anchor.getNode().is(this)) {\n          anchor.set(key, anchor.offset, 'element');\n        }\n        if (focus.type === 'element' && focus.getNode().is(this)) {\n          focus.set(key, focus.offset, 'element');\n        }\n      }\n    } else {\n      listNode.insertBefore(paragraph);\n      this.remove();\n    }\n    return true;\n  }\n  getValue() {\n    const self = this.getLatest();\n    return self.__value;\n  }\n  setValue(value) {\n    const self = this.getWritable();\n    self.__value = value;\n    return self;\n  }\n  getChecked() {\n    const self = this.getLatest();\n    let listType;\n    const parent = this.getParent();\n    if ($isListNode(parent)) {\n      listType = parent.getListType();\n    }\n    return listType === 'check' ? Boolean(self.__checked) : undefined;\n  }\n  setChecked(checked) {\n    const self = this.getWritable();\n    self.__checked = checked;\n    return self;\n  }\n  toggleChecked() {\n    const self = this.getWritable();\n    return self.setChecked(!self.__checked);\n  }\n  getIndent() {\n    // If we don't have a parent, we are likely serializing\n    const parent = this.getParent();\n    if (parent === null || !this.isAttached()) {\n      return this.getLatest().__indent;\n    }\n    // ListItemNode should always have a ListNode for a parent.\n    let listNodeParent = parent.getParentOrThrow();\n    let indentLevel = 0;\n    while ($isListItemNode(listNodeParent)) {\n      listNodeParent = listNodeParent.getParentOrThrow().getParentOrThrow();\n      indentLevel++;\n    }\n    return indentLevel;\n  }\n  setIndent(indent) {\n    if (!(typeof indent === 'number')) {\n      formatDevErrorMessage(`Invalid indent value.`);\n    }\n    indent = Math.floor(indent);\n    if (!(indent >= 0)) {\n      formatDevErrorMessage(`Indent value must be non-negative.`);\n    }\n    let currentIndent = this.getIndent();\n    while (currentIndent !== indent) {\n      if (currentIndent < indent) {\n        $handleIndent(this);\n        currentIndent++;\n      } else {\n        $handleOutdent(this);\n        currentIndent--;\n      }\n    }\n    return this;\n  }\n\n  /** @deprecated @internal */\n  canInsertAfter(node) {\n    return $isListItemNode(node);\n  }\n\n  /** @deprecated @internal */\n  canReplaceWith(replacement) {\n    return $isListItemNode(replacement);\n  }\n  canMergeWith(node) {\n    return $isListItemNode(node) || $isParagraphNode(node);\n  }\n  extractWithChild(child, selection) {\n    if (!$isRangeSelection(selection)) {\n      return false;\n    }\n    const anchorNode = selection.anchor.getNode();\n    const focusNode = selection.focus.getNode();\n    return this.isParentOf(anchorNode) && this.isParentOf(focusNode) && this.getTextContent().length === selection.getTextContent().length;\n  }\n  isParentRequired() {\n    return true;\n  }\n  createParentElementNode() {\n    return $createListNode('bullet');\n  }\n  canMergeWhenEmpty() {\n    return true;\n  }\n}\nfunction $setListItemThemeClassNames(dom, editorThemeClasses, node) {\n  const classesToAdd = [];\n  const classesToRemove = [];\n  const listTheme = editorThemeClasses.list;\n  const listItemClassName = listTheme ? listTheme.listitem : undefined;\n  let nestedListItemClassName;\n  if (listTheme && listTheme.nested) {\n    nestedListItemClassName = listTheme.nested.listitem;\n  }\n  if (listItemClassName !== undefined) {\n    classesToAdd.push(...normalizeClassNames(listItemClassName));\n  }\n  if (listTheme) {\n    const parentNode = node.getParent();\n    const isCheckList = $isListNode(parentNode) && parentNode.getListType() === 'check';\n    const checked = node.getChecked();\n    if (!isCheckList || checked) {\n      classesToRemove.push(listTheme.listitemUnchecked);\n    }\n    if (!isCheckList || !checked) {\n      classesToRemove.push(listTheme.listitemChecked);\n    }\n    if (isCheckList) {\n      classesToAdd.push(checked ? listTheme.listitemChecked : listTheme.listitemUnchecked);\n    }\n  }\n  if (nestedListItemClassName !== undefined) {\n    const nestedListItemClasses = normalizeClassNames(nestedListItemClassName);\n    if (node.getChildren().some(child => $isListNode(child))) {\n      classesToAdd.push(...nestedListItemClasses);\n    } else {\n      classesToRemove.push(...nestedListItemClasses);\n    }\n  }\n  if (classesToRemove.length > 0) {\n    removeClassNamesFromElement(dom, ...classesToRemove);\n  }\n  if (classesToAdd.length > 0) {\n    addClassNamesToElement(dom, ...classesToAdd);\n  }\n}\nfunction updateListItemChecked(dom, listItemNode, prevListItemNode, listNode) {\n  // Only add attributes for leaf list items\n  if ($isListNode(listItemNode.getFirstChild())) {\n    dom.removeAttribute('role');\n    dom.removeAttribute('tabIndex');\n    dom.removeAttribute('aria-checked');\n  } else {\n    dom.setAttribute('role', 'checkbox');\n    dom.setAttribute('tabIndex', '-1');\n    if (!prevListItemNode || listItemNode.__checked !== prevListItemNode.__checked) {\n      dom.setAttribute('aria-checked', listItemNode.getChecked() ? 'true' : 'false');\n    }\n  }\n}\nfunction $convertListItemElement(domNode) {\n  const isGitHubCheckList = domNode.classList.contains('task-list-item');\n  if (isGitHubCheckList) {\n    for (const child of domNode.children) {\n      if (child.tagName === 'INPUT') {\n        return $convertCheckboxInput(child);\n      }\n    }\n  }\n  const ariaCheckedAttr = domNode.getAttribute('aria-checked');\n  const checked = ariaCheckedAttr === 'true' ? true : ariaCheckedAttr === 'false' ? false : undefined;\n  return {\n    node: $createListItemNode(checked)\n  };\n}\nfunction $convertCheckboxInput(domNode) {\n  const isCheckboxInput = domNode.getAttribute('type') === 'checkbox';\n  if (!isCheckboxInput) {\n    return {\n      node: null\n    };\n  }\n  const checked = domNode.hasAttribute('checked');\n  return {\n    node: $createListItemNode(checked)\n  };\n}\n\n/**\n * Creates a new List Item node, passing true/false will convert it to a checkbox input.\n * @param checked - Is the List Item a checkbox and, if so, is it checked? undefined/null: not a checkbox, true/false is a checkbox and checked/unchecked, respectively.\n * @returns The new List Item.\n */\nfunction $createListItemNode(checked) {\n  return $applyNodeReplacement(new ListItemNode(undefined, checked));\n}\n\n/**\n * Checks to see if the node is a ListItemNode.\n * @param node - The node to be checked.\n * @returns true if the node is a ListItemNode, false otherwise.\n */\nfunction $isListItemNode(node) {\n  return node instanceof ListItemNode;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/** @noInheritDoc */\nclass ListNode extends ElementNode {\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n  $config() {\n    return this.config('list', {\n      $transform: node => {\n        mergeNextSiblingListIfSameType(node);\n        updateChildrenListItemValue(node);\n      },\n      extends: ElementNode,\n      importDOM: buildImportMap({\n        ol: () => ({\n          conversion: $convertListNode,\n          priority: 0\n        }),\n        ul: () => ({\n          conversion: $convertListNode,\n          priority: 0\n        })\n      })\n    });\n  }\n  constructor(listType = 'number', start = 1, key) {\n    super(key);\n    const _listType = TAG_TO_LIST_TYPE[listType] || listType;\n    this.__listType = _listType;\n    this.__tag = _listType === 'number' ? 'ol' : 'ul';\n    this.__start = start;\n  }\n  afterCloneFrom(prevNode) {\n    super.afterCloneFrom(prevNode);\n    this.__listType = prevNode.__listType;\n    this.__tag = prevNode.__tag;\n    this.__start = prevNode.__start;\n  }\n  getTag() {\n    return this.getLatest().__tag;\n  }\n  setListType(type) {\n    const writable = this.getWritable();\n    writable.__listType = type;\n    writable.__tag = type === 'number' ? 'ol' : 'ul';\n    return writable;\n  }\n  getListType() {\n    return this.getLatest().__listType;\n  }\n  getStart() {\n    return this.getLatest().__start;\n  }\n  setStart(start) {\n    const self = this.getWritable();\n    self.__start = start;\n    return self;\n  }\n\n  // View\n\n  createDOM(config, _editor) {\n    const tag = this.__tag;\n    const dom = document.createElement(tag);\n    if (this.__start !== 1) {\n      dom.setAttribute('start', String(this.__start));\n    }\n    // @ts-expect-error Internal field.\n    dom.__lexicalListType = this.__listType;\n    $setListThemeClassNames(dom, config.theme, this);\n    return dom;\n  }\n  updateDOM(prevNode, dom, config) {\n    if (prevNode.__tag !== this.__tag) {\n      return true;\n    }\n    $setListThemeClassNames(dom, config.theme, this);\n    return false;\n  }\n  updateFromJSON(serializedNode) {\n    return super.updateFromJSON(serializedNode).setListType(serializedNode.listType).setStart(serializedNode.start);\n  }\n  exportDOM(editor) {\n    const element = this.createDOM(editor._config, editor);\n    if (isHTMLElement(element)) {\n      if (this.__start !== 1) {\n        element.setAttribute('start', String(this.__start));\n      }\n      if (this.__listType === 'check') {\n        element.setAttribute('__lexicalListType', 'check');\n      }\n    }\n    return {\n      element\n    };\n  }\n  exportJSON() {\n    return {\n      ...super.exportJSON(),\n      listType: this.getListType(),\n      start: this.getStart(),\n      tag: this.getTag()\n    };\n  }\n  canBeEmpty() {\n    return false;\n  }\n  canIndent() {\n    return false;\n  }\n  splice(start, deleteCount, nodesToInsert) {\n    let listItemNodesToInsert = nodesToInsert;\n    for (let i = 0; i < nodesToInsert.length; i++) {\n      const node = nodesToInsert[i];\n      if (!$isListItemNode(node)) {\n        if (listItemNodesToInsert === nodesToInsert) {\n          listItemNodesToInsert = [...nodesToInsert];\n        }\n        listItemNodesToInsert[i] = $createListItemNode().append($isElementNode(node) && !($isListNode(node) || node.isInline()) ? $createTextNode(node.getTextContent()) : node);\n      }\n    }\n    return super.splice(start, deleteCount, listItemNodesToInsert);\n  }\n  extractWithChild(child) {\n    return $isListItemNode(child);\n  }\n}\nfunction $setListThemeClassNames(dom, editorThemeClasses, node) {\n  const classesToAdd = [];\n  const classesToRemove = [];\n  const listTheme = editorThemeClasses.list;\n  if (listTheme !== undefined) {\n    const listLevelsClassNames = listTheme[`${node.__tag}Depth`] || [];\n    const listDepth = $getListDepth(node) - 1;\n    const normalizedListDepth = listDepth % listLevelsClassNames.length;\n    const listLevelClassName = listLevelsClassNames[normalizedListDepth];\n    const listClassName = listTheme[node.__tag];\n    let nestedListClassName;\n    const nestedListTheme = listTheme.nested;\n    const checklistClassName = listTheme.checklist;\n    if (nestedListTheme !== undefined && nestedListTheme.list) {\n      nestedListClassName = nestedListTheme.list;\n    }\n    if (listClassName !== undefined) {\n      classesToAdd.push(listClassName);\n    }\n    if (checklistClassName !== undefined && node.__listType === 'check') {\n      classesToAdd.push(checklistClassName);\n    }\n    if (listLevelClassName !== undefined) {\n      classesToAdd.push(...normalizeClassNames(listLevelClassName));\n      for (let i = 0; i < listLevelsClassNames.length; i++) {\n        if (i !== normalizedListDepth) {\n          classesToRemove.push(node.__tag + i);\n        }\n      }\n    }\n    if (nestedListClassName !== undefined) {\n      const nestedListItemClasses = normalizeClassNames(nestedListClassName);\n      if (listDepth > 1) {\n        classesToAdd.push(...nestedListItemClasses);\n      } else {\n        classesToRemove.push(...nestedListItemClasses);\n      }\n    }\n  }\n  if (classesToRemove.length > 0) {\n    removeClassNamesFromElement(dom, ...classesToRemove);\n  }\n  if (classesToAdd.length > 0) {\n    addClassNamesToElement(dom, ...classesToAdd);\n  }\n}\n\n/*\n * This function normalizes the children of a ListNode after the conversion from HTML,\n * ensuring that they are all ListItemNodes and contain either a single nested ListNode\n * or some other inline content.\n */\nfunction $normalizeChildren(nodes) {\n  const normalizedListItems = [];\n  for (let i = 0; i < nodes.length; i++) {\n    const node = nodes[i];\n    if ($isListItemNode(node)) {\n      normalizedListItems.push(node);\n      const children = node.getChildren();\n      if (children.length > 1) {\n        children.forEach(child => {\n          if ($isListNode(child)) {\n            normalizedListItems.push($wrapInListItem(child));\n          }\n        });\n      }\n    } else {\n      normalizedListItems.push($wrapInListItem(node));\n    }\n  }\n  return normalizedListItems;\n}\nfunction isDomChecklist(domNode) {\n  if (domNode.getAttribute('__lexicallisttype') === 'check' ||\n  // is github checklist\n  domNode.classList.contains('contains-task-list')) {\n    return true;\n  }\n  // if children are checklist items, the node is a checklist ul. Applicable for googledoc checklist pasting.\n  for (const child of domNode.childNodes) {\n    if (isHTMLElement(child) && child.hasAttribute('aria-checked')) {\n      return true;\n    }\n  }\n  return false;\n}\nfunction $convertListNode(domNode) {\n  const nodeName = domNode.nodeName.toLowerCase();\n  let node = null;\n  if (nodeName === 'ol') {\n    // @ts-ignore\n    const start = domNode.start;\n    node = $createListNode('number', start);\n  } else if (nodeName === 'ul') {\n    if (isDomChecklist(domNode)) {\n      node = $createListNode('check');\n    } else {\n      node = $createListNode('bullet');\n    }\n  }\n  return {\n    after: $normalizeChildren,\n    node\n  };\n}\nconst TAG_TO_LIST_TYPE = {\n  ol: 'number',\n  ul: 'bullet'\n};\n\n/**\n * Creates a ListNode of listType.\n * @param listType - The type of list to be created. Can be 'number', 'bullet', or 'check'.\n * @param start - Where an ordered list starts its count, start = 1 if left undefined.\n * @returns The new ListNode\n */\nfunction $createListNode(listType = 'number', start = 1) {\n  return $applyNodeReplacement(new ListNode(listType, start));\n}\n\n/**\n * Checks to see if the node is a ListNode.\n * @param node - The node to be checked.\n * @returns true if the node is a ListNode, false otherwise.\n */\nfunction $isListNode(node) {\n  return node instanceof ListNode;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst INSERT_CHECK_LIST_COMMAND = createCommand('INSERT_CHECK_LIST_COMMAND');\nfunction registerCheckList(editor) {\n  return mergeRegister(editor.registerCommand(INSERT_CHECK_LIST_COMMAND, () => {\n    $insertList('check');\n    return true;\n  }, COMMAND_PRIORITY_LOW), editor.registerCommand(KEY_ARROW_DOWN_COMMAND, event => {\n    return handleArrowUpOrDown(event, editor, false);\n  }, COMMAND_PRIORITY_LOW), editor.registerCommand(KEY_ARROW_UP_COMMAND, event => {\n    return handleArrowUpOrDown(event, editor, true);\n  }, COMMAND_PRIORITY_LOW), editor.registerCommand(KEY_ESCAPE_COMMAND, () => {\n    const activeItem = getActiveCheckListItem();\n    if (activeItem != null) {\n      const rootElement = editor.getRootElement();\n      if (rootElement != null) {\n        rootElement.focus();\n      }\n      return true;\n    }\n    return false;\n  }, COMMAND_PRIORITY_LOW), editor.registerCommand(KEY_SPACE_COMMAND, event => {\n    const activeItem = getActiveCheckListItem();\n    if (activeItem != null && editor.isEditable()) {\n      editor.update(() => {\n        const listItemNode = $getNearestNodeFromDOMNode(activeItem);\n        if ($isListItemNode(listItemNode)) {\n          event.preventDefault();\n          listItemNode.toggleChecked();\n        }\n      });\n      return true;\n    }\n    return false;\n  }, COMMAND_PRIORITY_LOW), editor.registerCommand(KEY_ARROW_LEFT_COMMAND, event => {\n    return editor.getEditorState().read(() => {\n      const selection = $getSelection();\n      if ($isRangeSelection(selection) && selection.isCollapsed()) {\n        const {\n          anchor\n        } = selection;\n        const isElement = anchor.type === 'element';\n        if (isElement || anchor.offset === 0) {\n          const anchorNode = anchor.getNode();\n          const elementNode = $findMatchingParent(anchorNode, node => $isElementNode(node) && !node.isInline());\n          if ($isListItemNode(elementNode)) {\n            const parent = elementNode.getParent();\n            if ($isListNode(parent) && parent.getListType() === 'check' && (isElement || elementNode.getFirstDescendant() === anchorNode)) {\n              const domNode = editor.getElementByKey(elementNode.__key);\n              if (domNode != null && document.activeElement !== domNode) {\n                domNode.focus();\n                event.preventDefault();\n                return true;\n              }\n            }\n          }\n        }\n      }\n      return false;\n    });\n  }, COMMAND_PRIORITY_LOW), editor.registerRootListener((rootElement, prevElement) => {\n    if (rootElement !== null) {\n      rootElement.addEventListener('click', handleClick);\n      rootElement.addEventListener('pointerdown', handlePointerDown);\n    }\n    if (prevElement !== null) {\n      prevElement.removeEventListener('click', handleClick);\n      prevElement.removeEventListener('pointerdown', handlePointerDown);\n    }\n  }));\n}\nfunction handleCheckItemEvent(event, callback) {\n  const target = event.target;\n  if (!isHTMLElement(target)) {\n    return;\n  }\n\n  // Ignore clicks on LI that have nested lists\n  const firstChild = target.firstChild;\n  if (isHTMLElement(firstChild) && (firstChild.tagName === 'UL' || firstChild.tagName === 'OL')) {\n    return;\n  }\n  const parentNode = target.parentNode;\n\n  // @ts-ignore internal field\n  if (!parentNode || parentNode.__lexicalListType !== 'check') {\n    return;\n  }\n  const rect = target.getBoundingClientRect();\n  const zoom = calculateZoomLevel(target);\n  const clientX = event.clientX / zoom;\n\n  // Use getComputedStyle if available, otherwise fallback to 0px width\n  const beforeStyles = window.getComputedStyle ? window.getComputedStyle(target, '::before') : {\n    width: '0px'\n  };\n  const beforeWidthInPixels = parseFloat(beforeStyles.width);\n\n  // Make click area slightly larger for touch devices to improve accessibility\n  const isTouchEvent = event.pointerType === 'touch';\n  const clickAreaPadding = isTouchEvent ? 32 : 0; // Add 32px padding for touch events\n\n  if (target.dir === 'rtl' ? clientX < rect.right + clickAreaPadding && clientX > rect.right - beforeWidthInPixels - clickAreaPadding : clientX > rect.left - clickAreaPadding && clientX < rect.left + beforeWidthInPixels + clickAreaPadding) {\n    callback();\n  }\n}\nfunction handleClick(event) {\n  handleCheckItemEvent(event, () => {\n    if (isHTMLElement(event.target)) {\n      const domNode = event.target;\n      const editor = getNearestEditorFromDOMNode(domNode);\n      if (editor != null && editor.isEditable()) {\n        editor.update(() => {\n          const node = $getNearestNodeFromDOMNode(domNode);\n          if ($isListItemNode(node)) {\n            domNode.focus();\n            node.toggleChecked();\n          }\n        });\n      }\n    }\n  });\n}\nfunction handlePointerDown(event) {\n  handleCheckItemEvent(event, () => {\n    // Prevents caret moving when clicking on check mark\n    event.preventDefault();\n  });\n}\nfunction getActiveCheckListItem() {\n  const activeElement = document.activeElement;\n  return isHTMLElement(activeElement) && activeElement.tagName === 'LI' && activeElement.parentNode != null &&\n  // @ts-ignore internal field\n  activeElement.parentNode.__lexicalListType === 'check' ? activeElement : null;\n}\nfunction findCheckListItemSibling(node, backward) {\n  let sibling = backward ? node.getPreviousSibling() : node.getNextSibling();\n  let parent = node;\n\n  // Going up in a tree to get non-null sibling\n  while (sibling == null && $isListItemNode(parent)) {\n    // Get li -> parent ul/ol -> parent li\n    parent = parent.getParentOrThrow().getParent();\n    if (parent != null) {\n      sibling = backward ? parent.getPreviousSibling() : parent.getNextSibling();\n    }\n  }\n\n  // Going down in a tree to get first non-nested list item\n  while ($isListItemNode(sibling)) {\n    const firstChild = backward ? sibling.getLastChild() : sibling.getFirstChild();\n    if (!$isListNode(firstChild)) {\n      return sibling;\n    }\n    sibling = backward ? firstChild.getLastChild() : firstChild.getFirstChild();\n  }\n  return null;\n}\nfunction handleArrowUpOrDown(event, editor, backward) {\n  const activeItem = getActiveCheckListItem();\n  if (activeItem != null) {\n    editor.update(() => {\n      const listItem = $getNearestNodeFromDOMNode(activeItem);\n      if (!$isListItemNode(listItem)) {\n        return;\n      }\n      const nextListItem = findCheckListItemSibling(listItem, backward);\n      if (nextListItem != null) {\n        nextListItem.selectStart();\n        const dom = editor.getElementByKey(nextListItem.__key);\n        if (dom != null) {\n          event.preventDefault();\n          setTimeout(() => {\n            dom.focus();\n          }, 0);\n        }\n      }\n    });\n  }\n  return false;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst UPDATE_LIST_START_COMMAND = createCommand('UPDATE_LIST_START_COMMAND');\nconst INSERT_UNORDERED_LIST_COMMAND = createCommand('INSERT_UNORDERED_LIST_COMMAND');\nconst INSERT_ORDERED_LIST_COMMAND = createCommand('INSERT_ORDERED_LIST_COMMAND');\nconst REMOVE_LIST_COMMAND = createCommand('REMOVE_LIST_COMMAND');\nfunction registerList(editor) {\n  const removeListener = mergeRegister(editor.registerCommand(INSERT_ORDERED_LIST_COMMAND, () => {\n    $insertList('number');\n    return true;\n  }, COMMAND_PRIORITY_LOW), editor.registerCommand(UPDATE_LIST_START_COMMAND, payload => {\n    const {\n      listNodeKey,\n      newStart\n    } = payload;\n    const listNode = $getNodeByKey(listNodeKey);\n    if (!$isListNode(listNode)) {\n      return false;\n    }\n    if (listNode.getListType() === 'number') {\n      listNode.setStart(newStart);\n      updateChildrenListItemValue(listNode);\n    }\n    return true;\n  }, COMMAND_PRIORITY_LOW), editor.registerCommand(INSERT_UNORDERED_LIST_COMMAND, () => {\n    $insertList('bullet');\n    return true;\n  }, COMMAND_PRIORITY_LOW), editor.registerCommand(REMOVE_LIST_COMMAND, () => {\n    $removeList();\n    return true;\n  }, COMMAND_PRIORITY_LOW), editor.registerCommand(INSERT_PARAGRAPH_COMMAND, () => $handleListInsertParagraph(), COMMAND_PRIORITY_LOW), editor.registerNodeTransform(ListItemNode, node => {\n    const firstChild = node.getFirstChild();\n    if (firstChild) {\n      if ($isTextNode(firstChild)) {\n        const style = firstChild.getStyle();\n        const format = firstChild.getFormat();\n        if (node.getTextStyle() !== style) {\n          node.setTextStyle(style);\n        }\n        if (node.getTextFormat() !== format) {\n          node.setTextFormat(format);\n        }\n      }\n    } else {\n      // If it's empty, check the selection\n      const selection = $getSelection();\n      if ($isRangeSelection(selection) && (selection.style !== node.getTextStyle() || selection.format !== node.getTextFormat()) && selection.isCollapsed() && node.is(selection.anchor.getNode())) {\n        node.setTextStyle(selection.style).setTextFormat(selection.format);\n      }\n    }\n  }), editor.registerNodeTransform(TextNode, node => {\n    const listItemParentNode = node.getParent();\n    if ($isListItemNode(listItemParentNode) && node.is(listItemParentNode.getFirstChild())) {\n      const style = node.getStyle();\n      const format = node.getFormat();\n      if (style !== listItemParentNode.getTextStyle() || format !== listItemParentNode.getTextFormat()) {\n        listItemParentNode.setTextStyle(style).setTextFormat(format);\n      }\n    }\n  }));\n  return removeListener;\n}\nfunction registerListStrictIndentTransform(editor) {\n  const $formatListIndentStrict = listItemNode => {\n    const listNode = listItemNode.getParent();\n    if ($isListNode(listItemNode.getFirstChild()) || !$isListNode(listNode)) {\n      return;\n    }\n    const startingListItemNode = $findMatchingParent(listItemNode, node => $isListItemNode(node) && $isListNode(node.getParent()) && $isListItemNode(node.getPreviousSibling()));\n    if (startingListItemNode === null && listItemNode.getIndent() > 0) {\n      listItemNode.setIndent(0);\n    } else if ($isListItemNode(startingListItemNode)) {\n      const prevListItemNode = startingListItemNode.getPreviousSibling();\n      if ($isListItemNode(prevListItemNode)) {\n        const endListItemNode = $findChildrenEndListItemNode(prevListItemNode);\n        const endListNode = endListItemNode.getParent();\n        if ($isListNode(endListNode)) {\n          const prevDepth = $getListDepth(endListNode);\n          const depth = $getListDepth(listNode);\n          if (prevDepth + 1 < depth) {\n            listItemNode.setIndent(prevDepth);\n          }\n        }\n      }\n    }\n  };\n  const $processListWithStrictIndent = listNode => {\n    const queue = [listNode];\n    while (queue.length > 0) {\n      const node = queue.shift();\n      if (!$isListNode(node)) {\n        continue;\n      }\n      for (const child of node.getChildren()) {\n        if ($isListItemNode(child)) {\n          $formatListIndentStrict(child);\n          const firstChild = child.getFirstChild();\n          if ($isListNode(firstChild)) {\n            queue.push(firstChild);\n          }\n        }\n      }\n    }\n  };\n  return editor.registerNodeTransform(ListNode, $processListWithStrictIndent);\n}\nfunction $findChildrenEndListItemNode(listItemNode) {\n  let current = listItemNode;\n  let firstChild = current.getFirstChild();\n  while ($isListNode(firstChild)) {\n    const lastChild = firstChild.getLastChild();\n    if ($isListItemNode(lastChild)) {\n      current = lastChild;\n      firstChild = current.getFirstChild();\n    } else {\n      break;\n    }\n  }\n  return current;\n}\n\n/**\n * @deprecated use {@link $insertList} from an update or command listener.\n *\n * Inserts a new ListNode. If the selection's anchor node is an empty ListItemNode and is a child of\n * the root/shadow root, it will replace the ListItemNode with a ListNode and the old ListItemNode.\n * Otherwise it will replace its parent with a new ListNode and re-insert the ListItemNode and any previous children.\n * If the selection's anchor node is not an empty ListItemNode, it will add a new ListNode or merge an existing ListNode,\n * unless the the node is a leaf node, in which case it will attempt to find a ListNode up the branch and replace it with\n * a new ListNode, or create a new ListNode at the nearest root/shadow root.\n * @param editor - The lexical editor.\n * @param listType - The type of list, \"number\" | \"bullet\" | \"check\".\n */\nfunction insertList(editor, listType) {\n  editor.update(() => $insertList(listType));\n}\n\n/**\n * @deprecated use {@link $removeList} from an update or command listener.\n *\n * Searches for the nearest ancestral ListNode and removes it. If selection is an empty ListItemNode\n * it will remove the whole list, including the ListItemNode. For each ListItemNode in the ListNode,\n * removeList will also generate new ParagraphNodes in the removed ListNode's place. Any child node\n * inside a ListItemNode will be appended to the new ParagraphNodes.\n * @param editor - The lexical editor.\n */\nfunction removeList(editor) {\n  editor.update(() => $removeList());\n}\n\nexport { $createListItemNode, $createListNode, $getListDepth, $handleListInsertParagraph, $insertList, $isListItemNode, $isListNode, $removeList, INSERT_CHECK_LIST_COMMAND, INSERT_ORDERED_LIST_COMMAND, INSERT_UNORDERED_LIST_COMMAND, ListItemNode, ListNode, REMOVE_LIST_COMMAND, UPDATE_LIST_START_COMMAND, insertList, registerCheckList, registerList, registerListStrictIndentTransform, removeList };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}