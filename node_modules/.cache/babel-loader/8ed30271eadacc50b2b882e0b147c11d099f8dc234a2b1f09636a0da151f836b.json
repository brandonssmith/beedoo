{"ast":null,"code":"import React,{useMemo}from'react';import{LexicalComposer}from'@lexical/react/LexicalComposer';import{RichTextPlugin}from'@lexical/react/LexicalRichTextPlugin';import{ContentEditable}from'@lexical/react/LexicalContentEditable';import{HistoryPlugin}from'@lexical/react/LexicalHistoryPlugin';import{$getRoot,$createTextNode}from'lexical';import{jsx as _jsx,Fragment as _Fragment,jsxs as _jsxs}from\"react/jsx-runtime\";const LexicalViewer=_ref=>{let{value,className=''}=_ref;// Only set initialEditorState if value is a valid Lexical state\nconst initialEditorState=useMemo(()=>{if(typeof value==='string'&&value.trim().length>0){let parsed=null;try{parsed=JSON.parse(value);}catch{// not JSON, treat as plain text\n}if(parsed&&typeof parsed==='object'&&parsed.root){// Looks like a Lexical serialized state\nreturn editor=>{editor.setEditorState(editor.parseEditorState(value));};}else{// Fallback: treat as plain text\nreturn editor=>{editor.update(()=>{const root=$getRoot();root.clear();root.append($createTextNode(value));});};}}return undefined;},[value]);const initialConfig={namespace:'BeedooRichTextViewer',theme:{root:'outline-none min-h-[40px] p-0',text:{bold:'font-bold',italic:'italic',underline:'underline'}},onError:error=>{console.error('Lexical error:',error);},editorState:null,editable:false,initialEditorState};return/*#__PURE__*/_jsx(\"div\",{className:className,children:/*#__PURE__*/_jsxs(LexicalComposer,{initialConfig:initialConfig,children:[/*#__PURE__*/_jsx(RichTextPlugin,{contentEditable:/*#__PURE__*/_jsx(ContentEditable,{className:\"outline-none min-h-[40px] p-0\"}),placeholder:null,ErrorBoundary:_ref2=>{let{children}=_ref2;return/*#__PURE__*/_jsx(_Fragment,{children:children});}}),/*#__PURE__*/_jsx(HistoryPlugin,{})]})});};export default LexicalViewer;","map":{"version":3,"names":["React","useMemo","LexicalComposer","RichTextPlugin","ContentEditable","HistoryPlugin","$getRoot","$createTextNode","jsx","_jsx","Fragment","_Fragment","jsxs","_jsxs","LexicalViewer","_ref","value","className","initialEditorState","trim","length","parsed","JSON","parse","root","editor","setEditorState","parseEditorState","update","clear","append","undefined","initialConfig","namespace","theme","text","bold","italic","underline","onError","error","console","editorState","editable","children","contentEditable","placeholder","ErrorBoundary","_ref2"],"sources":["C:/Code/beedoo/src/components/LexicalViewer.tsx"],"sourcesContent":["import React, { useMemo } from 'react';\r\nimport { LexicalComposer } from '@lexical/react/LexicalComposer';\r\nimport { RichTextPlugin } from '@lexical/react/LexicalRichTextPlugin';\r\nimport { ContentEditable } from '@lexical/react/LexicalContentEditable';\r\nimport { HistoryPlugin } from '@lexical/react/LexicalHistoryPlugin';\r\nimport { $getRoot, $createTextNode } from 'lexical';\r\nimport type { LexicalEditor } from 'lexical';\r\n\r\ninterface LexicalViewerProps {\r\n  value: string;\r\n  className?: string;\r\n}\r\n\r\nconst LexicalViewer: React.FC<LexicalViewerProps> = ({ value, className = '' }) => {\r\n  // Only set initialEditorState if value is a valid Lexical state\r\n  const initialEditorState = useMemo(() => {\r\n    if (typeof value === 'string' && value.trim().length > 0) {\r\n      let parsed: any = null;\r\n      try {\r\n        parsed = JSON.parse(value);\r\n      } catch {\r\n        // not JSON, treat as plain text\r\n      }\r\n      if (parsed && typeof parsed === 'object' && parsed.root) {\r\n        // Looks like a Lexical serialized state\r\n        return (editor: LexicalEditor) => {\r\n          editor.setEditorState(editor.parseEditorState(value));\r\n        };\r\n      } else {\r\n        // Fallback: treat as plain text\r\n        return (editor: LexicalEditor) => {\r\n          editor.update(() => {\r\n            const root = $getRoot();\r\n            root.clear();\r\n            root.append($createTextNode(value));\r\n          });\r\n        };\r\n      }\r\n    }\r\n    return undefined;\r\n  }, [value]);\r\n\r\n  const initialConfig = {\r\n    namespace: 'BeedooRichTextViewer',\r\n    theme: {\r\n      root: 'outline-none min-h-[40px] p-0',\r\n      text: {\r\n        bold: 'font-bold',\r\n        italic: 'italic',\r\n        underline: 'underline',\r\n      },\r\n    },\r\n    onError: (error: Error) => {\r\n      console.error('Lexical error:', error);\r\n    },\r\n    editorState: null,\r\n    editable: false,\r\n    initialEditorState,\r\n  };\r\n\r\n  return (\r\n    <div className={className}>\r\n      <LexicalComposer initialConfig={initialConfig}>\r\n        <RichTextPlugin\r\n          contentEditable={<ContentEditable className=\"outline-none min-h-[40px] p-0\" />}\r\n          placeholder={null}\r\n          ErrorBoundary={({ children }) => <>{children}</>}\r\n        />\r\n        <HistoryPlugin />\r\n      </LexicalComposer>\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default LexicalViewer; "],"mappings":"AAAA,MAAO,CAAAA,KAAK,EAAIC,OAAO,KAAQ,OAAO,CACtC,OAASC,eAAe,KAAQ,gCAAgC,CAChE,OAASC,cAAc,KAAQ,sCAAsC,CACrE,OAASC,eAAe,KAAQ,uCAAuC,CACvE,OAASC,aAAa,KAAQ,qCAAqC,CACnE,OAASC,QAAQ,CAAEC,eAAe,KAAQ,SAAS,CAAC,OAAAC,GAAA,IAAAC,IAAA,CAAAC,QAAA,IAAAC,SAAA,CAAAC,IAAA,IAAAC,KAAA,yBAQpD,KAAM,CAAAC,aAA2C,CAAGC,IAAA,EAA+B,IAA9B,CAAEC,KAAK,CAAEC,SAAS,CAAG,EAAG,CAAC,CAAAF,IAAA,CAC5E;AACA,KAAM,CAAAG,kBAAkB,CAAGjB,OAAO,CAAC,IAAM,CACvC,GAAI,MAAO,CAAAe,KAAK,GAAK,QAAQ,EAAIA,KAAK,CAACG,IAAI,CAAC,CAAC,CAACC,MAAM,CAAG,CAAC,CAAE,CACxD,GAAI,CAAAC,MAAW,CAAG,IAAI,CACtB,GAAI,CACFA,MAAM,CAAGC,IAAI,CAACC,KAAK,CAACP,KAAK,CAAC,CAC5B,CAAE,KAAM,CACN;AAAA,CAEF,GAAIK,MAAM,EAAI,MAAO,CAAAA,MAAM,GAAK,QAAQ,EAAIA,MAAM,CAACG,IAAI,CAAE,CACvD;AACA,MAAQ,CAAAC,MAAqB,EAAK,CAChCA,MAAM,CAACC,cAAc,CAACD,MAAM,CAACE,gBAAgB,CAACX,KAAK,CAAC,CAAC,CACvD,CAAC,CACH,CAAC,IAAM,CACL;AACA,MAAQ,CAAAS,MAAqB,EAAK,CAChCA,MAAM,CAACG,MAAM,CAAC,IAAM,CAClB,KAAM,CAAAJ,IAAI,CAAGlB,QAAQ,CAAC,CAAC,CACvBkB,IAAI,CAACK,KAAK,CAAC,CAAC,CACZL,IAAI,CAACM,MAAM,CAACvB,eAAe,CAACS,KAAK,CAAC,CAAC,CACrC,CAAC,CAAC,CACJ,CAAC,CACH,CACF,CACA,MAAO,CAAAe,SAAS,CAClB,CAAC,CAAE,CAACf,KAAK,CAAC,CAAC,CAEX,KAAM,CAAAgB,aAAa,CAAG,CACpBC,SAAS,CAAE,sBAAsB,CACjCC,KAAK,CAAE,CACLV,IAAI,CAAE,+BAA+B,CACrCW,IAAI,CAAE,CACJC,IAAI,CAAE,WAAW,CACjBC,MAAM,CAAE,QAAQ,CAChBC,SAAS,CAAE,WACb,CACF,CAAC,CACDC,OAAO,CAAGC,KAAY,EAAK,CACzBC,OAAO,CAACD,KAAK,CAAC,gBAAgB,CAAEA,KAAK,CAAC,CACxC,CAAC,CACDE,WAAW,CAAE,IAAI,CACjBC,QAAQ,CAAE,KAAK,CACfzB,kBACF,CAAC,CAED,mBACET,IAAA,QAAKQ,SAAS,CAAEA,SAAU,CAAA2B,QAAA,cACxB/B,KAAA,CAACX,eAAe,EAAC8B,aAAa,CAAEA,aAAc,CAAAY,QAAA,eAC5CnC,IAAA,CAACN,cAAc,EACb0C,eAAe,cAAEpC,IAAA,CAACL,eAAe,EAACa,SAAS,CAAC,+BAA+B,CAAE,CAAE,CAC/E6B,WAAW,CAAE,IAAK,CAClBC,aAAa,CAAEC,KAAA,MAAC,CAAEJ,QAAS,CAAC,CAAAI,KAAA,oBAAKvC,IAAA,CAAAE,SAAA,EAAAiC,QAAA,CAAGA,QAAQ,CAAG,CAAC,EAAC,CAClD,CAAC,cACFnC,IAAA,CAACJ,aAAa,GAAE,CAAC,EACF,CAAC,CACf,CAAC,CAEV,CAAC,CAED,cAAe,CAAAS,aAAa","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}