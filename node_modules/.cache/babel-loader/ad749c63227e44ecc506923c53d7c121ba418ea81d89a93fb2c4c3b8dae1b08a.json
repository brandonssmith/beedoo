{"ast":null,"code":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport { $generateHtmlFromNodes, $generateNodesFromDOM } from '@lexical/html';\nimport { $addNodeStyle, $sliceSelectedTextNodeContent } from '@lexical/selection';\nimport { objectKlassEquals } from '@lexical/utils';\nimport { $isRangeSelection, $getSelection, $createTabNode, SELECTION_INSERT_CLIPBOARD_NODES_COMMAND, $caretFromPoint, $isTextPointCaret, $getCaretRange, $getChildCaret, $getRoot, $isTextNode, $isElementNode, $parseSerializedNode, getDOMSelection, COPY_COMMAND, COMMAND_PRIORITY_CRITICAL, isSelectionWithinEditor, $getEditor, $cloneWithProperties } from 'lexical';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n// Do not require this module directly! Use normal `invariant` calls.\n\nfunction formatDevErrorMessage(message) {\n  throw new Error(message);\n}\n\n/**\n * Returns the *currently selected* Lexical content as an HTML string, relying on the\n * logic defined in the exportDOM methods on the LexicalNode classes. Note that\n * this will not return the HTML content of the entire editor (unless all the content is included\n * in the current selection).\n *\n * @param editor - LexicalEditor instance to get HTML content from\n * @param selection - The selection to use (default is $getSelection())\n * @returns a string of HTML content\n */\nfunction $getHtmlContent(editor, selection = $getSelection()) {\n  if (selection == null) {\n    {\n      formatDevErrorMessage(`Expected valid LexicalSelection`);\n    }\n  }\n\n  // If we haven't selected anything\n  if ($isRangeSelection(selection) && selection.isCollapsed() || selection.getNodes().length === 0) {\n    return '';\n  }\n  return $generateHtmlFromNodes(editor, selection);\n}\n\n/**\n * Returns the *currently selected* Lexical content as a JSON string, relying on the\n * logic defined in the exportJSON methods on the LexicalNode classes. Note that\n * this will not return the JSON content of the entire editor (unless all the content is included\n * in the current selection).\n *\n * @param editor  - LexicalEditor instance to get the JSON content from\n * @param selection - The selection to use (default is $getSelection())\n * @returns\n */\nfunction $getLexicalContent(editor, selection = $getSelection()) {\n  if (selection == null) {\n    {\n      formatDevErrorMessage(`Expected valid LexicalSelection`);\n    }\n  }\n\n  // If we haven't selected anything\n  if ($isRangeSelection(selection) && selection.isCollapsed() || selection.getNodes().length === 0) {\n    return null;\n  }\n  return JSON.stringify($generateJSONFromSelectedNodes(editor, selection));\n}\n\n/**\n * Attempts to insert content of the mime-types text/plain or text/uri-list from\n * the provided DataTransfer object into the editor at the provided selection.\n * text/uri-list is only used if text/plain is not also provided.\n *\n * @param dataTransfer an object conforming to the [DataTransfer interface] (https://html.spec.whatwg.org/multipage/dnd.html#the-datatransfer-interface)\n * @param selection the selection to use as the insertion point for the content in the DataTransfer object\n */\nfunction $insertDataTransferForPlainText(dataTransfer, selection) {\n  const text = dataTransfer.getData('text/plain') || dataTransfer.getData('text/uri-list');\n  if (text != null) {\n    selection.insertRawText(text);\n  }\n}\n\n/**\n * Attempts to insert content of the mime-types application/x-lexical-editor, text/html,\n * text/plain, or text/uri-list (in descending order of priority) from the provided DataTransfer\n * object into the editor at the provided selection.\n *\n * @param dataTransfer an object conforming to the [DataTransfer interface] (https://html.spec.whatwg.org/multipage/dnd.html#the-datatransfer-interface)\n * @param selection the selection to use as the insertion point for the content in the DataTransfer object\n * @param editor the LexicalEditor the content is being inserted into.\n */\nfunction $insertDataTransferForRichText(dataTransfer, selection, editor) {\n  const lexicalString = dataTransfer.getData('application/x-lexical-editor');\n  if (lexicalString) {\n    try {\n      const payload = JSON.parse(lexicalString);\n      if (payload.namespace === editor._config.namespace && Array.isArray(payload.nodes)) {\n        const nodes = $generateNodesFromSerializedNodes(payload.nodes);\n        return $insertGeneratedNodes(editor, nodes, selection);\n      }\n    } catch (_unused) {\n      // Fail silently.\n    }\n  }\n  const htmlString = dataTransfer.getData('text/html');\n  const plainString = dataTransfer.getData('text/plain');\n\n  // Skip HTML handling if it matches the plain text representation.\n  // This avoids unnecessary processing for plain text strings created by\n  // iOS Safari autocorrect, which incorrectly includes a `text/html` type.\n  if (htmlString && plainString !== htmlString) {\n    try {\n      const parser = new DOMParser();\n      const dom = parser.parseFromString(trustHTML(htmlString), 'text/html');\n      const nodes = $generateNodesFromDOM(editor, dom);\n      return $insertGeneratedNodes(editor, nodes, selection);\n    } catch (_unused2) {\n      // Fail silently.\n    }\n  }\n\n  // Multi-line plain text in rich text mode pasted as separate paragraphs\n  // instead of single paragraph with linebreaks.\n  // Webkit-specific: Supports read 'text/uri-list' in clipboard.\n  const text = plainString || dataTransfer.getData('text/uri-list');\n  if (text != null) {\n    if ($isRangeSelection(selection)) {\n      const parts = text.split(/(\\r?\\n|\\t)/);\n      if (parts[parts.length - 1] === '') {\n        parts.pop();\n      }\n      for (let i = 0; i < parts.length; i++) {\n        const currentSelection = $getSelection();\n        if ($isRangeSelection(currentSelection)) {\n          const part = parts[i];\n          if (part === '\\n' || part === '\\r\\n') {\n            currentSelection.insertParagraph();\n          } else if (part === '\\t') {\n            currentSelection.insertNodes([$createTabNode()]);\n          } else {\n            currentSelection.insertText(part);\n          }\n        }\n      }\n    } else {\n      selection.insertRawText(text);\n    }\n  }\n}\nfunction trustHTML(html) {\n  if (window.trustedTypes && window.trustedTypes.createPolicy) {\n    const policy = window.trustedTypes.createPolicy('lexical', {\n      createHTML: input => input\n    });\n    return policy.createHTML(html);\n  }\n  return html;\n}\n\n/**\n * Inserts Lexical nodes into the editor using different strategies depending on\n * some simple selection-based heuristics. If you're looking for a generic way to\n * to insert nodes into the editor at a specific selection point, you probably want\n * {@link lexical.$insertNodes}\n *\n * @param editor LexicalEditor instance to insert the nodes into.\n * @param nodes The nodes to insert.\n * @param selection The selection to insert the nodes into.\n */\nfunction $insertGeneratedNodes(editor, nodes, selection) {\n  if (!editor.dispatchCommand(SELECTION_INSERT_CLIPBOARD_NODES_COMMAND, {\n    nodes,\n    selection\n  })) {\n    selection.insertNodes(nodes);\n    $updateSelectionOnInsert(selection);\n  }\n  return;\n}\nfunction $updateSelectionOnInsert(selection) {\n  if ($isRangeSelection(selection) && selection.isCollapsed()) {\n    const anchor = selection.anchor;\n    let nodeToInspect = null;\n    const anchorCaret = $caretFromPoint(anchor, 'previous');\n    if (anchorCaret) {\n      if ($isTextPointCaret(anchorCaret)) {\n        nodeToInspect = anchorCaret.origin;\n      } else {\n        const range = $getCaretRange(anchorCaret, $getChildCaret($getRoot(), 'next').getFlipped());\n        for (const caret of range) {\n          if ($isTextNode(caret.origin)) {\n            nodeToInspect = caret.origin;\n            break;\n          } else if ($isElementNode(caret.origin) && !caret.origin.isInline()) {\n            break;\n          }\n        }\n      }\n    }\n    if (nodeToInspect && $isTextNode(nodeToInspect)) {\n      const newFormat = nodeToInspect.getFormat();\n      const newStyle = nodeToInspect.getStyle();\n      if (selection.format !== newFormat || selection.style !== newStyle) {\n        selection.format = newFormat;\n        selection.style = newStyle;\n        selection.dirty = true;\n      }\n    }\n  }\n}\nfunction exportNodeToJSON(node) {\n  const serializedNode = node.exportJSON();\n  const nodeClass = node.constructor;\n  if (serializedNode.type !== nodeClass.getType()) {\n    {\n      formatDevErrorMessage(`LexicalNode: Node ${nodeClass.name} does not implement .exportJSON().`);\n    }\n  }\n  if ($isElementNode(node)) {\n    const serializedChildren = serializedNode.children;\n    if (!Array.isArray(serializedChildren)) {\n      {\n        formatDevErrorMessage(`LexicalNode: Node ${nodeClass.name} is an element but .exportJSON() does not have a children array.`);\n      }\n    }\n  }\n  return serializedNode;\n}\nfunction $appendNodesToJSON(editor, selection, currentNode, targetArray = []) {\n  let shouldInclude = selection !== null ? currentNode.isSelected(selection) : true;\n  const shouldExclude = $isElementNode(currentNode) && currentNode.excludeFromCopy('html');\n  let target = currentNode;\n  if (selection !== null) {\n    let clone = $cloneWithProperties(currentNode);\n    clone = $isTextNode(clone) && selection !== null ? $sliceSelectedTextNodeContent(selection, clone) : clone;\n    target = clone;\n  }\n  const children = $isElementNode(target) ? target.getChildren() : [];\n  const serializedNode = exportNodeToJSON(target);\n\n  // TODO: TextNode calls getTextContent() (NOT node.__text) within its exportJSON method\n  // which uses getLatest() to get the text from the original node with the same key.\n  // This is a deeper issue with the word \"clone\" here, it's still a reference to the\n  // same node as far as the LexicalEditor is concerned since it shares a key.\n  // We need a way to create a clone of a Node in memory with its own key, but\n  // until then this hack will work for the selected text extract use case.\n  if ($isTextNode(target)) {\n    const text = target.__text;\n    // If an uncollapsed selection ends or starts at the end of a line of specialized,\n    // TextNodes, such as code tokens, we will get a 'blank' TextNode here, i.e., one\n    // with text of length 0. We don't want this, it makes a confusing mess. Reset!\n    if (text.length > 0) {\n      serializedNode.text = text;\n    } else {\n      shouldInclude = false;\n    }\n  }\n  for (let i = 0; i < children.length; i++) {\n    const childNode = children[i];\n    const shouldIncludeChild = $appendNodesToJSON(editor, selection, childNode, serializedNode.children);\n    if (!shouldInclude && $isElementNode(currentNode) && shouldIncludeChild && currentNode.extractWithChild(childNode, selection, 'clone')) {\n      shouldInclude = true;\n    }\n  }\n  if (shouldInclude && !shouldExclude) {\n    targetArray.push(serializedNode);\n  } else if (Array.isArray(serializedNode.children)) {\n    for (let i = 0; i < serializedNode.children.length; i++) {\n      const serializedChildNode = serializedNode.children[i];\n      targetArray.push(serializedChildNode);\n    }\n  }\n  return shouldInclude;\n}\n\n// TODO why $ function with Editor instance?\n/**\n * Gets the Lexical JSON of the nodes inside the provided Selection.\n *\n * @param editor LexicalEditor to get the JSON content from.\n * @param selection Selection to get the JSON content from.\n * @returns an object with the editor namespace and a list of serializable nodes as JavaScript objects.\n */\nfunction $generateJSONFromSelectedNodes(editor, selection) {\n  const nodes = [];\n  const root = $getRoot();\n  const topLevelChildren = root.getChildren();\n  for (let i = 0; i < topLevelChildren.length; i++) {\n    const topLevelNode = topLevelChildren[i];\n    $appendNodesToJSON(editor, selection, topLevelNode, nodes);\n  }\n  return {\n    namespace: editor._config.namespace,\n    nodes\n  };\n}\n\n/**\n * This method takes an array of objects conforming to the BaseSerializedNode interface and returns\n * an Array containing instances of the corresponding LexicalNode classes registered on the editor.\n * Normally, you'd get an Array of BaseSerialized nodes from {@link $generateJSONFromSelectedNodes}\n *\n * @param serializedNodes an Array of objects conforming to the BaseSerializedNode interface.\n * @returns an Array of Lexical Node objects.\n */\nfunction $generateNodesFromSerializedNodes(serializedNodes) {\n  const nodes = [];\n  for (let i = 0; i < serializedNodes.length; i++) {\n    const serializedNode = serializedNodes[i];\n    const node = $parseSerializedNode(serializedNode);\n    if ($isTextNode(node)) {\n      $addNodeStyle(node);\n    }\n    nodes.push(node);\n  }\n  return nodes;\n}\nconst EVENT_LATENCY = 50;\nlet clipboardEventTimeout = null;\n\n// TODO custom selection\n// TODO potentially have a node customizable version for plain text\n/**\n * Copies the content of the current selection to the clipboard in\n * text/plain, text/html, and application/x-lexical-editor (Lexical JSON)\n * formats.\n *\n * @param editor the LexicalEditor instance to copy content from\n * @param event the native browser ClipboardEvent to add the content to.\n * @returns\n */\nasync function copyToClipboard(editor, event, data) {\n  if (clipboardEventTimeout !== null) {\n    // Prevent weird race conditions that can happen when this function is run multiple times\n    // synchronously. In the future, we can do better, we can cancel/override the previously running job.\n    return false;\n  }\n  if (event !== null) {\n    return new Promise((resolve, reject) => {\n      editor.update(() => {\n        resolve($copyToClipboardEvent(editor, event, data));\n      });\n    });\n  }\n  const rootElement = editor.getRootElement();\n  const editorWindow = editor._window || window;\n  const windowDocument = window.document;\n  const domSelection = getDOMSelection(editorWindow);\n  if (rootElement === null || domSelection === null) {\n    return false;\n  }\n  const element = windowDocument.createElement('span');\n  element.style.cssText = 'position: fixed; top: -1000px;';\n  element.append(windowDocument.createTextNode('#'));\n  rootElement.append(element);\n  const range = new Range();\n  range.setStart(element, 0);\n  range.setEnd(element, 1);\n  domSelection.removeAllRanges();\n  domSelection.addRange(range);\n  return new Promise((resolve, reject) => {\n    const removeListener = editor.registerCommand(COPY_COMMAND, secondEvent => {\n      if (objectKlassEquals(secondEvent, ClipboardEvent)) {\n        removeListener();\n        if (clipboardEventTimeout !== null) {\n          window.clearTimeout(clipboardEventTimeout);\n          clipboardEventTimeout = null;\n        }\n        resolve($copyToClipboardEvent(editor, secondEvent, data));\n      }\n      // Block the entire copy flow while we wait for the next ClipboardEvent\n      return true;\n    }, COMMAND_PRIORITY_CRITICAL);\n    // If the above hack execCommand hack works, this timeout code should never fire. Otherwise,\n    // the listener will be quickly freed so that the user can reuse it again\n    clipboardEventTimeout = window.setTimeout(() => {\n      removeListener();\n      clipboardEventTimeout = null;\n      resolve(false);\n    }, EVENT_LATENCY);\n    windowDocument.execCommand('copy');\n    element.remove();\n  });\n}\n\n// TODO shouldn't pass editor (pass namespace directly)\nfunction $copyToClipboardEvent(editor, event, data) {\n  if (data === undefined) {\n    const domSelection = getDOMSelection(editor._window);\n    if (!domSelection) {\n      return false;\n    }\n    const anchorDOM = domSelection.anchorNode;\n    const focusDOM = domSelection.focusNode;\n    if (anchorDOM !== null && focusDOM !== null && !isSelectionWithinEditor(editor, anchorDOM, focusDOM)) {\n      return false;\n    }\n    const selection = $getSelection();\n    if (selection === null) {\n      return false;\n    }\n    data = $getClipboardDataFromSelection(selection);\n  }\n  event.preventDefault();\n  const clipboardData = event.clipboardData;\n  if (clipboardData === null) {\n    return false;\n  }\n  setLexicalClipboardDataTransfer(clipboardData, data);\n  return true;\n}\nconst clipboardDataFunctions = [['text/html', $getHtmlContent], ['application/x-lexical-editor', $getLexicalContent]];\n\n/**\n * Serialize the content of the current selection to strings in\n * text/plain, text/html, and application/x-lexical-editor (Lexical JSON)\n * formats (as available).\n *\n * @param selection the selection to serialize (defaults to $getSelection())\n * @returns LexicalClipboardData\n */\nfunction $getClipboardDataFromSelection(selection = $getSelection()) {\n  const clipboardData = {\n    'text/plain': selection ? selection.getTextContent() : ''\n  };\n  if (selection) {\n    const editor = $getEditor();\n    for (const [mimeType, $editorFn] of clipboardDataFunctions) {\n      const v = $editorFn(editor, selection);\n      if (v !== null) {\n        clipboardData[mimeType] = v;\n      }\n    }\n  }\n  return clipboardData;\n}\n\n/**\n * Call setData on the given clipboardData for each MIME type present\n * in the given data (from {@link $getClipboardDataFromSelection})\n *\n * @param clipboardData the event.clipboardData to populate from data\n * @param data The lexical data\n */\nfunction setLexicalClipboardDataTransfer(clipboardData, data) {\n  for (const k in data) {\n    const v = data[k];\n    if (v !== undefined) {\n      clipboardData.setData(k, v);\n    }\n  }\n}\nexport { $generateJSONFromSelectedNodes, $generateNodesFromSerializedNodes, $getClipboardDataFromSelection, $getHtmlContent, $getLexicalContent, $insertDataTransferForPlainText, $insertDataTransferForRichText, $insertGeneratedNodes, copyToClipboard, setLexicalClipboardDataTransfer };","map":{"version":3,"names":["$generateHtmlFromNodes","$generateNodesFromDOM","$addNodeStyle","$sliceSelectedTextNodeContent","objectKlassEquals","$isRangeSelection","$getSelection","$createTabNode","SELECTION_INSERT_CLIPBOARD_NODES_COMMAND","$caretFromPoint","$isTextPointCaret","$getCaretRange","$getChildCaret","$getRoot","$isTextNode","$isElementNode","$parseSerializedNode","getDOMSelection","COPY_COMMAND","COMMAND_PRIORITY_CRITICAL","isSelectionWithinEditor","$getEditor","$cloneWithProperties","formatDevErrorMessage","message","Error","$getHtmlContent","editor","selection","isCollapsed","getNodes","length","$getLexicalContent","JSON","stringify","$generateJSONFromSelectedNodes","$insertDataTransferForPlainText","dataTransfer","text","getData","insertRawText","$insertDataTransferForRichText","lexicalString","payload","parse","namespace","_config","Array","isArray","nodes","$generateNodesFromSerializedNodes","$insertGeneratedNodes","_unused","htmlString","plainString","parser","DOMParser","dom","parseFromString","trustHTML","_unused2","parts","split","pop","i","currentSelection","part","insertParagraph","insertNodes","insertText","html","window","trustedTypes","createPolicy","policy","createHTML","input","dispatchCommand","$updateSelectionOnInsert","anchor","nodeToInspect","anchorCaret","origin","range","getFlipped","caret","isInline","newFormat","getFormat","newStyle","getStyle","format","style","dirty","exportNodeToJSON","node","serializedNode","exportJSON","nodeClass","constructor","type","getType","name","serializedChildren","children","$appendNodesToJSON","currentNode","targetArray","shouldInclude","isSelected","shouldExclude","excludeFromCopy","target","clone","getChildren","__text","childNode","shouldIncludeChild","extractWithChild","push","serializedChildNode","root","topLevelChildren","topLevelNode","serializedNodes","EVENT_LATENCY","clipboardEventTimeout","copyToClipboard","event","data","Promise","resolve","reject","update","$copyToClipboardEvent","rootElement","getRootElement","editorWindow","_window","windowDocument","document","domSelection","element","createElement","cssText","append","createTextNode","Range","setStart","setEnd","removeAllRanges","addRange","removeListener","registerCommand","secondEvent","ClipboardEvent","clearTimeout","setTimeout","execCommand","remove","undefined","anchorDOM","anchorNode","focusDOM","focusNode","$getClipboardDataFromSelection","preventDefault","clipboardData","setLexicalClipboardDataTransfer","clipboardDataFunctions","getTextContent","mimeType","$editorFn","v","k","setData"],"sources":["C:/Code/beedoo/node_modules/@lexical/clipboard/LexicalClipboard.dev.mjs"],"sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport { $generateHtmlFromNodes, $generateNodesFromDOM } from '@lexical/html';\nimport { $addNodeStyle, $sliceSelectedTextNodeContent } from '@lexical/selection';\nimport { objectKlassEquals } from '@lexical/utils';\nimport { $isRangeSelection, $getSelection, $createTabNode, SELECTION_INSERT_CLIPBOARD_NODES_COMMAND, $caretFromPoint, $isTextPointCaret, $getCaretRange, $getChildCaret, $getRoot, $isTextNode, $isElementNode, $parseSerializedNode, getDOMSelection, COPY_COMMAND, COMMAND_PRIORITY_CRITICAL, isSelectionWithinEditor, $getEditor, $cloneWithProperties } from 'lexical';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n// Do not require this module directly! Use normal `invariant` calls.\n\nfunction formatDevErrorMessage(message) {\n  throw new Error(message);\n}\n\n/**\n * Returns the *currently selected* Lexical content as an HTML string, relying on the\n * logic defined in the exportDOM methods on the LexicalNode classes. Note that\n * this will not return the HTML content of the entire editor (unless all the content is included\n * in the current selection).\n *\n * @param editor - LexicalEditor instance to get HTML content from\n * @param selection - The selection to use (default is $getSelection())\n * @returns a string of HTML content\n */\nfunction $getHtmlContent(editor, selection = $getSelection()) {\n  if (selection == null) {\n    {\n      formatDevErrorMessage(`Expected valid LexicalSelection`);\n    }\n  }\n\n  // If we haven't selected anything\n  if ($isRangeSelection(selection) && selection.isCollapsed() || selection.getNodes().length === 0) {\n    return '';\n  }\n  return $generateHtmlFromNodes(editor, selection);\n}\n\n/**\n * Returns the *currently selected* Lexical content as a JSON string, relying on the\n * logic defined in the exportJSON methods on the LexicalNode classes. Note that\n * this will not return the JSON content of the entire editor (unless all the content is included\n * in the current selection).\n *\n * @param editor  - LexicalEditor instance to get the JSON content from\n * @param selection - The selection to use (default is $getSelection())\n * @returns\n */\nfunction $getLexicalContent(editor, selection = $getSelection()) {\n  if (selection == null) {\n    {\n      formatDevErrorMessage(`Expected valid LexicalSelection`);\n    }\n  }\n\n  // If we haven't selected anything\n  if ($isRangeSelection(selection) && selection.isCollapsed() || selection.getNodes().length === 0) {\n    return null;\n  }\n  return JSON.stringify($generateJSONFromSelectedNodes(editor, selection));\n}\n\n/**\n * Attempts to insert content of the mime-types text/plain or text/uri-list from\n * the provided DataTransfer object into the editor at the provided selection.\n * text/uri-list is only used if text/plain is not also provided.\n *\n * @param dataTransfer an object conforming to the [DataTransfer interface] (https://html.spec.whatwg.org/multipage/dnd.html#the-datatransfer-interface)\n * @param selection the selection to use as the insertion point for the content in the DataTransfer object\n */\nfunction $insertDataTransferForPlainText(dataTransfer, selection) {\n  const text = dataTransfer.getData('text/plain') || dataTransfer.getData('text/uri-list');\n  if (text != null) {\n    selection.insertRawText(text);\n  }\n}\n\n/**\n * Attempts to insert content of the mime-types application/x-lexical-editor, text/html,\n * text/plain, or text/uri-list (in descending order of priority) from the provided DataTransfer\n * object into the editor at the provided selection.\n *\n * @param dataTransfer an object conforming to the [DataTransfer interface] (https://html.spec.whatwg.org/multipage/dnd.html#the-datatransfer-interface)\n * @param selection the selection to use as the insertion point for the content in the DataTransfer object\n * @param editor the LexicalEditor the content is being inserted into.\n */\nfunction $insertDataTransferForRichText(dataTransfer, selection, editor) {\n  const lexicalString = dataTransfer.getData('application/x-lexical-editor');\n  if (lexicalString) {\n    try {\n      const payload = JSON.parse(lexicalString);\n      if (payload.namespace === editor._config.namespace && Array.isArray(payload.nodes)) {\n        const nodes = $generateNodesFromSerializedNodes(payload.nodes);\n        return $insertGeneratedNodes(editor, nodes, selection);\n      }\n    } catch (_unused) {\n      // Fail silently.\n    }\n  }\n  const htmlString = dataTransfer.getData('text/html');\n  const plainString = dataTransfer.getData('text/plain');\n\n  // Skip HTML handling if it matches the plain text representation.\n  // This avoids unnecessary processing for plain text strings created by\n  // iOS Safari autocorrect, which incorrectly includes a `text/html` type.\n  if (htmlString && plainString !== htmlString) {\n    try {\n      const parser = new DOMParser();\n      const dom = parser.parseFromString(trustHTML(htmlString), 'text/html');\n      const nodes = $generateNodesFromDOM(editor, dom);\n      return $insertGeneratedNodes(editor, nodes, selection);\n    } catch (_unused2) {\n      // Fail silently.\n    }\n  }\n\n  // Multi-line plain text in rich text mode pasted as separate paragraphs\n  // instead of single paragraph with linebreaks.\n  // Webkit-specific: Supports read 'text/uri-list' in clipboard.\n  const text = plainString || dataTransfer.getData('text/uri-list');\n  if (text != null) {\n    if ($isRangeSelection(selection)) {\n      const parts = text.split(/(\\r?\\n|\\t)/);\n      if (parts[parts.length - 1] === '') {\n        parts.pop();\n      }\n      for (let i = 0; i < parts.length; i++) {\n        const currentSelection = $getSelection();\n        if ($isRangeSelection(currentSelection)) {\n          const part = parts[i];\n          if (part === '\\n' || part === '\\r\\n') {\n            currentSelection.insertParagraph();\n          } else if (part === '\\t') {\n            currentSelection.insertNodes([$createTabNode()]);\n          } else {\n            currentSelection.insertText(part);\n          }\n        }\n      }\n    } else {\n      selection.insertRawText(text);\n    }\n  }\n}\nfunction trustHTML(html) {\n  if (window.trustedTypes && window.trustedTypes.createPolicy) {\n    const policy = window.trustedTypes.createPolicy('lexical', {\n      createHTML: input => input\n    });\n    return policy.createHTML(html);\n  }\n  return html;\n}\n\n/**\n * Inserts Lexical nodes into the editor using different strategies depending on\n * some simple selection-based heuristics. If you're looking for a generic way to\n * to insert nodes into the editor at a specific selection point, you probably want\n * {@link lexical.$insertNodes}\n *\n * @param editor LexicalEditor instance to insert the nodes into.\n * @param nodes The nodes to insert.\n * @param selection The selection to insert the nodes into.\n */\nfunction $insertGeneratedNodes(editor, nodes, selection) {\n  if (!editor.dispatchCommand(SELECTION_INSERT_CLIPBOARD_NODES_COMMAND, {\n    nodes,\n    selection\n  })) {\n    selection.insertNodes(nodes);\n    $updateSelectionOnInsert(selection);\n  }\n  return;\n}\nfunction $updateSelectionOnInsert(selection) {\n  if ($isRangeSelection(selection) && selection.isCollapsed()) {\n    const anchor = selection.anchor;\n    let nodeToInspect = null;\n    const anchorCaret = $caretFromPoint(anchor, 'previous');\n    if (anchorCaret) {\n      if ($isTextPointCaret(anchorCaret)) {\n        nodeToInspect = anchorCaret.origin;\n      } else {\n        const range = $getCaretRange(anchorCaret, $getChildCaret($getRoot(), 'next').getFlipped());\n        for (const caret of range) {\n          if ($isTextNode(caret.origin)) {\n            nodeToInspect = caret.origin;\n            break;\n          } else if ($isElementNode(caret.origin) && !caret.origin.isInline()) {\n            break;\n          }\n        }\n      }\n    }\n    if (nodeToInspect && $isTextNode(nodeToInspect)) {\n      const newFormat = nodeToInspect.getFormat();\n      const newStyle = nodeToInspect.getStyle();\n      if (selection.format !== newFormat || selection.style !== newStyle) {\n        selection.format = newFormat;\n        selection.style = newStyle;\n        selection.dirty = true;\n      }\n    }\n  }\n}\nfunction exportNodeToJSON(node) {\n  const serializedNode = node.exportJSON();\n  const nodeClass = node.constructor;\n  if (serializedNode.type !== nodeClass.getType()) {\n    {\n      formatDevErrorMessage(`LexicalNode: Node ${nodeClass.name} does not implement .exportJSON().`);\n    }\n  }\n  if ($isElementNode(node)) {\n    const serializedChildren = serializedNode.children;\n    if (!Array.isArray(serializedChildren)) {\n      {\n        formatDevErrorMessage(`LexicalNode: Node ${nodeClass.name} is an element but .exportJSON() does not have a children array.`);\n      }\n    }\n  }\n  return serializedNode;\n}\nfunction $appendNodesToJSON(editor, selection, currentNode, targetArray = []) {\n  let shouldInclude = selection !== null ? currentNode.isSelected(selection) : true;\n  const shouldExclude = $isElementNode(currentNode) && currentNode.excludeFromCopy('html');\n  let target = currentNode;\n  if (selection !== null) {\n    let clone = $cloneWithProperties(currentNode);\n    clone = $isTextNode(clone) && selection !== null ? $sliceSelectedTextNodeContent(selection, clone) : clone;\n    target = clone;\n  }\n  const children = $isElementNode(target) ? target.getChildren() : [];\n  const serializedNode = exportNodeToJSON(target);\n\n  // TODO: TextNode calls getTextContent() (NOT node.__text) within its exportJSON method\n  // which uses getLatest() to get the text from the original node with the same key.\n  // This is a deeper issue with the word \"clone\" here, it's still a reference to the\n  // same node as far as the LexicalEditor is concerned since it shares a key.\n  // We need a way to create a clone of a Node in memory with its own key, but\n  // until then this hack will work for the selected text extract use case.\n  if ($isTextNode(target)) {\n    const text = target.__text;\n    // If an uncollapsed selection ends or starts at the end of a line of specialized,\n    // TextNodes, such as code tokens, we will get a 'blank' TextNode here, i.e., one\n    // with text of length 0. We don't want this, it makes a confusing mess. Reset!\n    if (text.length > 0) {\n      serializedNode.text = text;\n    } else {\n      shouldInclude = false;\n    }\n  }\n  for (let i = 0; i < children.length; i++) {\n    const childNode = children[i];\n    const shouldIncludeChild = $appendNodesToJSON(editor, selection, childNode, serializedNode.children);\n    if (!shouldInclude && $isElementNode(currentNode) && shouldIncludeChild && currentNode.extractWithChild(childNode, selection, 'clone')) {\n      shouldInclude = true;\n    }\n  }\n  if (shouldInclude && !shouldExclude) {\n    targetArray.push(serializedNode);\n  } else if (Array.isArray(serializedNode.children)) {\n    for (let i = 0; i < serializedNode.children.length; i++) {\n      const serializedChildNode = serializedNode.children[i];\n      targetArray.push(serializedChildNode);\n    }\n  }\n  return shouldInclude;\n}\n\n// TODO why $ function with Editor instance?\n/**\n * Gets the Lexical JSON of the nodes inside the provided Selection.\n *\n * @param editor LexicalEditor to get the JSON content from.\n * @param selection Selection to get the JSON content from.\n * @returns an object with the editor namespace and a list of serializable nodes as JavaScript objects.\n */\nfunction $generateJSONFromSelectedNodes(editor, selection) {\n  const nodes = [];\n  const root = $getRoot();\n  const topLevelChildren = root.getChildren();\n  for (let i = 0; i < topLevelChildren.length; i++) {\n    const topLevelNode = topLevelChildren[i];\n    $appendNodesToJSON(editor, selection, topLevelNode, nodes);\n  }\n  return {\n    namespace: editor._config.namespace,\n    nodes\n  };\n}\n\n/**\n * This method takes an array of objects conforming to the BaseSerializedNode interface and returns\n * an Array containing instances of the corresponding LexicalNode classes registered on the editor.\n * Normally, you'd get an Array of BaseSerialized nodes from {@link $generateJSONFromSelectedNodes}\n *\n * @param serializedNodes an Array of objects conforming to the BaseSerializedNode interface.\n * @returns an Array of Lexical Node objects.\n */\nfunction $generateNodesFromSerializedNodes(serializedNodes) {\n  const nodes = [];\n  for (let i = 0; i < serializedNodes.length; i++) {\n    const serializedNode = serializedNodes[i];\n    const node = $parseSerializedNode(serializedNode);\n    if ($isTextNode(node)) {\n      $addNodeStyle(node);\n    }\n    nodes.push(node);\n  }\n  return nodes;\n}\nconst EVENT_LATENCY = 50;\nlet clipboardEventTimeout = null;\n\n// TODO custom selection\n// TODO potentially have a node customizable version for plain text\n/**\n * Copies the content of the current selection to the clipboard in\n * text/plain, text/html, and application/x-lexical-editor (Lexical JSON)\n * formats.\n *\n * @param editor the LexicalEditor instance to copy content from\n * @param event the native browser ClipboardEvent to add the content to.\n * @returns\n */\nasync function copyToClipboard(editor, event, data) {\n  if (clipboardEventTimeout !== null) {\n    // Prevent weird race conditions that can happen when this function is run multiple times\n    // synchronously. In the future, we can do better, we can cancel/override the previously running job.\n    return false;\n  }\n  if (event !== null) {\n    return new Promise((resolve, reject) => {\n      editor.update(() => {\n        resolve($copyToClipboardEvent(editor, event, data));\n      });\n    });\n  }\n  const rootElement = editor.getRootElement();\n  const editorWindow = editor._window || window;\n  const windowDocument = window.document;\n  const domSelection = getDOMSelection(editorWindow);\n  if (rootElement === null || domSelection === null) {\n    return false;\n  }\n  const element = windowDocument.createElement('span');\n  element.style.cssText = 'position: fixed; top: -1000px;';\n  element.append(windowDocument.createTextNode('#'));\n  rootElement.append(element);\n  const range = new Range();\n  range.setStart(element, 0);\n  range.setEnd(element, 1);\n  domSelection.removeAllRanges();\n  domSelection.addRange(range);\n  return new Promise((resolve, reject) => {\n    const removeListener = editor.registerCommand(COPY_COMMAND, secondEvent => {\n      if (objectKlassEquals(secondEvent, ClipboardEvent)) {\n        removeListener();\n        if (clipboardEventTimeout !== null) {\n          window.clearTimeout(clipboardEventTimeout);\n          clipboardEventTimeout = null;\n        }\n        resolve($copyToClipboardEvent(editor, secondEvent, data));\n      }\n      // Block the entire copy flow while we wait for the next ClipboardEvent\n      return true;\n    }, COMMAND_PRIORITY_CRITICAL);\n    // If the above hack execCommand hack works, this timeout code should never fire. Otherwise,\n    // the listener will be quickly freed so that the user can reuse it again\n    clipboardEventTimeout = window.setTimeout(() => {\n      removeListener();\n      clipboardEventTimeout = null;\n      resolve(false);\n    }, EVENT_LATENCY);\n    windowDocument.execCommand('copy');\n    element.remove();\n  });\n}\n\n// TODO shouldn't pass editor (pass namespace directly)\nfunction $copyToClipboardEvent(editor, event, data) {\n  if (data === undefined) {\n    const domSelection = getDOMSelection(editor._window);\n    if (!domSelection) {\n      return false;\n    }\n    const anchorDOM = domSelection.anchorNode;\n    const focusDOM = domSelection.focusNode;\n    if (anchorDOM !== null && focusDOM !== null && !isSelectionWithinEditor(editor, anchorDOM, focusDOM)) {\n      return false;\n    }\n    const selection = $getSelection();\n    if (selection === null) {\n      return false;\n    }\n    data = $getClipboardDataFromSelection(selection);\n  }\n  event.preventDefault();\n  const clipboardData = event.clipboardData;\n  if (clipboardData === null) {\n    return false;\n  }\n  setLexicalClipboardDataTransfer(clipboardData, data);\n  return true;\n}\nconst clipboardDataFunctions = [['text/html', $getHtmlContent], ['application/x-lexical-editor', $getLexicalContent]];\n\n/**\n * Serialize the content of the current selection to strings in\n * text/plain, text/html, and application/x-lexical-editor (Lexical JSON)\n * formats (as available).\n *\n * @param selection the selection to serialize (defaults to $getSelection())\n * @returns LexicalClipboardData\n */\nfunction $getClipboardDataFromSelection(selection = $getSelection()) {\n  const clipboardData = {\n    'text/plain': selection ? selection.getTextContent() : ''\n  };\n  if (selection) {\n    const editor = $getEditor();\n    for (const [mimeType, $editorFn] of clipboardDataFunctions) {\n      const v = $editorFn(editor, selection);\n      if (v !== null) {\n        clipboardData[mimeType] = v;\n      }\n    }\n  }\n  return clipboardData;\n}\n\n/**\n * Call setData on the given clipboardData for each MIME type present\n * in the given data (from {@link $getClipboardDataFromSelection})\n *\n * @param clipboardData the event.clipboardData to populate from data\n * @param data The lexical data\n */\nfunction setLexicalClipboardDataTransfer(clipboardData, data) {\n  for (const k in data) {\n    const v = data[k];\n    if (v !== undefined) {\n      clipboardData.setData(k, v);\n    }\n  }\n}\n\nexport { $generateJSONFromSelectedNodes, $generateNodesFromSerializedNodes, $getClipboardDataFromSelection, $getHtmlContent, $getLexicalContent, $insertDataTransferForPlainText, $insertDataTransferForRichText, $insertGeneratedNodes, copyToClipboard, setLexicalClipboardDataTransfer };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}