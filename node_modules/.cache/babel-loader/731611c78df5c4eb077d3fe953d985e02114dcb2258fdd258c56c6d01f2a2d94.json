{"ast":null,"code":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport { $isParagraphNode, $isTextNode, $getRoot, $isElementNode, $isDecoratorNode, $isLineBreakNode, $getSelection, $createTextNode, $createParagraphNode, $createLineBreakNode, COLLABORATION_TAG, HISTORIC_TAG, $isRangeSelection, $isRootOrShadowRoot, $createRangeSelection, $setSelection } from 'lexical';\nimport { $isListNode, $isListItemNode, ListNode, ListItemNode, $createListItemNode, $createListNode } from '@lexical/list';\nimport { $isQuoteNode, HeadingNode, $isHeadingNode, QuoteNode, $createQuoteNode, $createHeadingNode } from '@lexical/rich-text';\nimport { $findMatchingParent } from '@lexical/utils';\nimport { $isCodeNode, CodeNode, $createCodeNode } from '@lexical/code';\nimport { LinkNode, $isLinkNode, $isAutoLinkNode, $createLinkNode } from '@lexical/link';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction indexBy(list, callback) {\n  const index = {};\n  for (const item of list) {\n    const key = callback(item);\n    if (!key) {\n      continue;\n    }\n    if (index[key]) {\n      index[key].push(item);\n    } else {\n      index[key] = [item];\n    }\n  }\n  return index;\n}\nfunction transformersByType(transformers) {\n  const byType = indexBy(transformers, t => t.type);\n  return {\n    element: byType.element || [],\n    multilineElement: byType['multiline-element'] || [],\n    textFormat: byType['text-format'] || [],\n    textMatch: byType['text-match'] || []\n  };\n}\nconst PUNCTUATION_OR_SPACE = /[!-/:-@[-`{-~\\s]/;\nconst MARKDOWN_EMPTY_LINE_REG_EXP = /^\\s{0,3}$/;\nfunction isEmptyParagraph(node) {\n  if (!$isParagraphNode(node)) {\n    return false;\n  }\n  const firstChild = node.getFirstChild();\n  return firstChild == null || node.getChildrenSize() === 1 && $isTextNode(firstChild) && MARKDOWN_EMPTY_LINE_REG_EXP.test(firstChild.getTextContent());\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/**\n * Renders string from markdown. The selection is moved to the start after the operation.\n */\nfunction createMarkdownExport(transformers, shouldPreserveNewLines = false) {\n  const byType = transformersByType(transformers);\n  const elementTransformers = [...byType.multilineElement, ...byType.element];\n  const isNewlineDelimited = !shouldPreserveNewLines;\n\n  // Export only uses text formats that are responsible for single format\n  // e.g. it will filter out *** (bold, italic) and instead use separate ** and *\n  const textFormatTransformers = byType.textFormat.filter(transformer => transformer.format.length === 1)\n  // Make sure all text transformers that contain 'code' in their format are at the end of the array. Otherwise, formatted code like\n  // <strong><code>code</code></strong> will be exported as `**Bold Code**`, as the code format will be applied first, and the bold format\n  // will be applied second and thus skipped entirely, as the code format will prevent any further formatting.\n  .sort((a, b) => {\n    return Number(a.format.includes('code')) - Number(b.format.includes('code'));\n  });\n  return node => {\n    const output = [];\n    const children = (node || $getRoot()).getChildren();\n    for (let i = 0; i < children.length; i++) {\n      const child = children[i];\n      const result = exportTopLevelElements(child, elementTransformers, textFormatTransformers, byType.textMatch);\n      if (result != null) {\n        output.push(\n        // separate consecutive group of texts with a line break: eg. [\"hello\", \"world\"] -> [\"hello\", \"/nworld\"]\n        isNewlineDelimited && i > 0 && !isEmptyParagraph(child) && !isEmptyParagraph(children[i - 1]) ? '\\n'.concat(result) : result);\n      }\n    }\n    // Ensure consecutive groups of texts are at least \\n\\n apart while each empty paragraph render as a newline.\n    // Eg. [\"hello\", \"\", \"\", \"hi\", \"\\nworld\"] -> \"hello\\n\\n\\nhi\\n\\nworld\"\n    return output.join('\\n');\n  };\n}\nfunction exportTopLevelElements(node, elementTransformers, textTransformersIndex, textMatchTransformers) {\n  for (const transformer of elementTransformers) {\n    if (!transformer.export) {\n      continue;\n    }\n    const result = transformer.export(node, _node => exportChildren(_node, textTransformersIndex, textMatchTransformers));\n    if (result != null) {\n      return result;\n    }\n  }\n  if ($isElementNode(node)) {\n    return exportChildren(node, textTransformersIndex, textMatchTransformers);\n  } else if ($isDecoratorNode(node)) {\n    return node.getTextContent();\n  } else {\n    return null;\n  }\n}\nfunction exportChildren(node, textTransformersIndex, textMatchTransformers, unclosedTags, unclosableTags) {\n  const output = [];\n  const children = node.getChildren();\n  // keep track of unclosed tags from the very beginning\n  if (!unclosedTags) {\n    unclosedTags = [];\n  }\n  if (!unclosableTags) {\n    unclosableTags = [];\n  }\n  mainLoop: for (const child of children) {\n    for (const transformer of textMatchTransformers) {\n      if (!transformer.export) {\n        continue;\n      }\n      const result = transformer.export(child, parentNode => exportChildren(parentNode, textTransformersIndex, textMatchTransformers, unclosedTags,\n      // Add current unclosed tags to the list of unclosable tags - we don't want nested tags from\n      // textmatch transformers to close the outer ones, as that may result in invalid markdown.\n      // E.g. **text [text**](https://lexical.io)\n      // is invalid markdown, as the closing ** is inside the link.\n      //\n      [...unclosableTags, ...unclosedTags]), (textNode, textContent) => exportTextFormat(textNode, textContent, textTransformersIndex, unclosedTags, unclosableTags));\n      if (result != null) {\n        output.push(result);\n        continue mainLoop;\n      }\n    }\n    if ($isLineBreakNode(child)) {\n      output.push('\\n');\n    } else if ($isTextNode(child)) {\n      output.push(exportTextFormat(child, child.getTextContent(), textTransformersIndex, unclosedTags, unclosableTags));\n    } else if ($isElementNode(child)) {\n      // empty paragraph returns \"\"\n      output.push(exportChildren(child, textTransformersIndex, textMatchTransformers, unclosedTags, unclosableTags));\n    } else if ($isDecoratorNode(child)) {\n      output.push(child.getTextContent());\n    }\n  }\n  return output.join('');\n}\nfunction exportTextFormat(node, textContent, textTransformers,\n// unclosed tags include the markdown tags that haven't been closed yet, and their associated formats\nunclosedTags, unclosableTags) {\n  // This function handles the case of a string looking like this: \"   foo   \"\n  // Where it would be invalid markdown to generate: \"**   foo   **\"\n  // If the node has no format, we use the original text.\n  // Otherwise, we escape leading and trailing whitespaces to their corresponding code points,\n  // ensuring the returned string maintains its original formatting, e.g., \"**&#32;&#32;&#32;foo&#32;&#32;&#32;**\".\n  let output = node.getFormat() === 0 ? textContent : escapeLeadingAndTrailingWhitespaces(textContent);\n  if (!node.hasFormat('code')) {\n    // Escape any markdown characters in the text content\n    output = output.replace(/([*_`~\\\\])/g, '\\\\$1');\n  }\n\n  // the opening tags to be added to the result\n  let openingTags = '';\n  // the closing tags to be added to the result\n  let closingTagsBefore = '';\n  let closingTagsAfter = '';\n  const prevNode = getTextSibling(node, true);\n  const nextNode = getTextSibling(node, false);\n  const applied = new Set();\n  for (const transformer of textTransformers) {\n    const format = transformer.format[0];\n    const tag = transformer.tag;\n\n    // dedup applied formats\n    if (hasFormat(node, format) && !applied.has(format)) {\n      // Multiple tags might be used for the same format (*, _)\n      applied.add(format);\n\n      // append the tag to openingTags, if it's not applied to the previous nodes,\n      // or the nodes before that (which would result in an unclosed tag)\n      if (!hasFormat(prevNode, format) || !unclosedTags.find(element => element.tag === tag)) {\n        unclosedTags.push({\n          format,\n          tag\n        });\n        openingTags += tag;\n      }\n    }\n  }\n\n  // close any tags in the same order they were applied, if necessary\n  for (let i = 0; i < unclosedTags.length; i++) {\n    const nodeHasFormat = hasFormat(node, unclosedTags[i].format);\n    const nextNodeHasFormat = hasFormat(nextNode, unclosedTags[i].format);\n\n    // prevent adding closing tag if next sibling will do it\n    if (nodeHasFormat && nextNodeHasFormat) {\n      continue;\n    }\n    const unhandledUnclosedTags = [...unclosedTags]; // Shallow copy to avoid modifying the original array\n\n    while (unhandledUnclosedTags.length > i) {\n      const unclosedTag = unhandledUnclosedTags.pop();\n\n      // If tag is unclosable, don't close it and leave it in the original array,\n      // So that it can be closed when it's no longer unclosable\n      if (unclosableTags && unclosedTag && unclosableTags.find(element => element.tag === unclosedTag.tag)) {\n        continue;\n      }\n      if (unclosedTag && typeof unclosedTag.tag === 'string') {\n        if (!nodeHasFormat) {\n          // Handles cases where the tag has not been closed before, e.g. if the previous node\n          // was a text match transformer that did not account for closing tags of the next node (e.g. a link)\n          closingTagsBefore += unclosedTag.tag;\n        } else if (!nextNodeHasFormat) {\n          closingTagsAfter += unclosedTag.tag;\n        }\n      }\n      // Mutate the original array to remove the closed tag\n      unclosedTags.pop();\n    }\n    break;\n  }\n  output = openingTags + output + closingTagsAfter;\n  // Replace trimmed version of textContent ensuring surrounding whitespace is not modified\n  return closingTagsBefore + output;\n}\n\n// Get next or previous text sibling a text node, including cases\n// when it's a child of inline element (e.g. link)\nfunction getTextSibling(node, backward) {\n  let sibling = backward ? node.getPreviousSibling() : node.getNextSibling();\n  if (!sibling) {\n    const parent = node.getParentOrThrow();\n    if (parent.isInline()) {\n      sibling = backward ? parent.getPreviousSibling() : parent.getNextSibling();\n    }\n  }\n  while (sibling) {\n    if ($isElementNode(sibling)) {\n      if (!sibling.isInline()) {\n        break;\n      }\n      const descendant = backward ? sibling.getLastDescendant() : sibling.getFirstDescendant();\n      if ($isTextNode(descendant)) {\n        return descendant;\n      } else {\n        sibling = backward ? sibling.getPreviousSibling() : sibling.getNextSibling();\n      }\n    }\n    if ($isTextNode(sibling)) {\n      return sibling;\n    }\n    if (!$isElementNode(sibling)) {\n      return null;\n    }\n  }\n  return null;\n}\nfunction hasFormat(node, format) {\n  return $isTextNode(node) && node.hasFormat(format);\n}\nfunction escapeLeadingAndTrailingWhitespaces(textContent) {\n  return textContent.replace(/^\\s+|\\s+$/g, match => {\n    return [...match].map(char => '&#' + char.codePointAt(0) + ';').join('');\n  });\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction findOutermostTextFormatTransformer(textNode, textFormatTransformersIndex) {\n  const textContent = textNode.getTextContent();\n  const match = findOutermostMatch(textContent, textFormatTransformersIndex);\n  if (!match) {\n    return null;\n  }\n  const textFormatMatchStart = match.index || 0;\n  const textFormatMatchEnd = textFormatMatchStart + match[0].length;\n  const transformer = textFormatTransformersIndex.transformersByTag[match[1]];\n  return {\n    endIndex: textFormatMatchEnd,\n    match,\n    startIndex: textFormatMatchStart,\n    transformer\n  };\n}\n\n// Finds first \"<tag>content<tag>\" match that is not nested into another tag\nfunction findOutermostMatch(textContent, textTransformersIndex) {\n  const openTagsMatch = textContent.match(textTransformersIndex.openTagsRegExp);\n  if (openTagsMatch == null) {\n    return null;\n  }\n  for (const match of openTagsMatch) {\n    // Open tags reg exp might capture leading space so removing it\n    // before using match to find transformer\n    const tag = match.replace(/^\\s/, '');\n    const fullMatchRegExp = textTransformersIndex.fullMatchRegExpByTag[tag];\n    if (fullMatchRegExp == null) {\n      continue;\n    }\n    const fullMatch = textContent.match(fullMatchRegExp);\n    const transformer = textTransformersIndex.transformersByTag[tag];\n    if (fullMatch != null && transformer != null) {\n      if (transformer.intraword !== false) {\n        return fullMatch;\n      }\n\n      // For non-intraword transformers checking if it's within a word\n      // or surrounded with space/punctuation/newline\n      const {\n        index = 0\n      } = fullMatch;\n      const beforeChar = textContent[index - 1];\n      const afterChar = textContent[index + fullMatch[0].length];\n      if ((!beforeChar || PUNCTUATION_OR_SPACE.test(beforeChar)) && (!afterChar || PUNCTUATION_OR_SPACE.test(afterChar))) {\n        return fullMatch;\n      }\n    }\n  }\n  return null;\n}\nfunction importTextFormatTransformer(textNode, startIndex, endIndex, transformer, match) {\n  const textContent = textNode.getTextContent();\n\n  // No text matches - we can safely process the text format match\n  let transformedNode, nodeAfter, nodeBefore;\n\n  // If matching full content there's no need to run splitText and can reuse existing textNode\n  // to update its content and apply format. E.g. for **_Hello_** string after applying bold\n  // format (**) it will reuse the same text node to apply italic (_)\n  if (match[0] === textContent) {\n    transformedNode = textNode;\n  } else {\n    if (startIndex === 0) {\n      [transformedNode, nodeAfter] = textNode.splitText(endIndex);\n    } else {\n      [nodeBefore, transformedNode, nodeAfter] = textNode.splitText(startIndex, endIndex);\n    }\n  }\n  transformedNode.setTextContent(match[2]);\n  if (transformer) {\n    for (const format of transformer.format) {\n      if (!transformedNode.hasFormat(format)) {\n        transformedNode.toggleFormat(format);\n      }\n    }\n  }\n  return {\n    nodeAfter: nodeAfter,\n    nodeBefore: nodeBefore,\n    transformedNode: transformedNode\n  };\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction findOutermostTextMatchTransformer(textNode_, textMatchTransformers) {\n  const textNode = textNode_;\n  let foundMatchStartIndex = undefined;\n  let foundMatchEndIndex = undefined;\n  let foundMatchTransformer = undefined;\n  let foundMatch = undefined;\n  for (const transformer of textMatchTransformers) {\n    if (!transformer.replace || !transformer.importRegExp) {\n      continue;\n    }\n    const match = textNode.getTextContent().match(transformer.importRegExp);\n    if (!match) {\n      continue;\n    }\n    const startIndex = match.index || 0;\n    const endIndex = transformer.getEndIndex ? transformer.getEndIndex(textNode, match) : startIndex + match[0].length;\n    if (endIndex === false) {\n      continue;\n    }\n    if (foundMatchStartIndex === undefined || foundMatchEndIndex === undefined || startIndex < foundMatchStartIndex && endIndex > foundMatchEndIndex) {\n      foundMatchStartIndex = startIndex;\n      foundMatchEndIndex = endIndex;\n      foundMatchTransformer = transformer;\n      foundMatch = match;\n    }\n  }\n  if (foundMatchStartIndex === undefined || foundMatchEndIndex === undefined || foundMatchTransformer === undefined || foundMatch === undefined) {\n    return null;\n  }\n  return {\n    endIndex: foundMatchEndIndex,\n    match: foundMatch,\n    startIndex: foundMatchStartIndex,\n    transformer: foundMatchTransformer\n  };\n}\nfunction importFoundTextMatchTransformer(textNode, startIndex, endIndex, transformer, match) {\n  let transformedNode, nodeAfter, nodeBefore;\n  if (startIndex === 0) {\n    [transformedNode, nodeAfter] = textNode.splitText(endIndex);\n  } else {\n    [nodeBefore, transformedNode, nodeAfter] = textNode.splitText(startIndex, endIndex);\n  }\n  if (!transformer.replace) {\n    return null;\n  }\n  const potentialTransformedNode = transformer.replace(transformedNode, match);\n  return {\n    nodeAfter,\n    nodeBefore,\n    transformedNode: potentialTransformedNode || undefined\n  };\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/**\n * Returns true if the node can contain transformable markdown.\n * Code nodes cannot contain transformable markdown.\n * For example, `code **bold**` should not be transformed to\n * <code>code <strong>bold</strong></code>.\n */\nfunction canContainTransformableMarkdown(node) {\n  return $isTextNode(node) && !node.hasFormat('code');\n}\n\n/**\n * Handles applying both text format and text match transformers.\n * It finds the outermost text format or text match and applies it,\n * then recursively calls itself to apply the next outermost transformer,\n * until there are no more transformers to apply.\n */\nfunction importTextTransformers(textNode, textFormatTransformersIndex, textMatchTransformers) {\n  let foundTextFormat = findOutermostTextFormatTransformer(textNode, textFormatTransformersIndex);\n  let foundTextMatch = findOutermostTextMatchTransformer(textNode, textMatchTransformers);\n  if (foundTextFormat && foundTextMatch) {\n    // Find the outermost transformer\n    if (foundTextFormat.startIndex <= foundTextMatch.startIndex && foundTextFormat.endIndex >= foundTextMatch.endIndex) {\n      // foundTextFormat wraps foundTextMatch - apply foundTextFormat by setting foundTextMatch to null\n      foundTextMatch = null;\n    } else {\n      // foundTextMatch wraps foundTextFormat - apply foundTextMatch by setting foundTextFormat to null\n      foundTextFormat = null;\n    }\n  }\n  if (foundTextFormat) {\n    const result = importTextFormatTransformer(textNode, foundTextFormat.startIndex, foundTextFormat.endIndex, foundTextFormat.transformer, foundTextFormat.match);\n    if (canContainTransformableMarkdown(result.nodeAfter)) {\n      importTextTransformers(result.nodeAfter, textFormatTransformersIndex, textMatchTransformers);\n    }\n    if (canContainTransformableMarkdown(result.nodeBefore)) {\n      importTextTransformers(result.nodeBefore, textFormatTransformersIndex, textMatchTransformers);\n    }\n    if (canContainTransformableMarkdown(result.transformedNode)) {\n      importTextTransformers(result.transformedNode, textFormatTransformersIndex, textMatchTransformers);\n    }\n  } else if (foundTextMatch) {\n    const result = importFoundTextMatchTransformer(textNode, foundTextMatch.startIndex, foundTextMatch.endIndex, foundTextMatch.transformer, foundTextMatch.match);\n    if (!result) {\n      return;\n    }\n    if (canContainTransformableMarkdown(result.nodeAfter)) {\n      importTextTransformers(result.nodeAfter, textFormatTransformersIndex, textMatchTransformers);\n    }\n    if (canContainTransformableMarkdown(result.nodeBefore)) {\n      importTextTransformers(result.nodeBefore, textFormatTransformersIndex, textMatchTransformers);\n    }\n    if (canContainTransformableMarkdown(result.transformedNode)) {\n      importTextTransformers(result.transformedNode, textFormatTransformersIndex, textMatchTransformers);\n    }\n  }\n\n  // Handle escape characters\n  const textContent = textNode.getTextContent();\n  const escapedText = textContent.replace(/\\\\([*_`~\\\\])/g, '$1').replace(/&#(\\d+);/g, (_, codePoint) => {\n    return String.fromCodePoint(codePoint);\n  });\n  textNode.setTextContent(escapedText);\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/**\n * Renders markdown from a string. The selection is moved to the start after the operation.\n */\nfunction createMarkdownImport(transformers, shouldPreserveNewLines = false) {\n  const byType = transformersByType(transformers);\n  const textFormatTransformersIndex = createTextFormatTransformersIndex(byType.textFormat);\n  return (markdownString, node) => {\n    const lines = markdownString.split('\\n');\n    const linesLength = lines.length;\n    const root = node || $getRoot();\n    root.clear();\n    for (let i = 0; i < linesLength; i++) {\n      const lineText = lines[i];\n      const [imported, shiftedIndex] = $importMultiline(lines, i, byType.multilineElement, root);\n      if (imported) {\n        // If a multiline markdown element was imported, we don't want to process the lines that were part of it anymore.\n        // There could be other sub-markdown elements (both multiline and normal ones) matching within this matched multiline element's children.\n        // However, it would be the responsibility of the matched multiline transformer to decide how it wants to handle them.\n        // We cannot handle those, as there is no way for us to know how to maintain the correct order of generated lexical nodes for possible children.\n        i = shiftedIndex; // Next loop will start from the line after the last line of the multiline element\n        continue;\n      }\n      $importBlocks(lineText, root, byType.element, textFormatTransformersIndex, byType.textMatch, shouldPreserveNewLines);\n    }\n\n    // By default, removing empty paragraphs as md does not really\n    // allow empty lines and uses them as delimiter.\n    // If you need empty lines set shouldPreserveNewLines = true.\n    const children = root.getChildren();\n    for (const child of children) {\n      if (!shouldPreserveNewLines && isEmptyParagraph(child) && root.getChildrenSize() > 1) {\n        child.remove();\n      }\n    }\n    if ($getSelection() !== null) {\n      root.selectStart();\n    }\n  };\n}\n\n/**\n *\n * @returns first element of the returned tuple is a boolean indicating if a multiline element was imported. The second element is the index of the last line that was processed.\n */\nfunction $importMultiline(lines, startLineIndex, multilineElementTransformers, rootNode) {\n  for (const transformer of multilineElementTransformers) {\n    const {\n      handleImportAfterStartMatch,\n      regExpEnd,\n      regExpStart,\n      replace\n    } = transformer;\n    const startMatch = lines[startLineIndex].match(regExpStart);\n    if (!startMatch) {\n      continue; // Try next transformer\n    }\n    if (handleImportAfterStartMatch) {\n      const result = handleImportAfterStartMatch({\n        lines,\n        rootNode,\n        startLineIndex,\n        startMatch,\n        transformer\n      });\n      if (result === null) {\n        continue;\n      } else if (result) {\n        return result;\n      }\n    }\n    const regexpEndRegex = typeof regExpEnd === 'object' && 'regExp' in regExpEnd ? regExpEnd.regExp : regExpEnd;\n    const isEndOptional = regExpEnd && typeof regExpEnd === 'object' && 'optional' in regExpEnd ? regExpEnd.optional : !regExpEnd;\n    let endLineIndex = startLineIndex;\n    const linesLength = lines.length;\n\n    // check every single line for the closing match. It could also be on the same line as the opening match.\n    while (endLineIndex < linesLength) {\n      const endMatch = regexpEndRegex ? lines[endLineIndex].match(regexpEndRegex) : null;\n      if (!endMatch) {\n        if (!isEndOptional || isEndOptional && endLineIndex < linesLength - 1 // Optional end, but didn't reach the end of the document yet => continue searching for potential closing match\n        ) {\n          endLineIndex++;\n          continue; // Search next line for closing match\n        }\n      }\n\n      // Now, check if the closing match matched is the same as the opening match.\n      // If it is, we need to continue searching for the actual closing match.\n      if (endMatch && startLineIndex === endLineIndex && endMatch.index === startMatch.index) {\n        endLineIndex++;\n        continue; // Search next line for closing match\n      }\n\n      // At this point, we have found the closing match. Next: calculate the lines in between open and closing match\n      // This should not include the matches themselves, and be split up by lines\n      const linesInBetween = [];\n      if (endMatch && startLineIndex === endLineIndex) {\n        linesInBetween.push(lines[startLineIndex].slice(startMatch[0].length, -endMatch[0].length));\n      } else {\n        for (let i = startLineIndex; i <= endLineIndex; i++) {\n          if (i === startLineIndex) {\n            const text = lines[i].slice(startMatch[0].length);\n            linesInBetween.push(text); // Also include empty text\n          } else if (i === endLineIndex && endMatch) {\n            const text = lines[i].slice(0, -endMatch[0].length);\n            linesInBetween.push(text); // Also include empty text\n          } else {\n            linesInBetween.push(lines[i]);\n          }\n        }\n      }\n      if (replace(rootNode, null, startMatch, endMatch, linesInBetween, true) !== false) {\n        // Return here. This $importMultiline function is run line by line and should only process a single multiline element at a time.\n        return [true, endLineIndex];\n      }\n\n      // The replace function returned false, despite finding the matching open and close tags => this transformer does not want to handle it.\n      // Thus, we continue letting the remaining transformers handle the passed lines of text from the beginning\n      break;\n    }\n  }\n\n  // No multiline transformer handled this line successfully\n  return [false, startLineIndex];\n}\nfunction $importBlocks(lineText, rootNode, elementTransformers, textFormatTransformersIndex, textMatchTransformers, shouldPreserveNewLines) {\n  const textNode = $createTextNode(lineText);\n  const elementNode = $createParagraphNode();\n  elementNode.append(textNode);\n  rootNode.append(elementNode);\n  for (const {\n    regExp,\n    replace\n  } of elementTransformers) {\n    const match = lineText.match(regExp);\n    if (match) {\n      textNode.setTextContent(lineText.slice(match[0].length));\n      if (replace(elementNode, [textNode], match, true) !== false) {\n        break;\n      }\n    }\n  }\n  importTextTransformers(textNode, textFormatTransformersIndex, textMatchTransformers);\n\n  // If no transformer found and we left with original paragraph node\n  // can check if its content can be appended to the previous node\n  // if it's a paragraph, quote or list\n  if (elementNode.isAttached() && lineText.length > 0) {\n    const previousNode = elementNode.getPreviousSibling();\n    if (!shouldPreserveNewLines && (\n    // Only append if we're not preserving newlines\n    $isParagraphNode(previousNode) || $isQuoteNode(previousNode) || $isListNode(previousNode))) {\n      let targetNode = previousNode;\n      if ($isListNode(previousNode)) {\n        const lastDescendant = previousNode.getLastDescendant();\n        if (lastDescendant == null) {\n          targetNode = null;\n        } else {\n          targetNode = $findMatchingParent(lastDescendant, $isListItemNode);\n        }\n      }\n      if (targetNode != null && targetNode.getTextContentSize() > 0) {\n        targetNode.splice(targetNode.getChildrenSize(), 0, [$createLineBreakNode(), ...elementNode.getChildren()]);\n        elementNode.remove();\n      }\n    }\n  }\n}\nfunction createTextFormatTransformersIndex(textTransformers) {\n  const transformersByTag = {};\n  const fullMatchRegExpByTag = {};\n  const openTagsRegExp = [];\n  const escapeRegExp = `(?<![\\\\\\\\])`;\n  for (const transformer of textTransformers) {\n    const {\n      tag\n    } = transformer;\n    transformersByTag[tag] = transformer;\n    const tagRegExp = tag.replace(/(\\*|\\^|\\+)/g, '\\\\$1');\n    openTagsRegExp.push(tagRegExp);\n\n    // Single-char tag (e.g. \"*\"),\n    if (tag.length === 1) {\n      fullMatchRegExpByTag[tag] = new RegExp(`(?<![\\\\\\\\${tagRegExp}])(${tagRegExp})((\\\\\\\\${tagRegExp})?.*?[^${tagRegExp}\\\\s](\\\\\\\\${tagRegExp})?)((?<!\\\\\\\\)|(?<=\\\\\\\\\\\\\\\\))(${tagRegExp})(?![\\\\\\\\${tagRegExp}])`);\n    } else {\n      // Multiâ€char tags (e.g. \"**\")\n      fullMatchRegExpByTag[tag] = new RegExp(`(?<!\\\\\\\\)(${tagRegExp})((\\\\\\\\${tagRegExp})?.*?[^\\\\s](\\\\\\\\${tagRegExp})?)((?<!\\\\\\\\)|(?<=\\\\\\\\\\\\\\\\))(${tagRegExp})(?!\\\\\\\\)`);\n    }\n  }\n  return {\n    // Reg exp to find open tag + content + close tag\n    fullMatchRegExpByTag,\n    // Regexp to locate *any* potential opening tag (longest first).\n    openTagsRegExp: new RegExp(`${escapeRegExp}(${openTagsRegExp.join('|')})`, 'g'),\n    transformersByTag\n  };\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n// Do not require this module directly! Use normal `invariant` calls.\n\nfunction formatDevErrorMessage(message) {\n  throw new Error(message);\n}\nfunction runElementTransformers(parentNode, anchorNode, anchorOffset, elementTransformers) {\n  const grandParentNode = parentNode.getParent();\n  if (!$isRootOrShadowRoot(grandParentNode) || parentNode.getFirstChild() !== anchorNode) {\n    return false;\n  }\n  const textContent = anchorNode.getTextContent();\n\n  // Checking for anchorOffset position to prevent any checks for cases when caret is too far\n  // from a line start to be a part of block-level markdown trigger.\n  //\n  // TODO:\n  // Can have a quick check if caret is close enough to the beginning of the string (e.g. offset less than 10-20)\n  // since otherwise it won't be a markdown shortcut, but tables are exception\n  if (textContent[anchorOffset - 1] !== ' ') {\n    return false;\n  }\n  for (const {\n    regExp,\n    replace\n  } of elementTransformers) {\n    const match = textContent.match(regExp);\n    if (match && match[0].length === (match[0].endsWith(' ') ? anchorOffset : anchorOffset - 1)) {\n      const nextSiblings = anchorNode.getNextSiblings();\n      const [leadingNode, remainderNode] = anchorNode.splitText(anchorOffset);\n      const siblings = remainderNode ? [remainderNode, ...nextSiblings] : nextSiblings;\n      if (replace(parentNode, siblings, match, false) !== false) {\n        leadingNode.remove();\n        return true;\n      }\n    }\n  }\n  return false;\n}\nfunction runMultilineElementTransformers(parentNode, anchorNode, anchorOffset, elementTransformers) {\n  const grandParentNode = parentNode.getParent();\n  if (!$isRootOrShadowRoot(grandParentNode) || parentNode.getFirstChild() !== anchorNode) {\n    return false;\n  }\n  const textContent = anchorNode.getTextContent();\n\n  // Checking for anchorOffset position to prevent any checks for cases when caret is too far\n  // from a line start to be a part of block-level markdown trigger.\n  //\n  // TODO:\n  // Can have a quick check if caret is close enough to the beginning of the string (e.g. offset less than 10-20)\n  // since otherwise it won't be a markdown shortcut, but tables are exception\n  if (textContent[anchorOffset - 1] !== ' ') {\n    return false;\n  }\n  for (const {\n    regExpStart,\n    replace,\n    regExpEnd\n  } of elementTransformers) {\n    if (regExpEnd && !('optional' in regExpEnd) || regExpEnd && 'optional' in regExpEnd && !regExpEnd.optional) {\n      continue;\n    }\n    const match = textContent.match(regExpStart);\n    if (match && match[0].length === (match[0].endsWith(' ') ? anchorOffset : anchorOffset - 1)) {\n      const nextSiblings = anchorNode.getNextSiblings();\n      const [leadingNode, remainderNode] = anchorNode.splitText(anchorOffset);\n      const siblings = remainderNode ? [remainderNode, ...nextSiblings] : nextSiblings;\n      if (replace(parentNode, siblings, match, null, null, false) !== false) {\n        leadingNode.remove();\n        return true;\n      }\n    }\n  }\n  return false;\n}\nfunction runTextMatchTransformers(anchorNode, anchorOffset, transformersByTrigger) {\n  let textContent = anchorNode.getTextContent();\n  const lastChar = textContent[anchorOffset - 1];\n  const transformers = transformersByTrigger[lastChar];\n  if (transformers == null) {\n    return false;\n  }\n\n  // If typing in the middle of content, remove the tail to do\n  // reg exp match up to a string end (caret position)\n  if (anchorOffset < textContent.length) {\n    textContent = textContent.slice(0, anchorOffset);\n  }\n  for (const transformer of transformers) {\n    if (!transformer.replace || !transformer.regExp) {\n      continue;\n    }\n    const match = textContent.match(transformer.regExp);\n    if (match === null) {\n      continue;\n    }\n    const startIndex = match.index || 0;\n    const endIndex = startIndex + match[0].length;\n    let replaceNode;\n    if (startIndex === 0) {\n      [replaceNode] = anchorNode.splitText(endIndex);\n    } else {\n      [, replaceNode] = anchorNode.splitText(startIndex, endIndex);\n    }\n    replaceNode.selectNext(0, 0);\n    transformer.replace(replaceNode, match);\n    return true;\n  }\n  return false;\n}\nfunction $runTextFormatTransformers(anchorNode, anchorOffset, textFormatTransformers) {\n  const textContent = anchorNode.getTextContent();\n  const closeTagEndIndex = anchorOffset - 1;\n  const closeChar = textContent[closeTagEndIndex];\n  // Quick check if we're possibly at the end of inline markdown style\n  const matchers = textFormatTransformers[closeChar];\n  if (!matchers) {\n    return false;\n  }\n  for (const matcher of matchers) {\n    const {\n      tag\n    } = matcher;\n    const tagLength = tag.length;\n    const closeTagStartIndex = closeTagEndIndex - tagLength + 1;\n\n    // If tag is not single char check if rest of it matches with text content\n    if (tagLength > 1) {\n      if (!isEqualSubString(textContent, closeTagStartIndex, tag, 0, tagLength)) {\n        continue;\n      }\n    }\n\n    // Space before closing tag cancels inline markdown\n    if (textContent[closeTagStartIndex - 1] === ' ') {\n      continue;\n    }\n\n    // Some tags can not be used within words, hence should have newline/space/punctuation after it\n    const afterCloseTagChar = textContent[closeTagEndIndex + 1];\n    if (matcher.intraword === false && afterCloseTagChar && !PUNCTUATION_OR_SPACE.test(afterCloseTagChar)) {\n      continue;\n    }\n    const closeNode = anchorNode;\n    let openNode = closeNode;\n    let openTagStartIndex = getOpenTagStartIndex(textContent, closeTagStartIndex, tag);\n\n    // Go through text node siblings and search for opening tag\n    // if haven't found it within the same text node as closing tag\n    let sibling = openNode;\n    while (openTagStartIndex < 0 && (sibling = sibling.getPreviousSibling())) {\n      if ($isLineBreakNode(sibling)) {\n        break;\n      }\n      if ($isTextNode(sibling)) {\n        if (sibling.hasFormat('code')) {\n          continue;\n        }\n        const siblingTextContent = sibling.getTextContent();\n        openNode = sibling;\n        openTagStartIndex = getOpenTagStartIndex(siblingTextContent, siblingTextContent.length, tag);\n      }\n    }\n\n    // Opening tag is not found\n    if (openTagStartIndex < 0) {\n      continue;\n    }\n\n    // No content between opening and closing tag\n    if (openNode === closeNode && openTagStartIndex + tagLength === closeTagStartIndex) {\n      continue;\n    }\n\n    // Checking longer tags for repeating chars (e.g. *** vs **)\n    const prevOpenNodeText = openNode.getTextContent();\n    if (openTagStartIndex > 0 && prevOpenNodeText[openTagStartIndex - 1] === closeChar) {\n      continue;\n    }\n\n    // Some tags can not be used within words, hence should have newline/space/punctuation before it\n    const beforeOpenTagChar = prevOpenNodeText[openTagStartIndex - 1];\n    if (matcher.intraword === false && beforeOpenTagChar && !PUNCTUATION_OR_SPACE.test(beforeOpenTagChar)) {\n      continue;\n    }\n\n    // Clean text from opening and closing tags (starting from closing tag\n    // to prevent any offset shifts if we start from opening one)\n    const prevCloseNodeText = closeNode.getTextContent();\n    const closeNodeText = prevCloseNodeText.slice(0, closeTagStartIndex) + prevCloseNodeText.slice(closeTagEndIndex + 1);\n    closeNode.setTextContent(closeNodeText);\n    const openNodeText = openNode === closeNode ? closeNodeText : prevOpenNodeText;\n    openNode.setTextContent(openNodeText.slice(0, openTagStartIndex) + openNodeText.slice(openTagStartIndex + tagLength));\n    const selection = $getSelection();\n    const nextSelection = $createRangeSelection();\n    $setSelection(nextSelection);\n    // Adjust offset based on deleted chars\n    const newOffset = closeTagEndIndex - tagLength * (openNode === closeNode ? 2 : 1) + 1;\n    nextSelection.anchor.set(openNode.__key, openTagStartIndex, 'text');\n    nextSelection.focus.set(closeNode.__key, newOffset, 'text');\n\n    // Apply formatting to selected text\n    for (const format of matcher.format) {\n      if (!nextSelection.hasFormat(format)) {\n        nextSelection.formatText(format);\n      }\n    }\n\n    // Collapse selection up to the focus point\n    nextSelection.anchor.set(nextSelection.focus.key, nextSelection.focus.offset, nextSelection.focus.type);\n\n    // Remove formatting from collapsed selection\n    for (const format of matcher.format) {\n      if (nextSelection.hasFormat(format)) {\n        nextSelection.toggleFormat(format);\n      }\n    }\n    if ($isRangeSelection(selection)) {\n      nextSelection.format = selection.format;\n    }\n    return true;\n  }\n  return false;\n}\nfunction getOpenTagStartIndex(string, maxIndex, tag) {\n  const tagLength = tag.length;\n  for (let i = maxIndex; i >= tagLength; i--) {\n    const startIndex = i - tagLength;\n    if (isEqualSubString(string, startIndex, tag, 0, tagLength) &&\n    // Space after opening tag cancels transformation\n    string[startIndex + tagLength] !== ' ') {\n      return startIndex;\n    }\n  }\n  return -1;\n}\nfunction isEqualSubString(stringA, aStart, stringB, bStart, length) {\n  for (let i = 0; i < length; i++) {\n    if (stringA[aStart + i] !== stringB[bStart + i]) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction registerMarkdownShortcuts(editor, transformers = TRANSFORMERS) {\n  const byType = transformersByType(transformers);\n  const textFormatTransformersByTrigger = indexBy(byType.textFormat, ({\n    tag\n  }) => tag[tag.length - 1]);\n  const textMatchTransformersByTrigger = indexBy(byType.textMatch, ({\n    trigger\n  }) => trigger);\n  for (const transformer of transformers) {\n    const type = transformer.type;\n    if (type === 'element' || type === 'text-match' || type === 'multiline-element') {\n      const dependencies = transformer.dependencies;\n      for (const node of dependencies) {\n        if (!editor.hasNode(node)) {\n          {\n            formatDevErrorMessage(`MarkdownShortcuts: missing dependency ${node.getType()} for transformer. Ensure node dependency is included in editor initial config.`);\n          }\n        }\n      }\n    }\n  }\n  const $transform = (parentNode, anchorNode, anchorOffset) => {\n    if (runElementTransformers(parentNode, anchorNode, anchorOffset, byType.element)) {\n      return;\n    }\n    if (runMultilineElementTransformers(parentNode, anchorNode, anchorOffset, byType.multilineElement)) {\n      return;\n    }\n    if (runTextMatchTransformers(anchorNode, anchorOffset, textMatchTransformersByTrigger)) {\n      return;\n    }\n    $runTextFormatTransformers(anchorNode, anchorOffset, textFormatTransformersByTrigger);\n  };\n  return editor.registerUpdateListener(({\n    tags,\n    dirtyLeaves,\n    editorState,\n    prevEditorState\n  }) => {\n    // Ignore updates from collaboration and undo/redo (as changes already calculated)\n    if (tags.has(COLLABORATION_TAG) || tags.has(HISTORIC_TAG)) {\n      return;\n    }\n\n    // If editor is still composing (i.e. backticks) we must wait before the user confirms the key\n    if (editor.isComposing()) {\n      return;\n    }\n    const selection = editorState.read($getSelection);\n    const prevSelection = prevEditorState.read($getSelection);\n\n    // We expect selection to be a collapsed range and not match previous one (as we want\n    // to trigger transforms only as user types)\n    if (!$isRangeSelection(prevSelection) || !$isRangeSelection(selection) || !selection.isCollapsed() || selection.is(prevSelection)) {\n      return;\n    }\n    const anchorKey = selection.anchor.key;\n    const anchorOffset = selection.anchor.offset;\n    const anchorNode = editorState._nodeMap.get(anchorKey);\n    if (!$isTextNode(anchorNode) || !dirtyLeaves.has(anchorKey) || anchorOffset !== 1 && anchorOffset > prevSelection.anchor.offset + 1) {\n      return;\n    }\n    editor.update(() => {\n      if (!canContainTransformableMarkdown(anchorNode)) {\n        return;\n      }\n      const parentNode = anchorNode.getParent();\n      if (parentNode === null || $isCodeNode(parentNode)) {\n        return;\n      }\n      $transform(parentNode, anchorNode, selection.anchor.offset);\n    });\n  });\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst ORDERED_LIST_REGEX = /^(\\s*)(\\d{1,})\\.\\s/;\nconst UNORDERED_LIST_REGEX = /^(\\s*)[-*+]\\s/;\nconst CHECK_LIST_REGEX = /^(\\s*)(?:-\\s)?\\s?(\\[(\\s|x)?\\])\\s/i;\nconst HEADING_REGEX = /^(#{1,6})\\s/;\nconst QUOTE_REGEX = /^>\\s/;\nconst CODE_START_REGEX = /^[ \\t]*```([\\w-]+)?/;\nconst CODE_END_REGEX = /[ \\t]*```$/;\nconst CODE_SINGLE_LINE_REGEX = /^[ \\t]*```[^`]+(?:(?:`{1,2}|`{4,})[^`]+)*```(?:[^`]|$)/;\nconst TABLE_ROW_REG_EXP = /^(?:\\|)(.+)(?:\\|)\\s?$/;\nconst TABLE_ROW_DIVIDER_REG_EXP = /^(\\| ?:?-*:? ?)+\\|\\s?$/;\nconst createBlockNode = createNode => {\n  return (parentNode, children, match, isImport) => {\n    const node = createNode(match);\n    node.append(...children);\n    parentNode.replace(node);\n    if (!isImport) {\n      node.select(0, 0);\n    }\n  };\n};\n\n// Amount of spaces that define indentation level\n// TODO: should be an option\nconst LIST_INDENT_SIZE = 4;\nfunction getIndent(whitespaces) {\n  const tabs = whitespaces.match(/\\t/g);\n  const spaces = whitespaces.match(/ /g);\n  let indent = 0;\n  if (tabs) {\n    indent += tabs.length;\n  }\n  if (spaces) {\n    indent += Math.floor(spaces.length / LIST_INDENT_SIZE);\n  }\n  return indent;\n}\nconst listReplace = listType => {\n  return (parentNode, children, match, isImport) => {\n    const previousNode = parentNode.getPreviousSibling();\n    const nextNode = parentNode.getNextSibling();\n    const listItem = $createListItemNode(listType === 'check' ? match[3] === 'x' : undefined);\n    if ($isListNode(nextNode) && nextNode.getListType() === listType) {\n      const firstChild = nextNode.getFirstChild();\n      if (firstChild !== null) {\n        firstChild.insertBefore(listItem);\n      } else {\n        // should never happen, but let's handle gracefully, just in case.\n        nextNode.append(listItem);\n      }\n      parentNode.remove();\n    } else if ($isListNode(previousNode) && previousNode.getListType() === listType) {\n      previousNode.append(listItem);\n      parentNode.remove();\n    } else {\n      const list = $createListNode(listType, listType === 'number' ? Number(match[2]) : undefined);\n      list.append(listItem);\n      parentNode.replace(list);\n    }\n    listItem.append(...children);\n    if (!isImport) {\n      listItem.select(0, 0);\n    }\n    const indent = getIndent(match[1]);\n    if (indent) {\n      listItem.setIndent(indent);\n    }\n  };\n};\nconst listExport = (listNode, exportChildren, depth) => {\n  const output = [];\n  const children = listNode.getChildren();\n  let index = 0;\n  for (const listItemNode of children) {\n    if ($isListItemNode(listItemNode)) {\n      if (listItemNode.getChildrenSize() === 1) {\n        const firstChild = listItemNode.getFirstChild();\n        if ($isListNode(firstChild)) {\n          output.push(listExport(firstChild, exportChildren, depth + 1));\n          continue;\n        }\n      }\n      const indent = ' '.repeat(depth * LIST_INDENT_SIZE);\n      const listType = listNode.getListType();\n      const prefix = listType === 'number' ? `${listNode.getStart() + index}. ` : listType === 'check' ? `- [${listItemNode.getChecked() ? 'x' : ' '}] ` : '- ';\n      output.push(indent + prefix + exportChildren(listItemNode));\n      index++;\n    }\n  }\n  return output.join('\\n');\n};\nconst HEADING = {\n  dependencies: [HeadingNode],\n  export: (node, exportChildren) => {\n    if (!$isHeadingNode(node)) {\n      return null;\n    }\n    const level = Number(node.getTag().slice(1));\n    return '#'.repeat(level) + ' ' + exportChildren(node);\n  },\n  regExp: HEADING_REGEX,\n  replace: createBlockNode(match => {\n    const tag = 'h' + match[1].length;\n    return $createHeadingNode(tag);\n  }),\n  type: 'element'\n};\nconst QUOTE = {\n  dependencies: [QuoteNode],\n  export: (node, exportChildren) => {\n    if (!$isQuoteNode(node)) {\n      return null;\n    }\n    const lines = exportChildren(node).split('\\n');\n    const output = [];\n    for (const line of lines) {\n      output.push('> ' + line);\n    }\n    return output.join('\\n');\n  },\n  regExp: QUOTE_REGEX,\n  replace: (parentNode, children, _match, isImport) => {\n    if (isImport) {\n      const previousNode = parentNode.getPreviousSibling();\n      if ($isQuoteNode(previousNode)) {\n        previousNode.splice(previousNode.getChildrenSize(), 0, [$createLineBreakNode(), ...children]);\n        parentNode.remove();\n        return;\n      }\n    }\n    const node = $createQuoteNode();\n    node.append(...children);\n    parentNode.replace(node);\n    if (!isImport) {\n      node.select(0, 0);\n    }\n  },\n  type: 'element'\n};\nconst CODE = {\n  dependencies: [CodeNode],\n  export: node => {\n    if (!$isCodeNode(node)) {\n      return null;\n    }\n    const textContent = node.getTextContent();\n    return '```' + (node.getLanguage() || '') + (textContent ? '\\n' + textContent : '') + '\\n' + '```';\n  },\n  regExpEnd: {\n    optional: true,\n    regExp: CODE_END_REGEX\n  },\n  regExpStart: CODE_START_REGEX,\n  replace: (rootNode, children, startMatch, endMatch, linesInBetween, isImport) => {\n    let codeBlockNode;\n    let code;\n    if (!children && linesInBetween) {\n      if (linesInBetween.length === 1) {\n        // Single-line code blocks\n        if (endMatch) {\n          // End match on same line. Example: ```markdown hello```. markdown should not be considered the language here.\n          codeBlockNode = $createCodeNode();\n          code = startMatch[1] + linesInBetween[0];\n        } else {\n          // No end match. We should assume the language is next to the backticks and that code will be typed on the next line in the future\n          codeBlockNode = $createCodeNode(startMatch[1]);\n          code = linesInBetween[0].startsWith(' ') ? linesInBetween[0].slice(1) : linesInBetween[0];\n        }\n      } else {\n        // Treat multi-line code blocks as if they always have an end match\n        codeBlockNode = $createCodeNode(startMatch[1]);\n        if (linesInBetween[0].trim().length === 0) {\n          // Filter out all start and end lines that are length 0 until we find the first line with content\n          while (linesInBetween.length > 0 && !linesInBetween[0].length) {\n            linesInBetween.shift();\n          }\n        } else {\n          // The first line already has content => Remove the first space of the line if it exists\n          linesInBetween[0] = linesInBetween[0].startsWith(' ') ? linesInBetween[0].slice(1) : linesInBetween[0];\n        }\n\n        // Filter out all end lines that are length 0 until we find the last line with content\n        while (linesInBetween.length > 0 && !linesInBetween[linesInBetween.length - 1].length) {\n          linesInBetween.pop();\n        }\n        code = linesInBetween.join('\\n');\n      }\n      const textNode = $createTextNode(code);\n      codeBlockNode.append(textNode);\n      rootNode.append(codeBlockNode);\n    } else if (children) {\n      createBlockNode(match => {\n        return $createCodeNode(match ? match[1] : undefined);\n      })(rootNode, children, startMatch, isImport);\n    }\n  },\n  type: 'multiline-element'\n};\nconst UNORDERED_LIST = {\n  dependencies: [ListNode, ListItemNode],\n  export: (node, exportChildren) => {\n    return $isListNode(node) ? listExport(node, exportChildren, 0) : null;\n  },\n  regExp: UNORDERED_LIST_REGEX,\n  replace: listReplace('bullet'),\n  type: 'element'\n};\nconst CHECK_LIST = {\n  dependencies: [ListNode, ListItemNode],\n  export: (node, exportChildren) => {\n    return $isListNode(node) ? listExport(node, exportChildren, 0) : null;\n  },\n  regExp: CHECK_LIST_REGEX,\n  replace: listReplace('check'),\n  type: 'element'\n};\nconst ORDERED_LIST = {\n  dependencies: [ListNode, ListItemNode],\n  export: (node, exportChildren) => {\n    return $isListNode(node) ? listExport(node, exportChildren, 0) : null;\n  },\n  regExp: ORDERED_LIST_REGEX,\n  replace: listReplace('number'),\n  type: 'element'\n};\nconst INLINE_CODE = {\n  format: ['code'],\n  tag: '`',\n  type: 'text-format'\n};\nconst HIGHLIGHT = {\n  format: ['highlight'],\n  tag: '==',\n  type: 'text-format'\n};\nconst BOLD_ITALIC_STAR = {\n  format: ['bold', 'italic'],\n  tag: '***',\n  type: 'text-format'\n};\nconst BOLD_ITALIC_UNDERSCORE = {\n  format: ['bold', 'italic'],\n  intraword: false,\n  tag: '___',\n  type: 'text-format'\n};\nconst BOLD_STAR = {\n  format: ['bold'],\n  tag: '**',\n  type: 'text-format'\n};\nconst BOLD_UNDERSCORE = {\n  format: ['bold'],\n  intraword: false,\n  tag: '__',\n  type: 'text-format'\n};\nconst STRIKETHROUGH = {\n  format: ['strikethrough'],\n  tag: '~~',\n  type: 'text-format'\n};\nconst ITALIC_STAR = {\n  format: ['italic'],\n  tag: '*',\n  type: 'text-format'\n};\nconst ITALIC_UNDERSCORE = {\n  format: ['italic'],\n  intraword: false,\n  tag: '_',\n  type: 'text-format'\n};\n\n// Order of text transformers matters:\n//\n// - code should go first as it prevents any transformations inside\n// - then longer tags match (e.g. ** or __ should go before * or _)\nconst LINK = {\n  dependencies: [LinkNode],\n  export: (node, exportChildren, exportFormat) => {\n    if (!$isLinkNode(node) || $isAutoLinkNode(node)) {\n      return null;\n    }\n    const title = node.getTitle();\n    const textContent = exportChildren(node);\n    const linkContent = title ? `[${textContent}](${node.getURL()} \"${title}\")` : `[${textContent}](${node.getURL()})`;\n    return linkContent;\n  },\n  importRegExp: /(?:\\[([^[]+)\\])(?:\\((?:([^()\\s]+)(?:\\s\"((?:[^\"]*\\\\\")*[^\"]*)\"\\s*)?)\\))/,\n  regExp: /(?:\\[([^[]+)\\])(?:\\((?:([^()\\s]+)(?:\\s\"((?:[^\"]*\\\\\")*[^\"]*)\"\\s*)?)\\))$/,\n  replace: (textNode, match) => {\n    const [, linkText, linkUrl, linkTitle] = match;\n    const linkNode = $createLinkNode(linkUrl, {\n      title: linkTitle\n    });\n    const linkTextNode = $createTextNode(linkText);\n    linkTextNode.setFormat(textNode.getFormat());\n    linkNode.append(linkTextNode);\n    textNode.replace(linkNode);\n    return linkTextNode;\n  },\n  trigger: ')',\n  type: 'text-match'\n};\nfunction normalizeMarkdown(input, shouldMergeAdjacentLines = false) {\n  const lines = input.split('\\n');\n  let inCodeBlock = false;\n  const sanitizedLines = [];\n  for (let i = 0; i < lines.length; i++) {\n    const line = lines[i];\n    const lastLine = sanitizedLines[sanitizedLines.length - 1];\n\n    // Code blocks of ```single line``` don't toggle the inCodeBlock flag\n    if (CODE_SINGLE_LINE_REGEX.test(line)) {\n      sanitizedLines.push(line);\n      continue;\n    }\n\n    // Detect the start or end of a code block\n    if (CODE_START_REGEX.test(line) || CODE_END_REGEX.test(line)) {\n      inCodeBlock = !inCodeBlock;\n      sanitizedLines.push(line);\n      continue;\n    }\n\n    // If we are inside a code block, keep the line unchanged\n    if (inCodeBlock) {\n      sanitizedLines.push(line);\n      continue;\n    }\n\n    // In markdown the concept of \"empty paragraphs\" does not exist.\n    // Blocks must be separated by an empty line. Non-empty adjacent lines must be merged.\n    if (line === '' || lastLine === '' || !lastLine || HEADING_REGEX.test(lastLine) || HEADING_REGEX.test(line) || QUOTE_REGEX.test(line) || ORDERED_LIST_REGEX.test(line) || UNORDERED_LIST_REGEX.test(line) || CHECK_LIST_REGEX.test(line) || TABLE_ROW_REG_EXP.test(line) || TABLE_ROW_DIVIDER_REG_EXP.test(line) || !shouldMergeAdjacentLines) {\n      sanitizedLines.push(line);\n    } else {\n      sanitizedLines[sanitizedLines.length - 1] = lastLine + line;\n    }\n  }\n  return sanitizedLines.join('\\n');\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst ELEMENT_TRANSFORMERS = [HEADING, QUOTE, UNORDERED_LIST, ORDERED_LIST];\nconst MULTILINE_ELEMENT_TRANSFORMERS = [CODE];\n\n// Order of text format transformers matters:\n//\n// - code should go first as it prevents any transformations inside\n// - then longer tags match (e.g. ** or __ should go before * or _)\nconst TEXT_FORMAT_TRANSFORMERS = [INLINE_CODE, BOLD_ITALIC_STAR, BOLD_ITALIC_UNDERSCORE, BOLD_STAR, BOLD_UNDERSCORE, HIGHLIGHT, ITALIC_STAR, ITALIC_UNDERSCORE, STRIKETHROUGH];\nconst TEXT_MATCH_TRANSFORMERS = [LINK];\nconst TRANSFORMERS = [...ELEMENT_TRANSFORMERS, ...MULTILINE_ELEMENT_TRANSFORMERS, ...TEXT_FORMAT_TRANSFORMERS, ...TEXT_MATCH_TRANSFORMERS];\n\n/**\n * Renders markdown from a string. The selection is moved to the start after the operation.\n *\n *  @param {boolean} [shouldPreserveNewLines] By setting this to true, new lines will be preserved between conversions\n *  @param {boolean} [shouldMergeAdjacentLines] By setting this to true, adjacent non empty lines will be merged according to commonmark spec: https://spec.commonmark.org/0.24/#example-177. Not applicable if shouldPreserveNewLines = true.\n */\nfunction $convertFromMarkdownString(markdown, transformers = TRANSFORMERS, node, shouldPreserveNewLines = false, shouldMergeAdjacentLines = false) {\n  const sanitizedMarkdown = shouldPreserveNewLines ? markdown : normalizeMarkdown(markdown, shouldMergeAdjacentLines);\n  const importMarkdown = createMarkdownImport(transformers, shouldPreserveNewLines);\n  return importMarkdown(sanitizedMarkdown, node);\n}\n\n/**\n * Renders string from markdown. The selection is moved to the start after the operation.\n */\nfunction $convertToMarkdownString(transformers = TRANSFORMERS, node, shouldPreserveNewLines = false) {\n  const exportMarkdown = createMarkdownExport(transformers, shouldPreserveNewLines);\n  return exportMarkdown(node);\n}\nexport { $convertFromMarkdownString, $convertToMarkdownString, BOLD_ITALIC_STAR, BOLD_ITALIC_UNDERSCORE, BOLD_STAR, BOLD_UNDERSCORE, CHECK_LIST, CODE, ELEMENT_TRANSFORMERS, HEADING, HIGHLIGHT, INLINE_CODE, ITALIC_STAR, ITALIC_UNDERSCORE, LINK, MULTILINE_ELEMENT_TRANSFORMERS, ORDERED_LIST, QUOTE, STRIKETHROUGH, TEXT_FORMAT_TRANSFORMERS, TEXT_MATCH_TRANSFORMERS, TRANSFORMERS, UNORDERED_LIST, registerMarkdownShortcuts };","map":{"version":3,"names":["$isParagraphNode","$isTextNode","$getRoot","$isElementNode","$isDecoratorNode","$isLineBreakNode","$getSelection","$createTextNode","$createParagraphNode","$createLineBreakNode","COLLABORATION_TAG","HISTORIC_TAG","$isRangeSelection","$isRootOrShadowRoot","$createRangeSelection","$setSelection","$isListNode","$isListItemNode","ListNode","ListItemNode","$createListItemNode","$createListNode","$isQuoteNode","HeadingNode","$isHeadingNode","QuoteNode","$createQuoteNode","$createHeadingNode","$findMatchingParent","$isCodeNode","CodeNode","$createCodeNode","LinkNode","$isLinkNode","$isAutoLinkNode","$createLinkNode","indexBy","list","callback","index","item","key","push","transformersByType","transformers","byType","t","type","element","multilineElement","textFormat","textMatch","PUNCTUATION_OR_SPACE","MARKDOWN_EMPTY_LINE_REG_EXP","isEmptyParagraph","node","firstChild","getFirstChild","getChildrenSize","test","getTextContent","createMarkdownExport","shouldPreserveNewLines","elementTransformers","isNewlineDelimited","textFormatTransformers","filter","transformer","format","length","sort","a","b","Number","includes","output","children","getChildren","i","child","result","exportTopLevelElements","concat","join","textTransformersIndex","textMatchTransformers","export","_node","exportChildren","unclosedTags","unclosableTags","mainLoop","parentNode","textNode","textContent","exportTextFormat","textTransformers","getFormat","escapeLeadingAndTrailingWhitespaces","hasFormat","replace","openingTags","closingTagsBefore","closingTagsAfter","prevNode","getTextSibling","nextNode","applied","Set","tag","has","add","find","nodeHasFormat","nextNodeHasFormat","unhandledUnclosedTags","unclosedTag","pop","backward","sibling","getPreviousSibling","getNextSibling","parent","getParentOrThrow","isInline","descendant","getLastDescendant","getFirstDescendant","match","map","char","codePointAt","findOutermostTextFormatTransformer","textFormatTransformersIndex","findOutermostMatch","textFormatMatchStart","textFormatMatchEnd","transformersByTag","endIndex","startIndex","openTagsMatch","openTagsRegExp","fullMatchRegExp","fullMatchRegExpByTag","fullMatch","intraword","beforeChar","afterChar","importTextFormatTransformer","transformedNode","nodeAfter","nodeBefore","splitText","setTextContent","toggleFormat","findOutermostTextMatchTransformer","textNode_","foundMatchStartIndex","undefined","foundMatchEndIndex","foundMatchTransformer","foundMatch","importRegExp","getEndIndex","importFoundTextMatchTransformer","potentialTransformedNode","canContainTransformableMarkdown","importTextTransformers","foundTextFormat","foundTextMatch","escapedText","_","codePoint","String","fromCodePoint","createMarkdownImport","createTextFormatTransformersIndex","markdownString","lines","split","linesLength","root","clear","lineText","imported","shiftedIndex","$importMultiline","$importBlocks","remove","selectStart","startLineIndex","multilineElementTransformers","rootNode","handleImportAfterStartMatch","regExpEnd","regExpStart","startMatch","regexpEndRegex","regExp","isEndOptional","optional","endLineIndex","endMatch","linesInBetween","slice","text","elementNode","append","isAttached","previousNode","targetNode","lastDescendant","getTextContentSize","splice","escapeRegExp","tagRegExp","RegExp","formatDevErrorMessage","message","Error","runElementTransformers","anchorNode","anchorOffset","grandParentNode","getParent","endsWith","nextSiblings","getNextSiblings","leadingNode","remainderNode","siblings","runMultilineElementTransformers","runTextMatchTransformers","transformersByTrigger","lastChar","replaceNode","selectNext","$runTextFormatTransformers","closeTagEndIndex","closeChar","matchers","matcher","tagLength","closeTagStartIndex","isEqualSubString","afterCloseTagChar","closeNode","openNode","openTagStartIndex","getOpenTagStartIndex","siblingTextContent","prevOpenNodeText","beforeOpenTagChar","prevCloseNodeText","closeNodeText","openNodeText","selection","nextSelection","newOffset","anchor","set","__key","focus","formatText","offset","string","maxIndex","stringA","aStart","stringB","bStart","registerMarkdownShortcuts","editor","TRANSFORMERS","textFormatTransformersByTrigger","textMatchTransformersByTrigger","trigger","dependencies","hasNode","getType","$transform","registerUpdateListener","tags","dirtyLeaves","editorState","prevEditorState","isComposing","read","prevSelection","isCollapsed","is","anchorKey","_nodeMap","get","update","ORDERED_LIST_REGEX","UNORDERED_LIST_REGEX","CHECK_LIST_REGEX","HEADING_REGEX","QUOTE_REGEX","CODE_START_REGEX","CODE_END_REGEX","CODE_SINGLE_LINE_REGEX","TABLE_ROW_REG_EXP","TABLE_ROW_DIVIDER_REG_EXP","createBlockNode","createNode","isImport","select","LIST_INDENT_SIZE","getIndent","whitespaces","tabs","spaces","indent","Math","floor","listReplace","listType","listItem","getListType","insertBefore","setIndent","listExport","listNode","depth","listItemNode","repeat","prefix","getStart","getChecked","HEADING","level","getTag","QUOTE","line","_match","CODE","getLanguage","codeBlockNode","code","startsWith","trim","shift","UNORDERED_LIST","CHECK_LIST","ORDERED_LIST","INLINE_CODE","HIGHLIGHT","BOLD_ITALIC_STAR","BOLD_ITALIC_UNDERSCORE","BOLD_STAR","BOLD_UNDERSCORE","STRIKETHROUGH","ITALIC_STAR","ITALIC_UNDERSCORE","LINK","exportFormat","title","getTitle","linkContent","getURL","linkText","linkUrl","linkTitle","linkNode","linkTextNode","setFormat","normalizeMarkdown","input","shouldMergeAdjacentLines","inCodeBlock","sanitizedLines","lastLine","ELEMENT_TRANSFORMERS","MULTILINE_ELEMENT_TRANSFORMERS","TEXT_FORMAT_TRANSFORMERS","TEXT_MATCH_TRANSFORMERS","$convertFromMarkdownString","markdown","sanitizedMarkdown","importMarkdown","$convertToMarkdownString","exportMarkdown"],"sources":["C:/Code/beedoo/node_modules/@lexical/markdown/LexicalMarkdown.dev.mjs"],"sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport { $isParagraphNode, $isTextNode, $getRoot, $isElementNode, $isDecoratorNode, $isLineBreakNode, $getSelection, $createTextNode, $createParagraphNode, $createLineBreakNode, COLLABORATION_TAG, HISTORIC_TAG, $isRangeSelection, $isRootOrShadowRoot, $createRangeSelection, $setSelection } from 'lexical';\nimport { $isListNode, $isListItemNode, ListNode, ListItemNode, $createListItemNode, $createListNode } from '@lexical/list';\nimport { $isQuoteNode, HeadingNode, $isHeadingNode, QuoteNode, $createQuoteNode, $createHeadingNode } from '@lexical/rich-text';\nimport { $findMatchingParent } from '@lexical/utils';\nimport { $isCodeNode, CodeNode, $createCodeNode } from '@lexical/code';\nimport { LinkNode, $isLinkNode, $isAutoLinkNode, $createLinkNode } from '@lexical/link';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction indexBy(list, callback) {\n  const index = {};\n  for (const item of list) {\n    const key = callback(item);\n    if (!key) {\n      continue;\n    }\n    if (index[key]) {\n      index[key].push(item);\n    } else {\n      index[key] = [item];\n    }\n  }\n  return index;\n}\nfunction transformersByType(transformers) {\n  const byType = indexBy(transformers, t => t.type);\n  return {\n    element: byType.element || [],\n    multilineElement: byType['multiline-element'] || [],\n    textFormat: byType['text-format'] || [],\n    textMatch: byType['text-match'] || []\n  };\n}\nconst PUNCTUATION_OR_SPACE = /[!-/:-@[-`{-~\\s]/;\nconst MARKDOWN_EMPTY_LINE_REG_EXP = /^\\s{0,3}$/;\nfunction isEmptyParagraph(node) {\n  if (!$isParagraphNode(node)) {\n    return false;\n  }\n  const firstChild = node.getFirstChild();\n  return firstChild == null || node.getChildrenSize() === 1 && $isTextNode(firstChild) && MARKDOWN_EMPTY_LINE_REG_EXP.test(firstChild.getTextContent());\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n/**\n * Renders string from markdown. The selection is moved to the start after the operation.\n */\nfunction createMarkdownExport(transformers, shouldPreserveNewLines = false) {\n  const byType = transformersByType(transformers);\n  const elementTransformers = [...byType.multilineElement, ...byType.element];\n  const isNewlineDelimited = !shouldPreserveNewLines;\n\n  // Export only uses text formats that are responsible for single format\n  // e.g. it will filter out *** (bold, italic) and instead use separate ** and *\n  const textFormatTransformers = byType.textFormat.filter(transformer => transformer.format.length === 1)\n  // Make sure all text transformers that contain 'code' in their format are at the end of the array. Otherwise, formatted code like\n  // <strong><code>code</code></strong> will be exported as `**Bold Code**`, as the code format will be applied first, and the bold format\n  // will be applied second and thus skipped entirely, as the code format will prevent any further formatting.\n  .sort((a, b) => {\n    return Number(a.format.includes('code')) - Number(b.format.includes('code'));\n  });\n  return node => {\n    const output = [];\n    const children = (node || $getRoot()).getChildren();\n    for (let i = 0; i < children.length; i++) {\n      const child = children[i];\n      const result = exportTopLevelElements(child, elementTransformers, textFormatTransformers, byType.textMatch);\n      if (result != null) {\n        output.push(\n        // separate consecutive group of texts with a line break: eg. [\"hello\", \"world\"] -> [\"hello\", \"/nworld\"]\n        isNewlineDelimited && i > 0 && !isEmptyParagraph(child) && !isEmptyParagraph(children[i - 1]) ? '\\n'.concat(result) : result);\n      }\n    }\n    // Ensure consecutive groups of texts are at least \\n\\n apart while each empty paragraph render as a newline.\n    // Eg. [\"hello\", \"\", \"\", \"hi\", \"\\nworld\"] -> \"hello\\n\\n\\nhi\\n\\nworld\"\n    return output.join('\\n');\n  };\n}\nfunction exportTopLevelElements(node, elementTransformers, textTransformersIndex, textMatchTransformers) {\n  for (const transformer of elementTransformers) {\n    if (!transformer.export) {\n      continue;\n    }\n    const result = transformer.export(node, _node => exportChildren(_node, textTransformersIndex, textMatchTransformers));\n    if (result != null) {\n      return result;\n    }\n  }\n  if ($isElementNode(node)) {\n    return exportChildren(node, textTransformersIndex, textMatchTransformers);\n  } else if ($isDecoratorNode(node)) {\n    return node.getTextContent();\n  } else {\n    return null;\n  }\n}\nfunction exportChildren(node, textTransformersIndex, textMatchTransformers, unclosedTags, unclosableTags) {\n  const output = [];\n  const children = node.getChildren();\n  // keep track of unclosed tags from the very beginning\n  if (!unclosedTags) {\n    unclosedTags = [];\n  }\n  if (!unclosableTags) {\n    unclosableTags = [];\n  }\n  mainLoop: for (const child of children) {\n    for (const transformer of textMatchTransformers) {\n      if (!transformer.export) {\n        continue;\n      }\n      const result = transformer.export(child, parentNode => exportChildren(parentNode, textTransformersIndex, textMatchTransformers, unclosedTags,\n      // Add current unclosed tags to the list of unclosable tags - we don't want nested tags from\n      // textmatch transformers to close the outer ones, as that may result in invalid markdown.\n      // E.g. **text [text**](https://lexical.io)\n      // is invalid markdown, as the closing ** is inside the link.\n      //\n      [...unclosableTags, ...unclosedTags]), (textNode, textContent) => exportTextFormat(textNode, textContent, textTransformersIndex, unclosedTags, unclosableTags));\n      if (result != null) {\n        output.push(result);\n        continue mainLoop;\n      }\n    }\n    if ($isLineBreakNode(child)) {\n      output.push('\\n');\n    } else if ($isTextNode(child)) {\n      output.push(exportTextFormat(child, child.getTextContent(), textTransformersIndex, unclosedTags, unclosableTags));\n    } else if ($isElementNode(child)) {\n      // empty paragraph returns \"\"\n      output.push(exportChildren(child, textTransformersIndex, textMatchTransformers, unclosedTags, unclosableTags));\n    } else if ($isDecoratorNode(child)) {\n      output.push(child.getTextContent());\n    }\n  }\n  return output.join('');\n}\nfunction exportTextFormat(node, textContent, textTransformers,\n// unclosed tags include the markdown tags that haven't been closed yet, and their associated formats\nunclosedTags, unclosableTags) {\n  // This function handles the case of a string looking like this: \"   foo   \"\n  // Where it would be invalid markdown to generate: \"**   foo   **\"\n  // If the node has no format, we use the original text.\n  // Otherwise, we escape leading and trailing whitespaces to their corresponding code points,\n  // ensuring the returned string maintains its original formatting, e.g., \"**&#32;&#32;&#32;foo&#32;&#32;&#32;**\".\n  let output = node.getFormat() === 0 ? textContent : escapeLeadingAndTrailingWhitespaces(textContent);\n  if (!node.hasFormat('code')) {\n    // Escape any markdown characters in the text content\n    output = output.replace(/([*_`~\\\\])/g, '\\\\$1');\n  }\n\n  // the opening tags to be added to the result\n  let openingTags = '';\n  // the closing tags to be added to the result\n  let closingTagsBefore = '';\n  let closingTagsAfter = '';\n  const prevNode = getTextSibling(node, true);\n  const nextNode = getTextSibling(node, false);\n  const applied = new Set();\n  for (const transformer of textTransformers) {\n    const format = transformer.format[0];\n    const tag = transformer.tag;\n\n    // dedup applied formats\n    if (hasFormat(node, format) && !applied.has(format)) {\n      // Multiple tags might be used for the same format (*, _)\n      applied.add(format);\n\n      // append the tag to openingTags, if it's not applied to the previous nodes,\n      // or the nodes before that (which would result in an unclosed tag)\n      if (!hasFormat(prevNode, format) || !unclosedTags.find(element => element.tag === tag)) {\n        unclosedTags.push({\n          format,\n          tag\n        });\n        openingTags += tag;\n      }\n    }\n  }\n\n  // close any tags in the same order they were applied, if necessary\n  for (let i = 0; i < unclosedTags.length; i++) {\n    const nodeHasFormat = hasFormat(node, unclosedTags[i].format);\n    const nextNodeHasFormat = hasFormat(nextNode, unclosedTags[i].format);\n\n    // prevent adding closing tag if next sibling will do it\n    if (nodeHasFormat && nextNodeHasFormat) {\n      continue;\n    }\n    const unhandledUnclosedTags = [...unclosedTags]; // Shallow copy to avoid modifying the original array\n\n    while (unhandledUnclosedTags.length > i) {\n      const unclosedTag = unhandledUnclosedTags.pop();\n\n      // If tag is unclosable, don't close it and leave it in the original array,\n      // So that it can be closed when it's no longer unclosable\n      if (unclosableTags && unclosedTag && unclosableTags.find(element => element.tag === unclosedTag.tag)) {\n        continue;\n      }\n      if (unclosedTag && typeof unclosedTag.tag === 'string') {\n        if (!nodeHasFormat) {\n          // Handles cases where the tag has not been closed before, e.g. if the previous node\n          // was a text match transformer that did not account for closing tags of the next node (e.g. a link)\n          closingTagsBefore += unclosedTag.tag;\n        } else if (!nextNodeHasFormat) {\n          closingTagsAfter += unclosedTag.tag;\n        }\n      }\n      // Mutate the original array to remove the closed tag\n      unclosedTags.pop();\n    }\n    break;\n  }\n  output = openingTags + output + closingTagsAfter;\n  // Replace trimmed version of textContent ensuring surrounding whitespace is not modified\n  return closingTagsBefore + output;\n}\n\n// Get next or previous text sibling a text node, including cases\n// when it's a child of inline element (e.g. link)\nfunction getTextSibling(node, backward) {\n  let sibling = backward ? node.getPreviousSibling() : node.getNextSibling();\n  if (!sibling) {\n    const parent = node.getParentOrThrow();\n    if (parent.isInline()) {\n      sibling = backward ? parent.getPreviousSibling() : parent.getNextSibling();\n    }\n  }\n  while (sibling) {\n    if ($isElementNode(sibling)) {\n      if (!sibling.isInline()) {\n        break;\n      }\n      const descendant = backward ? sibling.getLastDescendant() : sibling.getFirstDescendant();\n      if ($isTextNode(descendant)) {\n        return descendant;\n      } else {\n        sibling = backward ? sibling.getPreviousSibling() : sibling.getNextSibling();\n      }\n    }\n    if ($isTextNode(sibling)) {\n      return sibling;\n    }\n    if (!$isElementNode(sibling)) {\n      return null;\n    }\n  }\n  return null;\n}\nfunction hasFormat(node, format) {\n  return $isTextNode(node) && node.hasFormat(format);\n}\nfunction escapeLeadingAndTrailingWhitespaces(textContent) {\n  return textContent.replace(/^\\s+|\\s+$/g, match => {\n    return [...match].map(char => '&#' + char.codePointAt(0) + ';').join('');\n  });\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction findOutermostTextFormatTransformer(textNode, textFormatTransformersIndex) {\n  const textContent = textNode.getTextContent();\n  const match = findOutermostMatch(textContent, textFormatTransformersIndex);\n  if (!match) {\n    return null;\n  }\n  const textFormatMatchStart = match.index || 0;\n  const textFormatMatchEnd = textFormatMatchStart + match[0].length;\n  const transformer = textFormatTransformersIndex.transformersByTag[match[1]];\n  return {\n    endIndex: textFormatMatchEnd,\n    match,\n    startIndex: textFormatMatchStart,\n    transformer\n  };\n}\n\n// Finds first \"<tag>content<tag>\" match that is not nested into another tag\nfunction findOutermostMatch(textContent, textTransformersIndex) {\n  const openTagsMatch = textContent.match(textTransformersIndex.openTagsRegExp);\n  if (openTagsMatch == null) {\n    return null;\n  }\n  for (const match of openTagsMatch) {\n    // Open tags reg exp might capture leading space so removing it\n    // before using match to find transformer\n    const tag = match.replace(/^\\s/, '');\n    const fullMatchRegExp = textTransformersIndex.fullMatchRegExpByTag[tag];\n    if (fullMatchRegExp == null) {\n      continue;\n    }\n    const fullMatch = textContent.match(fullMatchRegExp);\n    const transformer = textTransformersIndex.transformersByTag[tag];\n    if (fullMatch != null && transformer != null) {\n      if (transformer.intraword !== false) {\n        return fullMatch;\n      }\n\n      // For non-intraword transformers checking if it's within a word\n      // or surrounded with space/punctuation/newline\n      const {\n        index = 0\n      } = fullMatch;\n      const beforeChar = textContent[index - 1];\n      const afterChar = textContent[index + fullMatch[0].length];\n      if ((!beforeChar || PUNCTUATION_OR_SPACE.test(beforeChar)) && (!afterChar || PUNCTUATION_OR_SPACE.test(afterChar))) {\n        return fullMatch;\n      }\n    }\n  }\n  return null;\n}\nfunction importTextFormatTransformer(textNode, startIndex, endIndex, transformer, match) {\n  const textContent = textNode.getTextContent();\n\n  // No text matches - we can safely process the text format match\n  let transformedNode, nodeAfter, nodeBefore;\n\n  // If matching full content there's no need to run splitText and can reuse existing textNode\n  // to update its content and apply format. E.g. for **_Hello_** string after applying bold\n  // format (**) it will reuse the same text node to apply italic (_)\n  if (match[0] === textContent) {\n    transformedNode = textNode;\n  } else {\n    if (startIndex === 0) {\n      [transformedNode, nodeAfter] = textNode.splitText(endIndex);\n    } else {\n      [nodeBefore, transformedNode, nodeAfter] = textNode.splitText(startIndex, endIndex);\n    }\n  }\n  transformedNode.setTextContent(match[2]);\n  if (transformer) {\n    for (const format of transformer.format) {\n      if (!transformedNode.hasFormat(format)) {\n        transformedNode.toggleFormat(format);\n      }\n    }\n  }\n  return {\n    nodeAfter: nodeAfter,\n    nodeBefore: nodeBefore,\n    transformedNode: transformedNode\n  };\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction findOutermostTextMatchTransformer(textNode_, textMatchTransformers) {\n  const textNode = textNode_;\n  let foundMatchStartIndex = undefined;\n  let foundMatchEndIndex = undefined;\n  let foundMatchTransformer = undefined;\n  let foundMatch = undefined;\n  for (const transformer of textMatchTransformers) {\n    if (!transformer.replace || !transformer.importRegExp) {\n      continue;\n    }\n    const match = textNode.getTextContent().match(transformer.importRegExp);\n    if (!match) {\n      continue;\n    }\n    const startIndex = match.index || 0;\n    const endIndex = transformer.getEndIndex ? transformer.getEndIndex(textNode, match) : startIndex + match[0].length;\n    if (endIndex === false) {\n      continue;\n    }\n    if (foundMatchStartIndex === undefined || foundMatchEndIndex === undefined || startIndex < foundMatchStartIndex && endIndex > foundMatchEndIndex) {\n      foundMatchStartIndex = startIndex;\n      foundMatchEndIndex = endIndex;\n      foundMatchTransformer = transformer;\n      foundMatch = match;\n    }\n  }\n  if (foundMatchStartIndex === undefined || foundMatchEndIndex === undefined || foundMatchTransformer === undefined || foundMatch === undefined) {\n    return null;\n  }\n  return {\n    endIndex: foundMatchEndIndex,\n    match: foundMatch,\n    startIndex: foundMatchStartIndex,\n    transformer: foundMatchTransformer\n  };\n}\nfunction importFoundTextMatchTransformer(textNode, startIndex, endIndex, transformer, match) {\n  let transformedNode, nodeAfter, nodeBefore;\n  if (startIndex === 0) {\n    [transformedNode, nodeAfter] = textNode.splitText(endIndex);\n  } else {\n    [nodeBefore, transformedNode, nodeAfter] = textNode.splitText(startIndex, endIndex);\n  }\n  if (!transformer.replace) {\n    return null;\n  }\n  const potentialTransformedNode = transformer.replace(transformedNode, match);\n  return {\n    nodeAfter,\n    nodeBefore,\n    transformedNode: potentialTransformedNode || undefined\n  };\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n/**\n * Returns true if the node can contain transformable markdown.\n * Code nodes cannot contain transformable markdown.\n * For example, `code **bold**` should not be transformed to\n * <code>code <strong>bold</strong></code>.\n */\nfunction canContainTransformableMarkdown(node) {\n  return $isTextNode(node) && !node.hasFormat('code');\n}\n\n/**\n * Handles applying both text format and text match transformers.\n * It finds the outermost text format or text match and applies it,\n * then recursively calls itself to apply the next outermost transformer,\n * until there are no more transformers to apply.\n */\nfunction importTextTransformers(textNode, textFormatTransformersIndex, textMatchTransformers) {\n  let foundTextFormat = findOutermostTextFormatTransformer(textNode, textFormatTransformersIndex);\n  let foundTextMatch = findOutermostTextMatchTransformer(textNode, textMatchTransformers);\n  if (foundTextFormat && foundTextMatch) {\n    // Find the outermost transformer\n    if (foundTextFormat.startIndex <= foundTextMatch.startIndex && foundTextFormat.endIndex >= foundTextMatch.endIndex) {\n      // foundTextFormat wraps foundTextMatch - apply foundTextFormat by setting foundTextMatch to null\n      foundTextMatch = null;\n    } else {\n      // foundTextMatch wraps foundTextFormat - apply foundTextMatch by setting foundTextFormat to null\n      foundTextFormat = null;\n    }\n  }\n  if (foundTextFormat) {\n    const result = importTextFormatTransformer(textNode, foundTextFormat.startIndex, foundTextFormat.endIndex, foundTextFormat.transformer, foundTextFormat.match);\n    if (canContainTransformableMarkdown(result.nodeAfter)) {\n      importTextTransformers(result.nodeAfter, textFormatTransformersIndex, textMatchTransformers);\n    }\n    if (canContainTransformableMarkdown(result.nodeBefore)) {\n      importTextTransformers(result.nodeBefore, textFormatTransformersIndex, textMatchTransformers);\n    }\n    if (canContainTransformableMarkdown(result.transformedNode)) {\n      importTextTransformers(result.transformedNode, textFormatTransformersIndex, textMatchTransformers);\n    }\n  } else if (foundTextMatch) {\n    const result = importFoundTextMatchTransformer(textNode, foundTextMatch.startIndex, foundTextMatch.endIndex, foundTextMatch.transformer, foundTextMatch.match);\n    if (!result) {\n      return;\n    }\n    if (canContainTransformableMarkdown(result.nodeAfter)) {\n      importTextTransformers(result.nodeAfter, textFormatTransformersIndex, textMatchTransformers);\n    }\n    if (canContainTransformableMarkdown(result.nodeBefore)) {\n      importTextTransformers(result.nodeBefore, textFormatTransformersIndex, textMatchTransformers);\n    }\n    if (canContainTransformableMarkdown(result.transformedNode)) {\n      importTextTransformers(result.transformedNode, textFormatTransformersIndex, textMatchTransformers);\n    }\n  }\n\n  // Handle escape characters\n  const textContent = textNode.getTextContent();\n  const escapedText = textContent.replace(/\\\\([*_`~\\\\])/g, '$1').replace(/&#(\\d+);/g, (_, codePoint) => {\n    return String.fromCodePoint(codePoint);\n  });\n  textNode.setTextContent(escapedText);\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/**\n * Renders markdown from a string. The selection is moved to the start after the operation.\n */\nfunction createMarkdownImport(transformers, shouldPreserveNewLines = false) {\n  const byType = transformersByType(transformers);\n  const textFormatTransformersIndex = createTextFormatTransformersIndex(byType.textFormat);\n  return (markdownString, node) => {\n    const lines = markdownString.split('\\n');\n    const linesLength = lines.length;\n    const root = node || $getRoot();\n    root.clear();\n    for (let i = 0; i < linesLength; i++) {\n      const lineText = lines[i];\n      const [imported, shiftedIndex] = $importMultiline(lines, i, byType.multilineElement, root);\n      if (imported) {\n        // If a multiline markdown element was imported, we don't want to process the lines that were part of it anymore.\n        // There could be other sub-markdown elements (both multiline and normal ones) matching within this matched multiline element's children.\n        // However, it would be the responsibility of the matched multiline transformer to decide how it wants to handle them.\n        // We cannot handle those, as there is no way for us to know how to maintain the correct order of generated lexical nodes for possible children.\n        i = shiftedIndex; // Next loop will start from the line after the last line of the multiline element\n        continue;\n      }\n      $importBlocks(lineText, root, byType.element, textFormatTransformersIndex, byType.textMatch, shouldPreserveNewLines);\n    }\n\n    // By default, removing empty paragraphs as md does not really\n    // allow empty lines and uses them as delimiter.\n    // If you need empty lines set shouldPreserveNewLines = true.\n    const children = root.getChildren();\n    for (const child of children) {\n      if (!shouldPreserveNewLines && isEmptyParagraph(child) && root.getChildrenSize() > 1) {\n        child.remove();\n      }\n    }\n    if ($getSelection() !== null) {\n      root.selectStart();\n    }\n  };\n}\n\n/**\n *\n * @returns first element of the returned tuple is a boolean indicating if a multiline element was imported. The second element is the index of the last line that was processed.\n */\nfunction $importMultiline(lines, startLineIndex, multilineElementTransformers, rootNode) {\n  for (const transformer of multilineElementTransformers) {\n    const {\n      handleImportAfterStartMatch,\n      regExpEnd,\n      regExpStart,\n      replace\n    } = transformer;\n    const startMatch = lines[startLineIndex].match(regExpStart);\n    if (!startMatch) {\n      continue; // Try next transformer\n    }\n    if (handleImportAfterStartMatch) {\n      const result = handleImportAfterStartMatch({\n        lines,\n        rootNode,\n        startLineIndex,\n        startMatch,\n        transformer\n      });\n      if (result === null) {\n        continue;\n      } else if (result) {\n        return result;\n      }\n    }\n    const regexpEndRegex = typeof regExpEnd === 'object' && 'regExp' in regExpEnd ? regExpEnd.regExp : regExpEnd;\n    const isEndOptional = regExpEnd && typeof regExpEnd === 'object' && 'optional' in regExpEnd ? regExpEnd.optional : !regExpEnd;\n    let endLineIndex = startLineIndex;\n    const linesLength = lines.length;\n\n    // check every single line for the closing match. It could also be on the same line as the opening match.\n    while (endLineIndex < linesLength) {\n      const endMatch = regexpEndRegex ? lines[endLineIndex].match(regexpEndRegex) : null;\n      if (!endMatch) {\n        if (!isEndOptional || isEndOptional && endLineIndex < linesLength - 1 // Optional end, but didn't reach the end of the document yet => continue searching for potential closing match\n        ) {\n          endLineIndex++;\n          continue; // Search next line for closing match\n        }\n      }\n\n      // Now, check if the closing match matched is the same as the opening match.\n      // If it is, we need to continue searching for the actual closing match.\n      if (endMatch && startLineIndex === endLineIndex && endMatch.index === startMatch.index) {\n        endLineIndex++;\n        continue; // Search next line for closing match\n      }\n\n      // At this point, we have found the closing match. Next: calculate the lines in between open and closing match\n      // This should not include the matches themselves, and be split up by lines\n      const linesInBetween = [];\n      if (endMatch && startLineIndex === endLineIndex) {\n        linesInBetween.push(lines[startLineIndex].slice(startMatch[0].length, -endMatch[0].length));\n      } else {\n        for (let i = startLineIndex; i <= endLineIndex; i++) {\n          if (i === startLineIndex) {\n            const text = lines[i].slice(startMatch[0].length);\n            linesInBetween.push(text); // Also include empty text\n          } else if (i === endLineIndex && endMatch) {\n            const text = lines[i].slice(0, -endMatch[0].length);\n            linesInBetween.push(text); // Also include empty text\n          } else {\n            linesInBetween.push(lines[i]);\n          }\n        }\n      }\n      if (replace(rootNode, null, startMatch, endMatch, linesInBetween, true) !== false) {\n        // Return here. This $importMultiline function is run line by line and should only process a single multiline element at a time.\n        return [true, endLineIndex];\n      }\n\n      // The replace function returned false, despite finding the matching open and close tags => this transformer does not want to handle it.\n      // Thus, we continue letting the remaining transformers handle the passed lines of text from the beginning\n      break;\n    }\n  }\n\n  // No multiline transformer handled this line successfully\n  return [false, startLineIndex];\n}\nfunction $importBlocks(lineText, rootNode, elementTransformers, textFormatTransformersIndex, textMatchTransformers, shouldPreserveNewLines) {\n  const textNode = $createTextNode(lineText);\n  const elementNode = $createParagraphNode();\n  elementNode.append(textNode);\n  rootNode.append(elementNode);\n  for (const {\n    regExp,\n    replace\n  } of elementTransformers) {\n    const match = lineText.match(regExp);\n    if (match) {\n      textNode.setTextContent(lineText.slice(match[0].length));\n      if (replace(elementNode, [textNode], match, true) !== false) {\n        break;\n      }\n    }\n  }\n  importTextTransformers(textNode, textFormatTransformersIndex, textMatchTransformers);\n\n  // If no transformer found and we left with original paragraph node\n  // can check if its content can be appended to the previous node\n  // if it's a paragraph, quote or list\n  if (elementNode.isAttached() && lineText.length > 0) {\n    const previousNode = elementNode.getPreviousSibling();\n    if (!shouldPreserveNewLines && (\n    // Only append if we're not preserving newlines\n    $isParagraphNode(previousNode) || $isQuoteNode(previousNode) || $isListNode(previousNode))) {\n      let targetNode = previousNode;\n      if ($isListNode(previousNode)) {\n        const lastDescendant = previousNode.getLastDescendant();\n        if (lastDescendant == null) {\n          targetNode = null;\n        } else {\n          targetNode = $findMatchingParent(lastDescendant, $isListItemNode);\n        }\n      }\n      if (targetNode != null && targetNode.getTextContentSize() > 0) {\n        targetNode.splice(targetNode.getChildrenSize(), 0, [$createLineBreakNode(), ...elementNode.getChildren()]);\n        elementNode.remove();\n      }\n    }\n  }\n}\nfunction createTextFormatTransformersIndex(textTransformers) {\n  const transformersByTag = {};\n  const fullMatchRegExpByTag = {};\n  const openTagsRegExp = [];\n  const escapeRegExp = `(?<![\\\\\\\\])`;\n  for (const transformer of textTransformers) {\n    const {\n      tag\n    } = transformer;\n    transformersByTag[tag] = transformer;\n    const tagRegExp = tag.replace(/(\\*|\\^|\\+)/g, '\\\\$1');\n    openTagsRegExp.push(tagRegExp);\n\n    // Single-char tag (e.g. \"*\"),\n    if (tag.length === 1) {\n      fullMatchRegExpByTag[tag] = new RegExp(`(?<![\\\\\\\\${tagRegExp}])(${tagRegExp})((\\\\\\\\${tagRegExp})?.*?[^${tagRegExp}\\\\s](\\\\\\\\${tagRegExp})?)((?<!\\\\\\\\)|(?<=\\\\\\\\\\\\\\\\))(${tagRegExp})(?![\\\\\\\\${tagRegExp}])`);\n    } else {\n      // Multiâ€char tags (e.g. \"**\")\n      fullMatchRegExpByTag[tag] = new RegExp(`(?<!\\\\\\\\)(${tagRegExp})((\\\\\\\\${tagRegExp})?.*?[^\\\\s](\\\\\\\\${tagRegExp})?)((?<!\\\\\\\\)|(?<=\\\\\\\\\\\\\\\\))(${tagRegExp})(?!\\\\\\\\)`);\n    }\n  }\n  return {\n    // Reg exp to find open tag + content + close tag\n    fullMatchRegExpByTag,\n    // Regexp to locate *any* potential opening tag (longest first).\n    openTagsRegExp: new RegExp(`${escapeRegExp}(${openTagsRegExp.join('|')})`, 'g'),\n    transformersByTag\n  };\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n// Do not require this module directly! Use normal `invariant` calls.\n\nfunction formatDevErrorMessage(message) {\n  throw new Error(message);\n}\n\nfunction runElementTransformers(parentNode, anchorNode, anchorOffset, elementTransformers) {\n  const grandParentNode = parentNode.getParent();\n  if (!$isRootOrShadowRoot(grandParentNode) || parentNode.getFirstChild() !== anchorNode) {\n    return false;\n  }\n  const textContent = anchorNode.getTextContent();\n\n  // Checking for anchorOffset position to prevent any checks for cases when caret is too far\n  // from a line start to be a part of block-level markdown trigger.\n  //\n  // TODO:\n  // Can have a quick check if caret is close enough to the beginning of the string (e.g. offset less than 10-20)\n  // since otherwise it won't be a markdown shortcut, but tables are exception\n  if (textContent[anchorOffset - 1] !== ' ') {\n    return false;\n  }\n  for (const {\n    regExp,\n    replace\n  } of elementTransformers) {\n    const match = textContent.match(regExp);\n    if (match && match[0].length === (match[0].endsWith(' ') ? anchorOffset : anchorOffset - 1)) {\n      const nextSiblings = anchorNode.getNextSiblings();\n      const [leadingNode, remainderNode] = anchorNode.splitText(anchorOffset);\n      const siblings = remainderNode ? [remainderNode, ...nextSiblings] : nextSiblings;\n      if (replace(parentNode, siblings, match, false) !== false) {\n        leadingNode.remove();\n        return true;\n      }\n    }\n  }\n  return false;\n}\nfunction runMultilineElementTransformers(parentNode, anchorNode, anchorOffset, elementTransformers) {\n  const grandParentNode = parentNode.getParent();\n  if (!$isRootOrShadowRoot(grandParentNode) || parentNode.getFirstChild() !== anchorNode) {\n    return false;\n  }\n  const textContent = anchorNode.getTextContent();\n\n  // Checking for anchorOffset position to prevent any checks for cases when caret is too far\n  // from a line start to be a part of block-level markdown trigger.\n  //\n  // TODO:\n  // Can have a quick check if caret is close enough to the beginning of the string (e.g. offset less than 10-20)\n  // since otherwise it won't be a markdown shortcut, but tables are exception\n  if (textContent[anchorOffset - 1] !== ' ') {\n    return false;\n  }\n  for (const {\n    regExpStart,\n    replace,\n    regExpEnd\n  } of elementTransformers) {\n    if (regExpEnd && !('optional' in regExpEnd) || regExpEnd && 'optional' in regExpEnd && !regExpEnd.optional) {\n      continue;\n    }\n    const match = textContent.match(regExpStart);\n    if (match && match[0].length === (match[0].endsWith(' ') ? anchorOffset : anchorOffset - 1)) {\n      const nextSiblings = anchorNode.getNextSiblings();\n      const [leadingNode, remainderNode] = anchorNode.splitText(anchorOffset);\n      const siblings = remainderNode ? [remainderNode, ...nextSiblings] : nextSiblings;\n      if (replace(parentNode, siblings, match, null, null, false) !== false) {\n        leadingNode.remove();\n        return true;\n      }\n    }\n  }\n  return false;\n}\nfunction runTextMatchTransformers(anchorNode, anchorOffset, transformersByTrigger) {\n  let textContent = anchorNode.getTextContent();\n  const lastChar = textContent[anchorOffset - 1];\n  const transformers = transformersByTrigger[lastChar];\n  if (transformers == null) {\n    return false;\n  }\n\n  // If typing in the middle of content, remove the tail to do\n  // reg exp match up to a string end (caret position)\n  if (anchorOffset < textContent.length) {\n    textContent = textContent.slice(0, anchorOffset);\n  }\n  for (const transformer of transformers) {\n    if (!transformer.replace || !transformer.regExp) {\n      continue;\n    }\n    const match = textContent.match(transformer.regExp);\n    if (match === null) {\n      continue;\n    }\n    const startIndex = match.index || 0;\n    const endIndex = startIndex + match[0].length;\n    let replaceNode;\n    if (startIndex === 0) {\n      [replaceNode] = anchorNode.splitText(endIndex);\n    } else {\n      [, replaceNode] = anchorNode.splitText(startIndex, endIndex);\n    }\n    replaceNode.selectNext(0, 0);\n    transformer.replace(replaceNode, match);\n    return true;\n  }\n  return false;\n}\nfunction $runTextFormatTransformers(anchorNode, anchorOffset, textFormatTransformers) {\n  const textContent = anchorNode.getTextContent();\n  const closeTagEndIndex = anchorOffset - 1;\n  const closeChar = textContent[closeTagEndIndex];\n  // Quick check if we're possibly at the end of inline markdown style\n  const matchers = textFormatTransformers[closeChar];\n  if (!matchers) {\n    return false;\n  }\n  for (const matcher of matchers) {\n    const {\n      tag\n    } = matcher;\n    const tagLength = tag.length;\n    const closeTagStartIndex = closeTagEndIndex - tagLength + 1;\n\n    // If tag is not single char check if rest of it matches with text content\n    if (tagLength > 1) {\n      if (!isEqualSubString(textContent, closeTagStartIndex, tag, 0, tagLength)) {\n        continue;\n      }\n    }\n\n    // Space before closing tag cancels inline markdown\n    if (textContent[closeTagStartIndex - 1] === ' ') {\n      continue;\n    }\n\n    // Some tags can not be used within words, hence should have newline/space/punctuation after it\n    const afterCloseTagChar = textContent[closeTagEndIndex + 1];\n    if (matcher.intraword === false && afterCloseTagChar && !PUNCTUATION_OR_SPACE.test(afterCloseTagChar)) {\n      continue;\n    }\n    const closeNode = anchorNode;\n    let openNode = closeNode;\n    let openTagStartIndex = getOpenTagStartIndex(textContent, closeTagStartIndex, tag);\n\n    // Go through text node siblings and search for opening tag\n    // if haven't found it within the same text node as closing tag\n    let sibling = openNode;\n    while (openTagStartIndex < 0 && (sibling = sibling.getPreviousSibling())) {\n      if ($isLineBreakNode(sibling)) {\n        break;\n      }\n      if ($isTextNode(sibling)) {\n        if (sibling.hasFormat('code')) {\n          continue;\n        }\n        const siblingTextContent = sibling.getTextContent();\n        openNode = sibling;\n        openTagStartIndex = getOpenTagStartIndex(siblingTextContent, siblingTextContent.length, tag);\n      }\n    }\n\n    // Opening tag is not found\n    if (openTagStartIndex < 0) {\n      continue;\n    }\n\n    // No content between opening and closing tag\n    if (openNode === closeNode && openTagStartIndex + tagLength === closeTagStartIndex) {\n      continue;\n    }\n\n    // Checking longer tags for repeating chars (e.g. *** vs **)\n    const prevOpenNodeText = openNode.getTextContent();\n    if (openTagStartIndex > 0 && prevOpenNodeText[openTagStartIndex - 1] === closeChar) {\n      continue;\n    }\n\n    // Some tags can not be used within words, hence should have newline/space/punctuation before it\n    const beforeOpenTagChar = prevOpenNodeText[openTagStartIndex - 1];\n    if (matcher.intraword === false && beforeOpenTagChar && !PUNCTUATION_OR_SPACE.test(beforeOpenTagChar)) {\n      continue;\n    }\n\n    // Clean text from opening and closing tags (starting from closing tag\n    // to prevent any offset shifts if we start from opening one)\n    const prevCloseNodeText = closeNode.getTextContent();\n    const closeNodeText = prevCloseNodeText.slice(0, closeTagStartIndex) + prevCloseNodeText.slice(closeTagEndIndex + 1);\n    closeNode.setTextContent(closeNodeText);\n    const openNodeText = openNode === closeNode ? closeNodeText : prevOpenNodeText;\n    openNode.setTextContent(openNodeText.slice(0, openTagStartIndex) + openNodeText.slice(openTagStartIndex + tagLength));\n    const selection = $getSelection();\n    const nextSelection = $createRangeSelection();\n    $setSelection(nextSelection);\n    // Adjust offset based on deleted chars\n    const newOffset = closeTagEndIndex - tagLength * (openNode === closeNode ? 2 : 1) + 1;\n    nextSelection.anchor.set(openNode.__key, openTagStartIndex, 'text');\n    nextSelection.focus.set(closeNode.__key, newOffset, 'text');\n\n    // Apply formatting to selected text\n    for (const format of matcher.format) {\n      if (!nextSelection.hasFormat(format)) {\n        nextSelection.formatText(format);\n      }\n    }\n\n    // Collapse selection up to the focus point\n    nextSelection.anchor.set(nextSelection.focus.key, nextSelection.focus.offset, nextSelection.focus.type);\n\n    // Remove formatting from collapsed selection\n    for (const format of matcher.format) {\n      if (nextSelection.hasFormat(format)) {\n        nextSelection.toggleFormat(format);\n      }\n    }\n    if ($isRangeSelection(selection)) {\n      nextSelection.format = selection.format;\n    }\n    return true;\n  }\n  return false;\n}\nfunction getOpenTagStartIndex(string, maxIndex, tag) {\n  const tagLength = tag.length;\n  for (let i = maxIndex; i >= tagLength; i--) {\n    const startIndex = i - tagLength;\n    if (isEqualSubString(string, startIndex, tag, 0, tagLength) &&\n    // Space after opening tag cancels transformation\n    string[startIndex + tagLength] !== ' ') {\n      return startIndex;\n    }\n  }\n  return -1;\n}\nfunction isEqualSubString(stringA, aStart, stringB, bStart, length) {\n  for (let i = 0; i < length; i++) {\n    if (stringA[aStart + i] !== stringB[bStart + i]) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction registerMarkdownShortcuts(editor, transformers = TRANSFORMERS) {\n  const byType = transformersByType(transformers);\n  const textFormatTransformersByTrigger = indexBy(byType.textFormat, ({\n    tag\n  }) => tag[tag.length - 1]);\n  const textMatchTransformersByTrigger = indexBy(byType.textMatch, ({\n    trigger\n  }) => trigger);\n  for (const transformer of transformers) {\n    const type = transformer.type;\n    if (type === 'element' || type === 'text-match' || type === 'multiline-element') {\n      const dependencies = transformer.dependencies;\n      for (const node of dependencies) {\n        if (!editor.hasNode(node)) {\n          {\n            formatDevErrorMessage(`MarkdownShortcuts: missing dependency ${node.getType()} for transformer. Ensure node dependency is included in editor initial config.`);\n          }\n        }\n      }\n    }\n  }\n  const $transform = (parentNode, anchorNode, anchorOffset) => {\n    if (runElementTransformers(parentNode, anchorNode, anchorOffset, byType.element)) {\n      return;\n    }\n    if (runMultilineElementTransformers(parentNode, anchorNode, anchorOffset, byType.multilineElement)) {\n      return;\n    }\n    if (runTextMatchTransformers(anchorNode, anchorOffset, textMatchTransformersByTrigger)) {\n      return;\n    }\n    $runTextFormatTransformers(anchorNode, anchorOffset, textFormatTransformersByTrigger);\n  };\n  return editor.registerUpdateListener(({\n    tags,\n    dirtyLeaves,\n    editorState,\n    prevEditorState\n  }) => {\n    // Ignore updates from collaboration and undo/redo (as changes already calculated)\n    if (tags.has(COLLABORATION_TAG) || tags.has(HISTORIC_TAG)) {\n      return;\n    }\n\n    // If editor is still composing (i.e. backticks) we must wait before the user confirms the key\n    if (editor.isComposing()) {\n      return;\n    }\n    const selection = editorState.read($getSelection);\n    const prevSelection = prevEditorState.read($getSelection);\n\n    // We expect selection to be a collapsed range and not match previous one (as we want\n    // to trigger transforms only as user types)\n    if (!$isRangeSelection(prevSelection) || !$isRangeSelection(selection) || !selection.isCollapsed() || selection.is(prevSelection)) {\n      return;\n    }\n    const anchorKey = selection.anchor.key;\n    const anchorOffset = selection.anchor.offset;\n    const anchorNode = editorState._nodeMap.get(anchorKey);\n    if (!$isTextNode(anchorNode) || !dirtyLeaves.has(anchorKey) || anchorOffset !== 1 && anchorOffset > prevSelection.anchor.offset + 1) {\n      return;\n    }\n    editor.update(() => {\n      if (!canContainTransformableMarkdown(anchorNode)) {\n        return;\n      }\n      const parentNode = anchorNode.getParent();\n      if (parentNode === null || $isCodeNode(parentNode)) {\n        return;\n      }\n      $transform(parentNode, anchorNode, selection.anchor.offset);\n    });\n  });\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst ORDERED_LIST_REGEX = /^(\\s*)(\\d{1,})\\.\\s/;\nconst UNORDERED_LIST_REGEX = /^(\\s*)[-*+]\\s/;\nconst CHECK_LIST_REGEX = /^(\\s*)(?:-\\s)?\\s?(\\[(\\s|x)?\\])\\s/i;\nconst HEADING_REGEX = /^(#{1,6})\\s/;\nconst QUOTE_REGEX = /^>\\s/;\nconst CODE_START_REGEX = /^[ \\t]*```([\\w-]+)?/;\nconst CODE_END_REGEX = /[ \\t]*```$/;\nconst CODE_SINGLE_LINE_REGEX = /^[ \\t]*```[^`]+(?:(?:`{1,2}|`{4,})[^`]+)*```(?:[^`]|$)/;\nconst TABLE_ROW_REG_EXP = /^(?:\\|)(.+)(?:\\|)\\s?$/;\nconst TABLE_ROW_DIVIDER_REG_EXP = /^(\\| ?:?-*:? ?)+\\|\\s?$/;\nconst createBlockNode = createNode => {\n  return (parentNode, children, match, isImport) => {\n    const node = createNode(match);\n    node.append(...children);\n    parentNode.replace(node);\n    if (!isImport) {\n      node.select(0, 0);\n    }\n  };\n};\n\n// Amount of spaces that define indentation level\n// TODO: should be an option\nconst LIST_INDENT_SIZE = 4;\nfunction getIndent(whitespaces) {\n  const tabs = whitespaces.match(/\\t/g);\n  const spaces = whitespaces.match(/ /g);\n  let indent = 0;\n  if (tabs) {\n    indent += tabs.length;\n  }\n  if (spaces) {\n    indent += Math.floor(spaces.length / LIST_INDENT_SIZE);\n  }\n  return indent;\n}\nconst listReplace = listType => {\n  return (parentNode, children, match, isImport) => {\n    const previousNode = parentNode.getPreviousSibling();\n    const nextNode = parentNode.getNextSibling();\n    const listItem = $createListItemNode(listType === 'check' ? match[3] === 'x' : undefined);\n    if ($isListNode(nextNode) && nextNode.getListType() === listType) {\n      const firstChild = nextNode.getFirstChild();\n      if (firstChild !== null) {\n        firstChild.insertBefore(listItem);\n      } else {\n        // should never happen, but let's handle gracefully, just in case.\n        nextNode.append(listItem);\n      }\n      parentNode.remove();\n    } else if ($isListNode(previousNode) && previousNode.getListType() === listType) {\n      previousNode.append(listItem);\n      parentNode.remove();\n    } else {\n      const list = $createListNode(listType, listType === 'number' ? Number(match[2]) : undefined);\n      list.append(listItem);\n      parentNode.replace(list);\n    }\n    listItem.append(...children);\n    if (!isImport) {\n      listItem.select(0, 0);\n    }\n    const indent = getIndent(match[1]);\n    if (indent) {\n      listItem.setIndent(indent);\n    }\n  };\n};\nconst listExport = (listNode, exportChildren, depth) => {\n  const output = [];\n  const children = listNode.getChildren();\n  let index = 0;\n  for (const listItemNode of children) {\n    if ($isListItemNode(listItemNode)) {\n      if (listItemNode.getChildrenSize() === 1) {\n        const firstChild = listItemNode.getFirstChild();\n        if ($isListNode(firstChild)) {\n          output.push(listExport(firstChild, exportChildren, depth + 1));\n          continue;\n        }\n      }\n      const indent = ' '.repeat(depth * LIST_INDENT_SIZE);\n      const listType = listNode.getListType();\n      const prefix = listType === 'number' ? `${listNode.getStart() + index}. ` : listType === 'check' ? `- [${listItemNode.getChecked() ? 'x' : ' '}] ` : '- ';\n      output.push(indent + prefix + exportChildren(listItemNode));\n      index++;\n    }\n  }\n  return output.join('\\n');\n};\nconst HEADING = {\n  dependencies: [HeadingNode],\n  export: (node, exportChildren) => {\n    if (!$isHeadingNode(node)) {\n      return null;\n    }\n    const level = Number(node.getTag().slice(1));\n    return '#'.repeat(level) + ' ' + exportChildren(node);\n  },\n  regExp: HEADING_REGEX,\n  replace: createBlockNode(match => {\n    const tag = 'h' + match[1].length;\n    return $createHeadingNode(tag);\n  }),\n  type: 'element'\n};\nconst QUOTE = {\n  dependencies: [QuoteNode],\n  export: (node, exportChildren) => {\n    if (!$isQuoteNode(node)) {\n      return null;\n    }\n    const lines = exportChildren(node).split('\\n');\n    const output = [];\n    for (const line of lines) {\n      output.push('> ' + line);\n    }\n    return output.join('\\n');\n  },\n  regExp: QUOTE_REGEX,\n  replace: (parentNode, children, _match, isImport) => {\n    if (isImport) {\n      const previousNode = parentNode.getPreviousSibling();\n      if ($isQuoteNode(previousNode)) {\n        previousNode.splice(previousNode.getChildrenSize(), 0, [$createLineBreakNode(), ...children]);\n        parentNode.remove();\n        return;\n      }\n    }\n    const node = $createQuoteNode();\n    node.append(...children);\n    parentNode.replace(node);\n    if (!isImport) {\n      node.select(0, 0);\n    }\n  },\n  type: 'element'\n};\nconst CODE = {\n  dependencies: [CodeNode],\n  export: node => {\n    if (!$isCodeNode(node)) {\n      return null;\n    }\n    const textContent = node.getTextContent();\n    return '```' + (node.getLanguage() || '') + (textContent ? '\\n' + textContent : '') + '\\n' + '```';\n  },\n  regExpEnd: {\n    optional: true,\n    regExp: CODE_END_REGEX\n  },\n  regExpStart: CODE_START_REGEX,\n  replace: (rootNode, children, startMatch, endMatch, linesInBetween, isImport) => {\n    let codeBlockNode;\n    let code;\n    if (!children && linesInBetween) {\n      if (linesInBetween.length === 1) {\n        // Single-line code blocks\n        if (endMatch) {\n          // End match on same line. Example: ```markdown hello```. markdown should not be considered the language here.\n          codeBlockNode = $createCodeNode();\n          code = startMatch[1] + linesInBetween[0];\n        } else {\n          // No end match. We should assume the language is next to the backticks and that code will be typed on the next line in the future\n          codeBlockNode = $createCodeNode(startMatch[1]);\n          code = linesInBetween[0].startsWith(' ') ? linesInBetween[0].slice(1) : linesInBetween[0];\n        }\n      } else {\n        // Treat multi-line code blocks as if they always have an end match\n        codeBlockNode = $createCodeNode(startMatch[1]);\n        if (linesInBetween[0].trim().length === 0) {\n          // Filter out all start and end lines that are length 0 until we find the first line with content\n          while (linesInBetween.length > 0 && !linesInBetween[0].length) {\n            linesInBetween.shift();\n          }\n        } else {\n          // The first line already has content => Remove the first space of the line if it exists\n          linesInBetween[0] = linesInBetween[0].startsWith(' ') ? linesInBetween[0].slice(1) : linesInBetween[0];\n        }\n\n        // Filter out all end lines that are length 0 until we find the last line with content\n        while (linesInBetween.length > 0 && !linesInBetween[linesInBetween.length - 1].length) {\n          linesInBetween.pop();\n        }\n        code = linesInBetween.join('\\n');\n      }\n      const textNode = $createTextNode(code);\n      codeBlockNode.append(textNode);\n      rootNode.append(codeBlockNode);\n    } else if (children) {\n      createBlockNode(match => {\n        return $createCodeNode(match ? match[1] : undefined);\n      })(rootNode, children, startMatch, isImport);\n    }\n  },\n  type: 'multiline-element'\n};\nconst UNORDERED_LIST = {\n  dependencies: [ListNode, ListItemNode],\n  export: (node, exportChildren) => {\n    return $isListNode(node) ? listExport(node, exportChildren, 0) : null;\n  },\n  regExp: UNORDERED_LIST_REGEX,\n  replace: listReplace('bullet'),\n  type: 'element'\n};\nconst CHECK_LIST = {\n  dependencies: [ListNode, ListItemNode],\n  export: (node, exportChildren) => {\n    return $isListNode(node) ? listExport(node, exportChildren, 0) : null;\n  },\n  regExp: CHECK_LIST_REGEX,\n  replace: listReplace('check'),\n  type: 'element'\n};\nconst ORDERED_LIST = {\n  dependencies: [ListNode, ListItemNode],\n  export: (node, exportChildren) => {\n    return $isListNode(node) ? listExport(node, exportChildren, 0) : null;\n  },\n  regExp: ORDERED_LIST_REGEX,\n  replace: listReplace('number'),\n  type: 'element'\n};\nconst INLINE_CODE = {\n  format: ['code'],\n  tag: '`',\n  type: 'text-format'\n};\nconst HIGHLIGHT = {\n  format: ['highlight'],\n  tag: '==',\n  type: 'text-format'\n};\nconst BOLD_ITALIC_STAR = {\n  format: ['bold', 'italic'],\n  tag: '***',\n  type: 'text-format'\n};\nconst BOLD_ITALIC_UNDERSCORE = {\n  format: ['bold', 'italic'],\n  intraword: false,\n  tag: '___',\n  type: 'text-format'\n};\nconst BOLD_STAR = {\n  format: ['bold'],\n  tag: '**',\n  type: 'text-format'\n};\nconst BOLD_UNDERSCORE = {\n  format: ['bold'],\n  intraword: false,\n  tag: '__',\n  type: 'text-format'\n};\nconst STRIKETHROUGH = {\n  format: ['strikethrough'],\n  tag: '~~',\n  type: 'text-format'\n};\nconst ITALIC_STAR = {\n  format: ['italic'],\n  tag: '*',\n  type: 'text-format'\n};\nconst ITALIC_UNDERSCORE = {\n  format: ['italic'],\n  intraword: false,\n  tag: '_',\n  type: 'text-format'\n};\n\n// Order of text transformers matters:\n//\n// - code should go first as it prevents any transformations inside\n// - then longer tags match (e.g. ** or __ should go before * or _)\nconst LINK = {\n  dependencies: [LinkNode],\n  export: (node, exportChildren, exportFormat) => {\n    if (!$isLinkNode(node) || $isAutoLinkNode(node)) {\n      return null;\n    }\n    const title = node.getTitle();\n    const textContent = exportChildren(node);\n    const linkContent = title ? `[${textContent}](${node.getURL()} \"${title}\")` : `[${textContent}](${node.getURL()})`;\n    return linkContent;\n  },\n  importRegExp: /(?:\\[([^[]+)\\])(?:\\((?:([^()\\s]+)(?:\\s\"((?:[^\"]*\\\\\")*[^\"]*)\"\\s*)?)\\))/,\n  regExp: /(?:\\[([^[]+)\\])(?:\\((?:([^()\\s]+)(?:\\s\"((?:[^\"]*\\\\\")*[^\"]*)\"\\s*)?)\\))$/,\n  replace: (textNode, match) => {\n    const [, linkText, linkUrl, linkTitle] = match;\n    const linkNode = $createLinkNode(linkUrl, {\n      title: linkTitle\n    });\n    const linkTextNode = $createTextNode(linkText);\n    linkTextNode.setFormat(textNode.getFormat());\n    linkNode.append(linkTextNode);\n    textNode.replace(linkNode);\n    return linkTextNode;\n  },\n  trigger: ')',\n  type: 'text-match'\n};\nfunction normalizeMarkdown(input, shouldMergeAdjacentLines = false) {\n  const lines = input.split('\\n');\n  let inCodeBlock = false;\n  const sanitizedLines = [];\n  for (let i = 0; i < lines.length; i++) {\n    const line = lines[i];\n    const lastLine = sanitizedLines[sanitizedLines.length - 1];\n\n    // Code blocks of ```single line``` don't toggle the inCodeBlock flag\n    if (CODE_SINGLE_LINE_REGEX.test(line)) {\n      sanitizedLines.push(line);\n      continue;\n    }\n\n    // Detect the start or end of a code block\n    if (CODE_START_REGEX.test(line) || CODE_END_REGEX.test(line)) {\n      inCodeBlock = !inCodeBlock;\n      sanitizedLines.push(line);\n      continue;\n    }\n\n    // If we are inside a code block, keep the line unchanged\n    if (inCodeBlock) {\n      sanitizedLines.push(line);\n      continue;\n    }\n\n    // In markdown the concept of \"empty paragraphs\" does not exist.\n    // Blocks must be separated by an empty line. Non-empty adjacent lines must be merged.\n    if (line === '' || lastLine === '' || !lastLine || HEADING_REGEX.test(lastLine) || HEADING_REGEX.test(line) || QUOTE_REGEX.test(line) || ORDERED_LIST_REGEX.test(line) || UNORDERED_LIST_REGEX.test(line) || CHECK_LIST_REGEX.test(line) || TABLE_ROW_REG_EXP.test(line) || TABLE_ROW_DIVIDER_REG_EXP.test(line) || !shouldMergeAdjacentLines) {\n      sanitizedLines.push(line);\n    } else {\n      sanitizedLines[sanitizedLines.length - 1] = lastLine + line;\n    }\n  }\n  return sanitizedLines.join('\\n');\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst ELEMENT_TRANSFORMERS = [HEADING, QUOTE, UNORDERED_LIST, ORDERED_LIST];\nconst MULTILINE_ELEMENT_TRANSFORMERS = [CODE];\n\n// Order of text format transformers matters:\n//\n// - code should go first as it prevents any transformations inside\n// - then longer tags match (e.g. ** or __ should go before * or _)\nconst TEXT_FORMAT_TRANSFORMERS = [INLINE_CODE, BOLD_ITALIC_STAR, BOLD_ITALIC_UNDERSCORE, BOLD_STAR, BOLD_UNDERSCORE, HIGHLIGHT, ITALIC_STAR, ITALIC_UNDERSCORE, STRIKETHROUGH];\nconst TEXT_MATCH_TRANSFORMERS = [LINK];\nconst TRANSFORMERS = [...ELEMENT_TRANSFORMERS, ...MULTILINE_ELEMENT_TRANSFORMERS, ...TEXT_FORMAT_TRANSFORMERS, ...TEXT_MATCH_TRANSFORMERS];\n\n/**\n * Renders markdown from a string. The selection is moved to the start after the operation.\n *\n *  @param {boolean} [shouldPreserveNewLines] By setting this to true, new lines will be preserved between conversions\n *  @param {boolean} [shouldMergeAdjacentLines] By setting this to true, adjacent non empty lines will be merged according to commonmark spec: https://spec.commonmark.org/0.24/#example-177. Not applicable if shouldPreserveNewLines = true.\n */\nfunction $convertFromMarkdownString(markdown, transformers = TRANSFORMERS, node, shouldPreserveNewLines = false, shouldMergeAdjacentLines = false) {\n  const sanitizedMarkdown = shouldPreserveNewLines ? markdown : normalizeMarkdown(markdown, shouldMergeAdjacentLines);\n  const importMarkdown = createMarkdownImport(transformers, shouldPreserveNewLines);\n  return importMarkdown(sanitizedMarkdown, node);\n}\n\n/**\n * Renders string from markdown. The selection is moved to the start after the operation.\n */\nfunction $convertToMarkdownString(transformers = TRANSFORMERS, node, shouldPreserveNewLines = false) {\n  const exportMarkdown = createMarkdownExport(transformers, shouldPreserveNewLines);\n  return exportMarkdown(node);\n}\n\nexport { $convertFromMarkdownString, $convertToMarkdownString, BOLD_ITALIC_STAR, BOLD_ITALIC_UNDERSCORE, BOLD_STAR, BOLD_UNDERSCORE, CHECK_LIST, CODE, ELEMENT_TRANSFORMERS, HEADING, HIGHLIGHT, INLINE_CODE, ITALIC_STAR, ITALIC_UNDERSCORE, LINK, MULTILINE_ELEMENT_TRANSFORMERS, ORDERED_LIST, QUOTE, STRIKETHROUGH, TEXT_FORMAT_TRANSFORMERS, TEXT_MATCH_TRANSFORMERS, TRANSFORMERS, UNORDERED_LIST, registerMarkdownShortcuts };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}