{"ast":null,"code":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport { isHTMLElement, addClassNamesToElement, removeClassNamesFromElement, $getAdjacentCaret, mergeRegister } from '@lexical/utils';\nimport { ElementNode, $createParagraphNode, $isTextNode, $isTabNode, $createTabNode, $createLineBreakNode, $applyNodeReplacement, TextNode, $getSiblingCaret, $isLineBreakNode, $createTextNode, $getNodeByKey, $getSelection, $isRangeSelection, $createPoint, INDENT_CONTENT_COMMAND, OUTDENT_CONTENT_COMMAND, INSERT_TAB_COMMAND, $setSelectionFromCaretRange, $getCaretRangeInDirection, $getCaretRange, $getTextPointCaret, $normalizeCaret, KEY_ARROW_UP_COMMAND, MOVE_TO_START, KEY_TAB_COMMAND, COMMAND_PRIORITY_LOW, $insertNodes, KEY_ARROW_DOWN_COMMAND, MOVE_TO_END } from 'lexical';\nimport 'prismjs';\nimport 'prismjs/components/prism-clike.js';\nimport 'prismjs/components/prism-javascript.js';\nimport 'prismjs/components/prism-markup.js';\nimport 'prismjs/components/prism-markdown.js';\nimport 'prismjs/components/prism-c.js';\nimport 'prismjs/components/prism-css.js';\nimport 'prismjs/components/prism-objectivec.js';\nimport 'prismjs/components/prism-sql.js';\nimport 'prismjs/components/prism-powershell.js';\nimport 'prismjs/components/prism-python.js';\nimport 'prismjs/components/prism-rust.js';\nimport 'prismjs/components/prism-swift.js';\nimport 'prismjs/components/prism-typescript.js';\nimport 'prismjs/components/prism-java.js';\nimport 'prismjs/components/prism-cpp.js';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n// Do not require this module directly! Use normal `invariant` calls.\n\nfunction formatDevErrorMessage(message) {\n  throw new Error(message);\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n// invariant(condition, message) will refine types based on \"condition\", and\n// if \"condition\" is false will throw an error. This function is special-cased\n// in flow itself, so we can't name it anything else.\nfunction invariant(cond, message, ...args) {\n  if (cond) {\n    return;\n  }\n  throw new Error('Internal Lexical error: invariant() is meant to be replaced at compile ' + 'time. There is no runtime version. Error: ' + message);\n}\n(function (Prism) {\n  Prism.languages.diff = {\n    'coord': [\n    // Match all kinds of coord lines (prefixed by \"+++\", \"---\" or \"***\").\n    /^(?:\\*{3}|-{3}|\\+{3}).*$/m,\n    // Match \"@@ ... @@\" coord lines in unified diff.\n    /^@@.*@@$/m,\n    // Match coord lines in normal diff (starts with a number).\n    /^\\d.*$/m]\n\n    // deleted, inserted, unchanged, diff\n  };\n\n  /**\n   * A map from the name of a block to its line prefix.\n   *\n   * @type {Object<string, string>}\n   */\n  var PREFIXES = {\n    'deleted-sign': '-',\n    'deleted-arrow': '<',\n    'inserted-sign': '+',\n    'inserted-arrow': '>',\n    'unchanged': ' ',\n    'diff': '!'\n  };\n\n  // add a token for each prefix\n  Object.keys(PREFIXES).forEach(function (name) {\n    var prefix = PREFIXES[name];\n    var alias = [];\n    if (!/^\\w+$/.test(name)) {\n      // \"deleted-sign\" -> \"deleted\"\n      alias.push(/\\w+/.exec(name)[0]);\n    }\n    if (name === 'diff') {\n      alias.push('bold');\n    }\n    Prism.languages.diff[name] = {\n      pattern: RegExp('^(?:[' + prefix + '].*(?:\\r\\n?|\\n|(?![\\\\s\\\\S])))+', 'm'),\n      alias: alias,\n      inside: {\n        'line': {\n          pattern: /(.)(?=[\\s\\S]).*(?:\\r\\n?|\\n)?/,\n          lookbehind: true\n        },\n        'prefix': {\n          pattern: /[\\s\\S]/,\n          alias: /\\w+/.exec(name)[0]\n        }\n      }\n    };\n  });\n\n  // make prefixes available to Diff plugin\n  Object.defineProperty(Prism.languages.diff, 'PREFIXES', {\n    value: PREFIXES\n  });\n})(Prism);\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst Prism$1 = globalThis.Prism || window.Prism;\n\n// The following code is extracted/adapted from prismjs v2\n// It will probably be possible to use it directly from prism v2\n// in the future when prismjs v2 is published and Lexical upgrades\n// the prismsjs dependency\n\nfunction getTextContent(token) {\n  if (typeof token === 'string') {\n    return token;\n  } else if (Array.isArray(token)) {\n    return token.map(getTextContent).join('');\n  } else {\n    return getTextContent(token.content);\n  }\n}\nfunction tokenizeDiffHighlight(tokens, language) {\n  const diffLanguage = language;\n  const diffGrammar = Prism$1.languages[diffLanguage];\n  const env = {\n    tokens\n  };\n  const PREFIXES = Prism$1.languages.diff.PREFIXES;\n  for (const token of env.tokens) {\n    if (typeof token === 'string' || !(token.type in PREFIXES) || !Array.isArray(token.content)) {\n      continue;\n    }\n    const type = token.type;\n    let insertedPrefixes = 0;\n    const getPrefixToken = () => {\n      insertedPrefixes++;\n      return new Prism$1.Token('prefix', PREFIXES[type], type.replace(/^(\\w+).*/, '$1'));\n    };\n    const withoutPrefixes = token.content.filter(t => typeof t === 'string' || t.type !== 'prefix');\n    const prefixCount = token.content.length - withoutPrefixes.length;\n    const diffTokens = Prism$1.tokenize(getTextContent(withoutPrefixes), diffGrammar);\n\n    // re-insert prefixes\n    // always add a prefix at the start\n    diffTokens.unshift(getPrefixToken());\n    const LINE_BREAK = /\\r\\n|\\n/g;\n    const insertAfterLineBreakString = text => {\n      const result = [];\n      LINE_BREAK.lastIndex = 0;\n      let last = 0;\n      let m;\n      while (insertedPrefixes < prefixCount && (m = LINE_BREAK.exec(text))) {\n        const end = m.index + m[0].length;\n        result.push(text.slice(last, end));\n        last = end;\n        result.push(getPrefixToken());\n      }\n      if (result.length === 0) {\n        return undefined;\n      }\n      if (last < text.length) {\n        result.push(text.slice(last));\n      }\n      return result;\n    };\n    const insertAfterLineBreak = toks => {\n      for (let i = 0; i < toks.length && insertedPrefixes < prefixCount; i++) {\n        const tok = toks[i];\n        if (typeof tok === 'string') {\n          const inserted = insertAfterLineBreakString(tok);\n          if (inserted) {\n            toks.splice(i, 1, ...inserted);\n            i += inserted.length - 1;\n          }\n        } else if (typeof tok.content === 'string') {\n          const inserted = insertAfterLineBreakString(tok.content);\n          if (inserted) {\n            tok.content = inserted;\n          }\n        } else if (Array.isArray(tok.content)) {\n          insertAfterLineBreak(tok.content);\n        } else {\n          insertAfterLineBreak([tok.content]);\n        }\n      }\n    };\n    insertAfterLineBreak(diffTokens);\n    if (insertedPrefixes < prefixCount) {\n      // we are missing the last prefix\n      diffTokens.push(getPrefixToken());\n    }\n    token.content = diffTokens;\n  }\n  return env.tokens;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst isLanguageSupportedByPrism = language => {\n  const DIFF_LANGUAGE_REGEX = /^diff-([\\w-]+)/i;\n  try {\n    if (!language) {\n      return false;\n    }\n    const langMatch = DIFF_LANGUAGE_REGEX.exec(language);\n    if (langMatch) {\n      return (\n        // eslint-disable-next-line no-prototype-builtins\n        Prism$1.languages.hasOwnProperty('diff') &&\n        // eslint-disable-next-line no-prototype-builtins\n        Prism$1.languages.hasOwnProperty(langMatch[1])\n      );\n    } else {\n      // eslint-disable-next-line no-prototype-builtins\n      return Prism$1.languages.hasOwnProperty(language);\n    }\n  } catch (_unused) {\n    return false;\n  }\n};\nfunction hasChildDOMNodeTag(node, tagName) {\n  for (const child of node.childNodes) {\n    if (isHTMLElement(child) && child.tagName === tagName) {\n      return true;\n    }\n    hasChildDOMNodeTag(child, tagName);\n  }\n  return false;\n}\nconst LANGUAGE_DATA_ATTRIBUTE = 'data-language';\nconst HIGHLIGHT_LANGUAGE_DATA_ATTRIBUTE = 'data-highlight-language';\n\n/** @noInheritDoc */\nclass CodeNode extends ElementNode {\n  /** @internal */\n\n  /** @internal */\n\n  static getType() {\n    return 'code';\n  }\n  static clone(node) {\n    return new CodeNode(node.__language, node.__key);\n  }\n  constructor(language, key) {\n    super(key);\n    this.__language = language || undefined;\n    this.__isSyntaxHighlightSupported = isLanguageSupportedByPrism(language);\n  }\n\n  // View\n  createDOM(config) {\n    const element = document.createElement('code');\n    addClassNamesToElement(element, config.theme.code);\n    element.setAttribute('spellcheck', 'false');\n    const language = this.getLanguage();\n    if (language) {\n      element.setAttribute(LANGUAGE_DATA_ATTRIBUTE, language);\n      if (this.getIsSyntaxHighlightSupported()) {\n        element.setAttribute(HIGHLIGHT_LANGUAGE_DATA_ATTRIBUTE, language);\n      }\n    }\n    return element;\n  }\n  updateDOM(prevNode, dom, config) {\n    const language = this.__language;\n    const prevLanguage = prevNode.__language;\n    if (language) {\n      if (language !== prevLanguage) {\n        dom.setAttribute(LANGUAGE_DATA_ATTRIBUTE, language);\n        if (this.__isSyntaxHighlightSupported) {\n          dom.setAttribute(HIGHLIGHT_LANGUAGE_DATA_ATTRIBUTE, language);\n        }\n      }\n    } else if (prevLanguage) {\n      dom.removeAttribute(LANGUAGE_DATA_ATTRIBUTE);\n      if (prevNode.__isSyntaxHighlightSupported) {\n        dom.removeAttribute(HIGHLIGHT_LANGUAGE_DATA_ATTRIBUTE);\n      }\n    }\n    return false;\n  }\n  exportDOM(editor) {\n    const element = document.createElement('pre');\n    addClassNamesToElement(element, editor._config.theme.code);\n    element.setAttribute('spellcheck', 'false');\n    const language = this.getLanguage();\n    if (language) {\n      element.setAttribute(LANGUAGE_DATA_ATTRIBUTE, language);\n      if (this.getIsSyntaxHighlightSupported()) {\n        element.setAttribute(HIGHLIGHT_LANGUAGE_DATA_ATTRIBUTE, language);\n      }\n    }\n    return {\n      element\n    };\n  }\n  static importDOM() {\n    return {\n      // Typically <pre> is used for code blocks, and <code> for inline code styles\n      // but if it's a multi line <code> we'll create a block. Pass through to\n      // inline format handled by TextNode otherwise.\n      code: node => {\n        const isMultiLine = node.textContent != null && (/\\r?\\n/.test(node.textContent) || hasChildDOMNodeTag(node, 'BR'));\n        return isMultiLine ? {\n          conversion: $convertPreElement,\n          priority: 1\n        } : null;\n      },\n      div: () => ({\n        conversion: $convertDivElement,\n        priority: 1\n      }),\n      pre: () => ({\n        conversion: $convertPreElement,\n        priority: 0\n      }),\n      table: node => {\n        const table = node;\n        // domNode is a <table> since we matched it by nodeName\n        if (isGitHubCodeTable(table)) {\n          return {\n            conversion: $convertTableElement,\n            priority: 3\n          };\n        }\n        return null;\n      },\n      td: node => {\n        // element is a <td> since we matched it by nodeName\n        const td = node;\n        const table = td.closest('table');\n        if (isGitHubCodeCell(td) || table && isGitHubCodeTable(table)) {\n          // Return a no-op if it's a table cell in a code table, but not a code line.\n          // Otherwise it'll fall back to the T\n          return {\n            conversion: convertCodeNoop,\n            priority: 3\n          };\n        }\n        return null;\n      },\n      tr: node => {\n        // element is a <tr> since we matched it by nodeName\n        const tr = node;\n        const table = tr.closest('table');\n        if (table && isGitHubCodeTable(table)) {\n          return {\n            conversion: convertCodeNoop,\n            priority: 3\n          };\n        }\n        return null;\n      }\n    };\n  }\n  static importJSON(serializedNode) {\n    return $createCodeNode().updateFromJSON(serializedNode);\n  }\n  updateFromJSON(serializedNode) {\n    return super.updateFromJSON(serializedNode).setLanguage(serializedNode.language);\n  }\n  exportJSON() {\n    return {\n      ...super.exportJSON(),\n      language: this.getLanguage()\n    };\n  }\n\n  // Mutation\n  insertNewAfter(selection, restoreSelection = true) {\n    const children = this.getChildren();\n    const childrenLength = children.length;\n    if (childrenLength >= 2 && children[childrenLength - 1].getTextContent() === '\\n' && children[childrenLength - 2].getTextContent() === '\\n' && selection.isCollapsed() && selection.anchor.key === this.__key && selection.anchor.offset === childrenLength) {\n      children[childrenLength - 1].remove();\n      children[childrenLength - 2].remove();\n      const newElement = $createParagraphNode();\n      this.insertAfter(newElement, restoreSelection);\n      return newElement;\n    }\n\n    // If the selection is within the codeblock, find all leading tabs and\n    // spaces of the current line. Create a new line that has all those\n    // tabs and spaces, such that leading indentation is preserved.\n    const {\n      anchor,\n      focus\n    } = selection;\n    const firstPoint = anchor.isBefore(focus) ? anchor : focus;\n    const firstSelectionNode = firstPoint.getNode();\n    if ($isTextNode(firstSelectionNode)) {\n      let node = $getFirstCodeNodeOfLine(firstSelectionNode);\n      const insertNodes = [];\n      // eslint-disable-next-line no-constant-condition\n      while (true) {\n        if ($isTabNode(node)) {\n          insertNodes.push($createTabNode());\n          node = node.getNextSibling();\n        } else if ($isCodeHighlightNode(node)) {\n          let spaces = 0;\n          const text = node.getTextContent();\n          const textSize = node.getTextContentSize();\n          while (spaces < textSize && text[spaces] === ' ') {\n            spaces++;\n          }\n          if (spaces !== 0) {\n            insertNodes.push($createCodeHighlightNode(' '.repeat(spaces)));\n          }\n          if (spaces !== textSize) {\n            break;\n          }\n          node = node.getNextSibling();\n        } else {\n          break;\n        }\n      }\n      const split = firstSelectionNode.splitText(anchor.offset)[0];\n      const x = anchor.offset === 0 ? 0 : 1;\n      const index = split.getIndexWithinParent() + x;\n      const codeNode = firstSelectionNode.getParentOrThrow();\n      const nodesToInsert = [$createLineBreakNode(), ...insertNodes];\n      codeNode.splice(index, 0, nodesToInsert);\n      const last = insertNodes[insertNodes.length - 1];\n      if (last) {\n        last.select();\n      } else if (anchor.offset === 0) {\n        split.selectPrevious();\n      } else {\n        split.getNextSibling().selectNext(0, 0);\n      }\n    }\n    if ($isCodeNode(firstSelectionNode)) {\n      const {\n        offset\n      } = selection.anchor;\n      firstSelectionNode.splice(offset, 0, [$createLineBreakNode()]);\n      firstSelectionNode.select(offset + 1, offset + 1);\n    }\n    return null;\n  }\n  canIndent() {\n    return false;\n  }\n  collapseAtStart() {\n    const paragraph = $createParagraphNode();\n    const children = this.getChildren();\n    children.forEach(child => paragraph.append(child));\n    this.replace(paragraph);\n    return true;\n  }\n  setLanguage(language) {\n    const writable = this.getWritable();\n    writable.__language = language || undefined;\n    writable.__isSyntaxHighlightSupported = isLanguageSupportedByPrism(language);\n    return writable;\n  }\n  getLanguage() {\n    return this.getLatest().__language;\n  }\n  getIsSyntaxHighlightSupported() {\n    return this.getLatest().__isSyntaxHighlightSupported;\n  }\n}\nfunction $createCodeNode(language) {\n  return $applyNodeReplacement(new CodeNode(language));\n}\nfunction $isCodeNode(node) {\n  return node instanceof CodeNode;\n}\nfunction $convertPreElement(domNode) {\n  const language = domNode.getAttribute(LANGUAGE_DATA_ATTRIBUTE);\n  return {\n    node: $createCodeNode(language)\n  };\n}\nfunction $convertDivElement(domNode) {\n  // domNode is a <div> since we matched it by nodeName\n  const div = domNode;\n  const isCode = isCodeElement(div);\n  if (!isCode && !isCodeChildElement(div)) {\n    return {\n      node: null\n    };\n  }\n  return {\n    node: isCode ? $createCodeNode() : null\n  };\n}\nfunction $convertTableElement() {\n  return {\n    node: $createCodeNode()\n  };\n}\nfunction convertCodeNoop() {\n  return {\n    node: null\n  };\n}\nfunction isCodeElement(div) {\n  return div.style.fontFamily.match('monospace') !== null;\n}\nfunction isCodeChildElement(node) {\n  let parent = node.parentElement;\n  while (parent !== null) {\n    if (isCodeElement(parent)) {\n      return true;\n    }\n    parent = parent.parentElement;\n  }\n  return false;\n}\nfunction isGitHubCodeCell(cell) {\n  return cell.classList.contains('js-file-line');\n}\nfunction isGitHubCodeTable(table) {\n  return table.classList.contains('js-file-line-container');\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst DEFAULT_CODE_LANGUAGE = 'javascript';\nconst CODE_LANGUAGE_FRIENDLY_NAME_MAP = {\n  c: 'C',\n  clike: 'C-like',\n  cpp: 'C++',\n  css: 'CSS',\n  html: 'HTML',\n  java: 'Java',\n  js: 'JavaScript',\n  markdown: 'Markdown',\n  objc: 'Objective-C',\n  plain: 'Plain Text',\n  powershell: 'PowerShell',\n  py: 'Python',\n  rust: 'Rust',\n  sql: 'SQL',\n  swift: 'Swift',\n  typescript: 'TypeScript',\n  xml: 'XML'\n};\nconst CODE_LANGUAGE_MAP = {\n  cpp: 'cpp',\n  java: 'java',\n  javascript: 'js',\n  md: 'markdown',\n  plaintext: 'plain',\n  python: 'py',\n  text: 'plain',\n  ts: 'typescript'\n};\nfunction normalizeCodeLang(lang) {\n  return CODE_LANGUAGE_MAP[lang] || lang;\n}\nfunction getLanguageFriendlyName(lang) {\n  const _lang = normalizeCodeLang(lang);\n  return CODE_LANGUAGE_FRIENDLY_NAME_MAP[_lang] || _lang;\n}\nconst getDefaultCodeLanguage = () => DEFAULT_CODE_LANGUAGE;\nconst getCodeLanguages = () => Object.keys(Prism$1.languages).filter(\n// Prism has several language helpers mixed into languages object\n// so filtering them out here to get langs list\nlanguage => typeof Prism$1.languages[language] !== 'function').sort();\n\n/** @noInheritDoc */\nclass CodeHighlightNode extends TextNode {\n  /** @internal */\n\n  constructor(text = '', highlightType, key) {\n    super(text, key);\n    this.__highlightType = highlightType;\n  }\n  static getType() {\n    return 'code-highlight';\n  }\n  static clone(node) {\n    return new CodeHighlightNode(node.__text, node.__highlightType || undefined, node.__key);\n  }\n  getHighlightType() {\n    const self = this.getLatest();\n    return self.__highlightType;\n  }\n  setHighlightType(highlightType) {\n    const self = this.getWritable();\n    self.__highlightType = highlightType || undefined;\n    return self;\n  }\n  canHaveFormat() {\n    return false;\n  }\n  createDOM(config) {\n    const element = super.createDOM(config);\n    const className = getHighlightThemeClass(config.theme, this.__highlightType);\n    addClassNamesToElement(element, className);\n    return element;\n  }\n  updateDOM(prevNode, dom, config) {\n    const update = super.updateDOM(prevNode, dom, config);\n    const prevClassName = getHighlightThemeClass(config.theme, prevNode.__highlightType);\n    const nextClassName = getHighlightThemeClass(config.theme, this.__highlightType);\n    if (prevClassName !== nextClassName) {\n      if (prevClassName) {\n        removeClassNamesFromElement(dom, prevClassName);\n      }\n      if (nextClassName) {\n        addClassNamesToElement(dom, nextClassName);\n      }\n    }\n    return update;\n  }\n  static importJSON(serializedNode) {\n    return $createCodeHighlightNode().updateFromJSON(serializedNode);\n  }\n  updateFromJSON(serializedNode) {\n    return super.updateFromJSON(serializedNode).setHighlightType(serializedNode.highlightType);\n  }\n  exportJSON() {\n    return {\n      ...super.exportJSON(),\n      highlightType: this.getHighlightType()\n    };\n  }\n\n  // Prevent formatting (bold, underline, etc)\n  setFormat(format) {\n    return this;\n  }\n  isParentRequired() {\n    return true;\n  }\n  createParentElementNode() {\n    return $createCodeNode();\n  }\n}\nfunction getHighlightThemeClass(theme, highlightType) {\n  return highlightType && theme && theme.codeHighlight && theme.codeHighlight[highlightType];\n}\nfunction $createCodeHighlightNode(text = '', highlightType) {\n  return $applyNodeReplacement(new CodeHighlightNode(text, highlightType));\n}\nfunction $isCodeHighlightNode(node) {\n  return node instanceof CodeHighlightNode;\n}\nfunction $getLastMatchingCodeNode(anchor, direction) {\n  let matchingNode = anchor;\n  for (let caret = $getSiblingCaret(anchor, direction); caret && ($isCodeHighlightNode(caret.origin) || $isTabNode(caret.origin)); caret = $getAdjacentCaret(caret)) {\n    matchingNode = caret.origin;\n  }\n  return matchingNode;\n}\nfunction $getFirstCodeNodeOfLine(anchor) {\n  return $getLastMatchingCodeNode(anchor, 'previous');\n}\nfunction $getLastCodeNodeOfLine(anchor) {\n  return $getLastMatchingCodeNode(anchor, 'next');\n}\nconst PrismTokenizer = {\n  defaultLanguage: DEFAULT_CODE_LANGUAGE,\n  tokenize(code, language) {\n    return Prism$1.tokenize(code, Prism$1.languages[language || ''] || Prism$1.languages[this.defaultLanguage]);\n  }\n};\nfunction $getStartOfCodeInLine(anchor, offset) {\n  let last = null;\n  let lastNonBlank = null;\n  let node = anchor;\n  let nodeOffset = offset;\n  let nodeTextContent = anchor.getTextContent();\n  // eslint-disable-next-line no-constant-condition\n  while (true) {\n    if (nodeOffset === 0) {\n      node = node.getPreviousSibling();\n      if (node === null) {\n        break;\n      }\n      if (!($isCodeHighlightNode(node) || $isTabNode(node) || $isLineBreakNode(node))) {\n        formatDevErrorMessage(`Expected a valid Code Node: CodeHighlightNode, TabNode, LineBreakNode`);\n      }\n      if ($isLineBreakNode(node)) {\n        last = {\n          node,\n          offset: 1\n        };\n        break;\n      }\n      nodeOffset = Math.max(0, node.getTextContentSize() - 1);\n      nodeTextContent = node.getTextContent();\n    } else {\n      nodeOffset--;\n    }\n    const character = nodeTextContent[nodeOffset];\n    if ($isCodeHighlightNode(node) && character !== ' ') {\n      lastNonBlank = {\n        node,\n        offset: nodeOffset\n      };\n    }\n  }\n  // lastNonBlank !== null: anchor in the middle of code; move to line beginning\n  if (lastNonBlank !== null) {\n    return lastNonBlank;\n  }\n  // Spaces, tabs or nothing ahead of anchor\n  let codeCharacterAtAnchorOffset = null;\n  if (offset < anchor.getTextContentSize()) {\n    if ($isCodeHighlightNode(anchor)) {\n      codeCharacterAtAnchorOffset = anchor.getTextContent()[offset];\n    }\n  } else {\n    const nextSibling = anchor.getNextSibling();\n    if ($isCodeHighlightNode(nextSibling)) {\n      codeCharacterAtAnchorOffset = nextSibling.getTextContent()[0];\n    }\n  }\n  if (codeCharacterAtAnchorOffset !== null && codeCharacterAtAnchorOffset !== ' ') {\n    // Borderline whitespace and code, move to line beginning\n    return last;\n  } else {\n    const nextNonBlank = findNextNonBlankInLine(anchor, offset);\n    if (nextNonBlank !== null) {\n      return nextNonBlank;\n    } else {\n      return last;\n    }\n  }\n}\nfunction findNextNonBlankInLine(anchor, offset) {\n  let node = anchor;\n  let nodeOffset = offset;\n  let nodeTextContent = anchor.getTextContent();\n  let nodeTextContentSize = anchor.getTextContentSize();\n  // eslint-disable-next-line no-constant-condition\n  while (true) {\n    if (!$isCodeHighlightNode(node) || nodeOffset === nodeTextContentSize) {\n      node = node.getNextSibling();\n      if (node === null || $isLineBreakNode(node)) {\n        return null;\n      }\n      if ($isCodeHighlightNode(node)) {\n        nodeOffset = 0;\n        nodeTextContent = node.getTextContent();\n        nodeTextContentSize = node.getTextContentSize();\n      }\n    }\n    if ($isCodeHighlightNode(node)) {\n      if (nodeTextContent[nodeOffset] !== ' ') {\n        return {\n          node,\n          offset: nodeOffset\n        };\n      }\n      nodeOffset++;\n    }\n  }\n}\nfunction $getEndOfCodeInLine(anchor) {\n  const lastNode = $getLastCodeNodeOfLine(anchor);\n  if (!!$isLineBreakNode(lastNode)) {\n    formatDevErrorMessage(`Unexpected lineBreakNode in getEndOfCodeInLine`);\n  }\n  return lastNode;\n}\nfunction $textNodeTransform(node, editor, tokenizer) {\n  // Since CodeNode has flat children structure we only need to check\n  // if node's parent is a code node and run highlighting if so\n  const parentNode = node.getParent();\n  if ($isCodeNode(parentNode)) {\n    codeNodeTransform(parentNode, editor, tokenizer);\n  } else if ($isCodeHighlightNode(node)) {\n    // When code block converted into paragraph or other element\n    // code highlight nodes converted back to normal text\n    node.replace($createTextNode(node.__text));\n  }\n}\nfunction updateCodeGutter(node, editor) {\n  const codeElement = editor.getElementByKey(node.getKey());\n  if (codeElement === null) {\n    return;\n  }\n  const children = node.getChildren();\n  const childrenLength = children.length;\n  // @ts-ignore: internal field\n  if (childrenLength === codeElement.__cachedChildrenLength) {\n    // Avoid updating the attribute if the children length hasn't changed.\n    return;\n  }\n  // @ts-ignore:: internal field\n  codeElement.__cachedChildrenLength = childrenLength;\n  let gutter = '1';\n  let count = 1;\n  for (let i = 0; i < childrenLength; i++) {\n    if ($isLineBreakNode(children[i])) {\n      gutter += '\\n' + ++count;\n    }\n  }\n  codeElement.setAttribute('data-gutter', gutter);\n}\n\n// Using `skipTransforms` to prevent extra transforms since reformatting the code\n// will not affect code block content itself.\n//\n// Using extra cache (`nodesCurrentlyHighlighting`) since both CodeNode and CodeHighlightNode\n// transforms might be called at the same time (e.g. new CodeHighlight node inserted) and\n// in both cases we'll rerun whole reformatting over CodeNode, which is redundant.\n// Especially when pasting code into CodeBlock.\n\nconst nodesCurrentlyHighlighting = new Set();\nfunction codeNodeTransform(node, editor, tokenizer) {\n  const nodeKey = node.getKey();\n  if (nodesCurrentlyHighlighting.has(nodeKey)) {\n    return;\n  }\n  nodesCurrentlyHighlighting.add(nodeKey);\n\n  // When new code block inserted it might not have language selected\n  if (node.getLanguage() === undefined) {\n    node.setLanguage(tokenizer.defaultLanguage);\n  }\n\n  // Using nested update call to pass `skipTransforms` since we don't want\n  // each individual CodeHighlightNode to be transformed again as it's already\n  // in its final state\n  editor.update(() => {\n    $updateAndRetainSelection(nodeKey, () => {\n      const currentNode = $getNodeByKey(nodeKey);\n      if (!$isCodeNode(currentNode) || !currentNode.isAttached()) {\n        return false;\n      }\n      const DIFF_LANGUAGE_REGEX = /^diff-([\\w-]+)/i;\n      const currentLanguage = currentNode.getLanguage() || tokenizer.defaultLanguage;\n      const diffLanguageMatch = DIFF_LANGUAGE_REGEX.exec(currentLanguage);\n      const code = currentNode.getTextContent();\n      let tokens = tokenizer.tokenize(code, diffLanguageMatch ? 'diff' : currentLanguage);\n      if (diffLanguageMatch) {\n        tokens = tokenizeDiffHighlight(tokens, diffLanguageMatch[1]);\n      }\n      const highlightNodes = $getHighlightNodes(tokens);\n      const diffRange = getDiffRange(currentNode.getChildren(), highlightNodes);\n      const {\n        from,\n        to,\n        nodesForReplacement\n      } = diffRange;\n      if (from !== to || nodesForReplacement.length) {\n        node.splice(from, to - from, nodesForReplacement);\n        return true;\n      }\n      return false;\n    });\n  }, {\n    onUpdate: () => {\n      nodesCurrentlyHighlighting.delete(nodeKey);\n    },\n    skipTransforms: true\n  });\n}\nfunction $getHighlightNodes(tokens, type) {\n  const nodes = [];\n  for (const token of tokens) {\n    if (typeof token === 'string') {\n      const partials = token.split(/(\\n|\\t)/);\n      const partialsLength = partials.length;\n      for (let i = 0; i < partialsLength; i++) {\n        const part = partials[i];\n        if (part === '\\n' || part === '\\r\\n') {\n          nodes.push($createLineBreakNode());\n        } else if (part === '\\t') {\n          nodes.push($createTabNode());\n        } else if (part.length > 0) {\n          nodes.push($createCodeHighlightNode(part, type));\n        }\n      }\n    } else {\n      const {\n        content,\n        alias\n      } = token;\n      if (typeof content === 'string') {\n        nodes.push(...$getHighlightNodes([content], token.type === 'prefix' && typeof alias === 'string' ? alias : token.type));\n      } else if (Array.isArray(content)) {\n        nodes.push(...$getHighlightNodes(content, token.type === 'unchanged' ? undefined : token.type));\n      }\n    }\n  }\n  return nodes;\n}\n\n// Wrapping update function into selection retainer, that tries to keep cursor at the same\n// position as before.\nfunction $updateAndRetainSelection(nodeKey, updateFn) {\n  const node = $getNodeByKey(nodeKey);\n  if (!$isCodeNode(node) || !node.isAttached()) {\n    return;\n  }\n  const selection = $getSelection();\n  // If it's not range selection (or null selection) there's no need to change it,\n  // but we can still run highlighting logic\n  if (!$isRangeSelection(selection)) {\n    updateFn();\n    return;\n  }\n  const anchor = selection.anchor;\n  const anchorOffset = anchor.offset;\n  const isNewLineAnchor = anchor.type === 'element' && $isLineBreakNode(node.getChildAtIndex(anchor.offset - 1));\n  let textOffset = 0;\n\n  // Calculating previous text offset (all text node prior to anchor + anchor own text offset)\n  if (!isNewLineAnchor) {\n    const anchorNode = anchor.getNode();\n    textOffset = anchorOffset + anchorNode.getPreviousSiblings().reduce((offset, _node) => {\n      return offset + _node.getTextContentSize();\n    }, 0);\n  }\n  const hasChanges = updateFn();\n  if (!hasChanges) {\n    return;\n  }\n\n  // Non-text anchors only happen for line breaks, otherwise\n  // selection will be within text node (code highlight node)\n  if (isNewLineAnchor) {\n    anchor.getNode().select(anchorOffset, anchorOffset);\n    return;\n  }\n\n  // If it was non-element anchor then we walk through child nodes\n  // and looking for a position of original text offset\n  node.getChildren().some(_node => {\n    const isText = $isTextNode(_node);\n    if (isText || $isLineBreakNode(_node)) {\n      const textContentSize = _node.getTextContentSize();\n      if (isText && textContentSize >= textOffset) {\n        _node.select(textOffset, textOffset);\n        return true;\n      }\n      textOffset -= textContentSize;\n    }\n    return false;\n  });\n}\n\n// Finds minimal diff range between two nodes lists. It returns from/to range boundaries of prevNodes\n// that needs to be replaced with `nodes` (subset of nextNodes) to make prevNodes equal to nextNodes.\nfunction getDiffRange(prevNodes, nextNodes) {\n  let leadingMatch = 0;\n  while (leadingMatch < prevNodes.length) {\n    if (!isEqual(prevNodes[leadingMatch], nextNodes[leadingMatch])) {\n      break;\n    }\n    leadingMatch++;\n  }\n  const prevNodesLength = prevNodes.length;\n  const nextNodesLength = nextNodes.length;\n  const maxTrailingMatch = Math.min(prevNodesLength, nextNodesLength) - leadingMatch;\n  let trailingMatch = 0;\n  while (trailingMatch < maxTrailingMatch) {\n    trailingMatch++;\n    if (!isEqual(prevNodes[prevNodesLength - trailingMatch], nextNodes[nextNodesLength - trailingMatch])) {\n      trailingMatch--;\n      break;\n    }\n  }\n  const from = leadingMatch;\n  const to = prevNodesLength - trailingMatch;\n  const nodesForReplacement = nextNodes.slice(leadingMatch, nextNodesLength - trailingMatch);\n  return {\n    from,\n    nodesForReplacement,\n    to\n  };\n}\nfunction isEqual(nodeA, nodeB) {\n  // Only checking for code highlight nodes, tabs and linebreaks. If it's regular text node\n  // returning false so that it's transformed into code highlight node\n  return $isCodeHighlightNode(nodeA) && $isCodeHighlightNode(nodeB) && nodeA.__text === nodeB.__text && nodeA.__highlightType === nodeB.__highlightType || $isTabNode(nodeA) && $isTabNode(nodeB) || $isLineBreakNode(nodeA) && $isLineBreakNode(nodeB);\n}\n\n/**\n * Returns a boolean.\n * Check that the selection span is within a single CodeNode.\n * This is used to guard against executing handlers that can only be\n * applied in a single CodeNode context\n */\nfunction $isSelectionInCode(selection) {\n  if (!$isRangeSelection(selection)) {\n    return false;\n  }\n  const anchorNode = selection.anchor.getNode();\n  const maybeAnchorCodeNode = $isCodeNode(anchorNode) ? anchorNode : anchorNode.getParent();\n  const focusNode = selection.focus.getNode();\n  const maybeFocusCodeNode = $isCodeNode(focusNode) ? focusNode : focusNode.getParent();\n  return $isCodeNode(maybeAnchorCodeNode) && maybeAnchorCodeNode.is(maybeFocusCodeNode);\n}\n\n/**\n * Returns an Array of code lines\n * Take the sequence of LineBreakNode | TabNode | CodeHighlightNode forming\n * the selection and split it by LineBreakNode.\n * If the selection ends at the start of the last line, it is considered empty.\n * Empty lines are discarded.\n */\nfunction $getCodeLines(selection) {\n  const nodes = selection.getNodes();\n  const lines = [];\n  if (nodes.length === 1 && $isCodeNode(nodes[0])) {\n    return lines;\n  }\n  let lastLine = [];\n  for (let i = 0; i < nodes.length; i++) {\n    const node = nodes[i];\n    if (!($isCodeHighlightNode(node) || $isTabNode(node) || $isLineBreakNode(node))) {\n      formatDevErrorMessage(`Expected selection to be inside CodeBlock and consisting of CodeHighlightNode, TabNode and LineBreakNode`);\n    }\n    if ($isLineBreakNode(node)) {\n      if (lastLine.length > 0) {\n        lines.push(lastLine);\n        lastLine = [];\n      }\n    } else {\n      lastLine.push(node);\n    }\n  }\n  if (lastLine.length > 0) {\n    const selectionEnd = selection.isBackward() ? selection.anchor : selection.focus;\n\n    // Discard the last line if the selection ends exactly at the\n    // start of the line (no real selection)\n    const lastPoint = $createPoint(lastLine[0].getKey(), 0, 'text');\n    if (!selectionEnd.is(lastPoint)) {\n      lines.push(lastLine);\n    }\n  }\n  return lines;\n}\nfunction $handleTab(shiftKey) {\n  const selection = $getSelection();\n  if (!$isRangeSelection(selection) || !$isSelectionInCode(selection)) {\n    return null;\n  }\n  const indentOrOutdent = !shiftKey ? INDENT_CONTENT_COMMAND : OUTDENT_CONTENT_COMMAND;\n  const tabOrOutdent = !shiftKey ? INSERT_TAB_COMMAND : OUTDENT_CONTENT_COMMAND;\n  const anchor = selection.anchor;\n  const focus = selection.focus;\n\n  // 1. early decision when there is no real selection\n  if (anchor.is(focus)) {\n    return tabOrOutdent;\n  }\n\n  // 2. If only empty lines or multiple non-empty lines are selected: indent/outdent\n  const codeLines = $getCodeLines(selection);\n  if (codeLines.length !== 1) {\n    return indentOrOutdent;\n  }\n  const codeLine = codeLines[0];\n  const codeLineLength = codeLine.length;\n  if (!(codeLineLength !== 0)) {\n    formatDevErrorMessage(`$getCodeLines only extracts non-empty lines`);\n  } // Take into account the direction of the selection\n  let selectionFirst;\n  let selectionLast;\n  if (selection.isBackward()) {\n    selectionFirst = focus;\n    selectionLast = anchor;\n  } else {\n    selectionFirst = anchor;\n    selectionLast = focus;\n  }\n\n  // find boundary elements of the line\n  // since codeLine only contains TabNode | CodeHighlightNode\n  // the result of these functions should is of Type TabNode | CodeHighlightNode\n  const firstOfLine = $getFirstCodeNodeOfLine(codeLine[0]);\n  const lastOfLine = $getLastCodeNodeOfLine(codeLine[0]);\n  const anchorOfLine = $createPoint(firstOfLine.getKey(), 0, 'text');\n  const focusOfLine = $createPoint(lastOfLine.getKey(), lastOfLine.getTextContentSize(), 'text');\n\n  // 3. multiline because selection started strictly before the line\n  if (selectionFirst.isBefore(anchorOfLine)) {\n    return indentOrOutdent;\n  }\n\n  // 4. multiline because the selection stops strictly after the line\n  if (focusOfLine.isBefore(selectionLast)) {\n    return indentOrOutdent;\n  }\n\n  // The selection if within the line.\n  // 4. If it does not touch both borders, it needs a tab\n  if (anchorOfLine.isBefore(selectionFirst) || selectionLast.isBefore(focusOfLine)) {\n    return tabOrOutdent;\n  }\n\n  // 5. Selection is matching a full line on non-empty code\n  return indentOrOutdent;\n}\nfunction $handleMultilineIndent(type) {\n  const selection = $getSelection();\n  if (!$isRangeSelection(selection) || !$isSelectionInCode(selection)) {\n    return false;\n  }\n  const codeLines = $getCodeLines(selection);\n  const codeLinesLength = codeLines.length;\n\n  // Special Indent case\n  // Selection is collapsed at the beginning of a line\n  if (codeLinesLength === 0 && selection.isCollapsed()) {\n    if (type === INDENT_CONTENT_COMMAND) {\n      selection.insertNodes([$createTabNode()]);\n    }\n    return true;\n  }\n\n  // Special Indent case\n  // Selection is matching only one LineBreak\n  if (codeLinesLength === 0 && type === INDENT_CONTENT_COMMAND && selection.getTextContent() === '\\n') {\n    const tabNode = $createTabNode();\n    const lineBreakNode = $createLineBreakNode();\n    const direction = selection.isBackward() ? 'previous' : 'next';\n    selection.insertNodes([tabNode, lineBreakNode]);\n    $setSelectionFromCaretRange($getCaretRangeInDirection($getCaretRange($getTextPointCaret(tabNode, 'next', 0), $normalizeCaret($getSiblingCaret(lineBreakNode, 'next'))), direction));\n    return true;\n  }\n\n  // Indent Non Empty Lines\n  for (let i = 0; i < codeLinesLength; i++) {\n    const line = codeLines[i];\n    // a line here is never empty\n    if (line.length > 0) {\n      let firstOfLine = line[0];\n\n      // make sure to consider the first node on the first line\n      // because the line might not be fully selected\n      if (i === 0) {\n        firstOfLine = $getFirstCodeNodeOfLine(firstOfLine);\n      }\n      if (type === INDENT_CONTENT_COMMAND) {\n        const tabNode = $createTabNode();\n        firstOfLine.insertBefore(tabNode);\n        // First real code line may need selection adjustment\n        // when firstOfLine is at the selection boundary\n        if (i === 0) {\n          const anchorKey = selection.isBackward() ? 'focus' : 'anchor';\n          const anchorLine = $createPoint(firstOfLine.getKey(), 0, 'text');\n          if (selection[anchorKey].is(anchorLine)) {\n            selection[anchorKey].set(tabNode.getKey(), 0, 'text');\n          }\n        }\n      } else if ($isTabNode(firstOfLine)) {\n        firstOfLine.remove();\n      }\n    }\n  }\n  return true;\n}\nfunction $handleShiftLines(type, event) {\n  // We only care about the alt+arrow keys\n  const selection = $getSelection();\n  if (!$isRangeSelection(selection)) {\n    return false;\n  }\n\n  // I'm not quite sure why, but it seems like calling anchor.getNode() collapses the selection here\n  // So first, get the anchor and the focus, then get their nodes\n  const {\n    anchor,\n    focus\n  } = selection;\n  const anchorOffset = anchor.offset;\n  const focusOffset = focus.offset;\n  const anchorNode = anchor.getNode();\n  const focusNode = focus.getNode();\n  const arrowIsUp = type === KEY_ARROW_UP_COMMAND;\n\n  // Ensure the selection is within the codeblock\n  if (!$isSelectionInCode(selection) || !($isCodeHighlightNode(anchorNode) || $isTabNode(anchorNode)) || !($isCodeHighlightNode(focusNode) || $isTabNode(focusNode))) {\n    return false;\n  }\n  if (!event.altKey) {\n    // Handle moving selection out of the code block, given there are no\n    // siblings that can natively take the selection.\n    if (selection.isCollapsed()) {\n      const codeNode = anchorNode.getParentOrThrow();\n      if (arrowIsUp && anchorOffset === 0 && anchorNode.getPreviousSibling() === null) {\n        const codeNodeSibling = codeNode.getPreviousSibling();\n        if (codeNodeSibling === null) {\n          codeNode.selectPrevious();\n          event.preventDefault();\n          return true;\n        }\n      } else if (!arrowIsUp && anchorOffset === anchorNode.getTextContentSize() && anchorNode.getNextSibling() === null) {\n        const codeNodeSibling = codeNode.getNextSibling();\n        if (codeNodeSibling === null) {\n          codeNode.selectNext();\n          event.preventDefault();\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n  let start;\n  let end;\n  if (anchorNode.isBefore(focusNode)) {\n    start = $getFirstCodeNodeOfLine(anchorNode);\n    end = $getLastCodeNodeOfLine(focusNode);\n  } else {\n    start = $getFirstCodeNodeOfLine(focusNode);\n    end = $getLastCodeNodeOfLine(anchorNode);\n  }\n  if (start == null || end == null) {\n    return false;\n  }\n  const range = start.getNodesBetween(end);\n  for (let i = 0; i < range.length; i++) {\n    const node = range[i];\n    if (!$isCodeHighlightNode(node) && !$isTabNode(node) && !$isLineBreakNode(node)) {\n      return false;\n    }\n  }\n\n  // After this point, we know the selection is within the codeblock. We may not be able to\n  // actually move the lines around, but we want to return true either way to prevent\n  // the event's default behavior\n  event.preventDefault();\n  event.stopPropagation(); // required to stop cursor movement under Firefox\n\n  const linebreak = arrowIsUp ? start.getPreviousSibling() : end.getNextSibling();\n  if (!$isLineBreakNode(linebreak)) {\n    return true;\n  }\n  const sibling = arrowIsUp ? linebreak.getPreviousSibling() : linebreak.getNextSibling();\n  if (sibling == null) {\n    return true;\n  }\n  const maybeInsertionPoint = $isCodeHighlightNode(sibling) || $isTabNode(sibling) || $isLineBreakNode(sibling) ? arrowIsUp ? $getFirstCodeNodeOfLine(sibling) : $getLastCodeNodeOfLine(sibling) : null;\n  let insertionPoint = maybeInsertionPoint != null ? maybeInsertionPoint : sibling;\n  linebreak.remove();\n  range.forEach(node => node.remove());\n  if (type === KEY_ARROW_UP_COMMAND) {\n    range.forEach(node => insertionPoint.insertBefore(node));\n    insertionPoint.insertBefore(linebreak);\n  } else {\n    insertionPoint.insertAfter(linebreak);\n    insertionPoint = linebreak;\n    range.forEach(node => {\n      insertionPoint.insertAfter(node);\n      insertionPoint = node;\n    });\n  }\n  selection.setTextNodeRange(anchorNode, anchorOffset, focusNode, focusOffset);\n  return true;\n}\nfunction $handleMoveTo(type, event) {\n  const selection = $getSelection();\n  if (!$isRangeSelection(selection)) {\n    return false;\n  }\n  const {\n    anchor,\n    focus\n  } = selection;\n  const anchorNode = anchor.getNode();\n  const focusNode = focus.getNode();\n  const isMoveToStart = type === MOVE_TO_START;\n\n  // Ensure the selection is within the codeblock\n  if (!$isSelectionInCode(selection) || !($isCodeHighlightNode(anchorNode) || $isTabNode(anchorNode)) || !($isCodeHighlightNode(focusNode) || $isTabNode(focusNode))) {\n    return false;\n  }\n  if (isMoveToStart) {\n    const start = $getStartOfCodeInLine(focusNode, focus.offset);\n    if (start !== null) {\n      const {\n        node,\n        offset\n      } = start;\n      if ($isLineBreakNode(node)) {\n        node.selectNext(0, 0);\n      } else {\n        selection.setTextNodeRange(node, offset, node, offset);\n      }\n    } else {\n      focusNode.getParentOrThrow().selectStart();\n    }\n  } else {\n    const node = $getEndOfCodeInLine(focusNode);\n    node.select();\n  }\n  event.preventDefault();\n  event.stopPropagation();\n  return true;\n}\nfunction registerCodeHighlighting(editor, tokenizer) {\n  if (!editor.hasNodes([CodeNode, CodeHighlightNode])) {\n    throw new Error('CodeHighlightPlugin: CodeNode or CodeHighlightNode not registered on editor');\n  }\n  if (tokenizer == null) {\n    tokenizer = PrismTokenizer;\n  }\n  const registrations = [];\n\n  // Only register the mutation listener if not in headless mode\n  if (editor._headless !== true) {\n    registrations.push(editor.registerMutationListener(CodeNode, mutations => {\n      editor.update(() => {\n        for (const [key, type] of mutations) {\n          if (type !== 'destroyed') {\n            const node = $getNodeByKey(key);\n            if (node !== null) {\n              updateCodeGutter(node, editor);\n            }\n          }\n        }\n      });\n    }, {\n      skipInitialization: false\n    }));\n  }\n\n  // Add the rest of the registrations\n  registrations.push(editor.registerNodeTransform(CodeNode, node => codeNodeTransform(node, editor, tokenizer)), editor.registerNodeTransform(TextNode, node => $textNodeTransform(node, editor, tokenizer)), editor.registerNodeTransform(CodeHighlightNode, node => $textNodeTransform(node, editor, tokenizer)), editor.registerCommand(KEY_TAB_COMMAND, event => {\n    const command = $handleTab(event.shiftKey);\n    if (command === null) {\n      return false;\n    }\n    event.preventDefault();\n    editor.dispatchCommand(command, undefined);\n    return true;\n  }, COMMAND_PRIORITY_LOW), editor.registerCommand(INSERT_TAB_COMMAND, () => {\n    const selection = $getSelection();\n    if (!$isSelectionInCode(selection)) {\n      return false;\n    }\n    $insertNodes([$createTabNode()]);\n    return true;\n  }, COMMAND_PRIORITY_LOW), editor.registerCommand(INDENT_CONTENT_COMMAND, payload => $handleMultilineIndent(INDENT_CONTENT_COMMAND), COMMAND_PRIORITY_LOW), editor.registerCommand(OUTDENT_CONTENT_COMMAND, payload => $handleMultilineIndent(OUTDENT_CONTENT_COMMAND), COMMAND_PRIORITY_LOW), editor.registerCommand(KEY_ARROW_UP_COMMAND, event => {\n    const selection = $getSelection();\n    if (!$isRangeSelection(selection)) {\n      return false;\n    }\n    const {\n      anchor\n    } = selection;\n    const anchorNode = anchor.getNode();\n    if (!$isSelectionInCode(selection)) {\n      return false;\n    }\n    // If at the start of a code block, prevent selection from moving out\n    if (selection.isCollapsed() && anchor.offset === 0 && anchorNode.getPreviousSibling() === null && $isCodeNode(anchorNode.getParentOrThrow())) {\n      event.preventDefault();\n      return true;\n    }\n    return $handleShiftLines(KEY_ARROW_UP_COMMAND, event);\n  }, COMMAND_PRIORITY_LOW), editor.registerCommand(KEY_ARROW_DOWN_COMMAND, event => {\n    const selection = $getSelection();\n    if (!$isRangeSelection(selection)) {\n      return false;\n    }\n    const {\n      anchor\n    } = selection;\n    const anchorNode = anchor.getNode();\n    if (!$isSelectionInCode(selection)) {\n      return false;\n    }\n    // If at the end of a code block, prevent selection from moving out\n    if (selection.isCollapsed() && anchor.offset === anchorNode.getTextContentSize() && anchorNode.getNextSibling() === null && $isCodeNode(anchorNode.getParentOrThrow())) {\n      event.preventDefault();\n      return true;\n    }\n    return $handleShiftLines(KEY_ARROW_DOWN_COMMAND, event);\n  }, COMMAND_PRIORITY_LOW), editor.registerCommand(MOVE_TO_START, event => $handleMoveTo(MOVE_TO_START, event), COMMAND_PRIORITY_LOW), editor.registerCommand(MOVE_TO_END, event => $handleMoveTo(MOVE_TO_END, event), COMMAND_PRIORITY_LOW));\n  return mergeRegister(...registrations);\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/** @deprecated renamed to {@link $getFirstCodeNodeOfLine} by @lexical/eslint-plugin rules-of-lexical */\nconst getFirstCodeNodeOfLine = $getFirstCodeNodeOfLine;\n/** @deprecated renamed to {@link $getLastCodeNodeOfLine} by @lexical/eslint-plugin rules-of-lexical */\nconst getLastCodeNodeOfLine = $getLastCodeNodeOfLine;\n/** @deprecated renamed to {@link $getEndOfCodeInLine} by @lexical/eslint-plugin rules-of-lexical */\nconst getEndOfCodeInLine = $getEndOfCodeInLine;\n/** @deprecated renamed to {@link $getStartOfCodeInLine} by @lexical/eslint-plugin rules-of-lexical */\nconst getStartOfCodeInLine = $getStartOfCodeInLine;\nexport { $createCodeHighlightNode, $createCodeNode, $getEndOfCodeInLine, $getFirstCodeNodeOfLine, $getLastCodeNodeOfLine, $getStartOfCodeInLine, $isCodeHighlightNode, $isCodeNode, CODE_LANGUAGE_FRIENDLY_NAME_MAP, CODE_LANGUAGE_MAP, CodeHighlightNode, CodeNode, DEFAULT_CODE_LANGUAGE, PrismTokenizer, getCodeLanguages, getDefaultCodeLanguage, getEndOfCodeInLine, getFirstCodeNodeOfLine, getLanguageFriendlyName, getLastCodeNodeOfLine, getStartOfCodeInLine, normalizeCodeLang, registerCodeHighlighting };","map":{"version":3,"names":["isHTMLElement","addClassNamesToElement","removeClassNamesFromElement","$getAdjacentCaret","mergeRegister","ElementNode","$createParagraphNode","$isTextNode","$isTabNode","$createTabNode","$createLineBreakNode","$applyNodeReplacement","TextNode","$getSiblingCaret","$isLineBreakNode","$createTextNode","$getNodeByKey","$getSelection","$isRangeSelection","$createPoint","INDENT_CONTENT_COMMAND","OUTDENT_CONTENT_COMMAND","INSERT_TAB_COMMAND","$setSelectionFromCaretRange","$getCaretRangeInDirection","$getCaretRange","$getTextPointCaret","$normalizeCaret","KEY_ARROW_UP_COMMAND","MOVE_TO_START","KEY_TAB_COMMAND","COMMAND_PRIORITY_LOW","$insertNodes","KEY_ARROW_DOWN_COMMAND","MOVE_TO_END","formatDevErrorMessage","message","Error","invariant","cond","args","Prism","languages","diff","PREFIXES","Object","keys","forEach","name","prefix","alias","test","push","exec","pattern","RegExp","inside","lookbehind","defineProperty","value","Prism$1","globalThis","window","getTextContent","token","Array","isArray","map","join","content","tokenizeDiffHighlight","tokens","language","diffLanguage","diffGrammar","env","type","insertedPrefixes","getPrefixToken","Token","replace","withoutPrefixes","filter","t","prefixCount","length","diffTokens","tokenize","unshift","LINE_BREAK","insertAfterLineBreakString","text","result","lastIndex","last","m","end","index","slice","undefined","insertAfterLineBreak","toks","i","tok","inserted","splice","isLanguageSupportedByPrism","DIFF_LANGUAGE_REGEX","langMatch","hasOwnProperty","_unused","hasChildDOMNodeTag","node","tagName","child","childNodes","LANGUAGE_DATA_ATTRIBUTE","HIGHLIGHT_LANGUAGE_DATA_ATTRIBUTE","CodeNode","getType","clone","__language","__key","constructor","key","__isSyntaxHighlightSupported","createDOM","config","element","document","createElement","theme","code","setAttribute","getLanguage","getIsSyntaxHighlightSupported","updateDOM","prevNode","dom","prevLanguage","removeAttribute","exportDOM","editor","_config","importDOM","isMultiLine","textContent","conversion","$convertPreElement","priority","div","$convertDivElement","pre","table","isGitHubCodeTable","$convertTableElement","td","closest","isGitHubCodeCell","convertCodeNoop","tr","importJSON","serializedNode","$createCodeNode","updateFromJSON","setLanguage","exportJSON","insertNewAfter","selection","restoreSelection","children","getChildren","childrenLength","isCollapsed","anchor","offset","remove","newElement","insertAfter","focus","firstPoint","isBefore","firstSelectionNode","getNode","$getFirstCodeNodeOfLine","insertNodes","getNextSibling","$isCodeHighlightNode","spaces","textSize","getTextContentSize","$createCodeHighlightNode","repeat","split","splitText","x","getIndexWithinParent","codeNode","getParentOrThrow","nodesToInsert","select","selectPrevious","selectNext","$isCodeNode","canIndent","collapseAtStart","paragraph","append","writable","getWritable","getLatest","domNode","getAttribute","isCode","isCodeElement","isCodeChildElement","style","fontFamily","match","parent","parentElement","cell","classList","contains","DEFAULT_CODE_LANGUAGE","CODE_LANGUAGE_FRIENDLY_NAME_MAP","c","clike","cpp","css","html","java","js","markdown","objc","plain","powershell","py","rust","sql","swift","typescript","xml","CODE_LANGUAGE_MAP","javascript","md","plaintext","python","ts","normalizeCodeLang","lang","getLanguageFriendlyName","_lang","getDefaultCodeLanguage","getCodeLanguages","sort","CodeHighlightNode","highlightType","__highlightType","__text","getHighlightType","self","setHighlightType","canHaveFormat","className","getHighlightThemeClass","update","prevClassName","nextClassName","setFormat","format","isParentRequired","createParentElementNode","codeHighlight","$getLastMatchingCodeNode","direction","matchingNode","caret","origin","$getLastCodeNodeOfLine","PrismTokenizer","defaultLanguage","$getStartOfCodeInLine","lastNonBlank","nodeOffset","nodeTextContent","getPreviousSibling","Math","max","character","codeCharacterAtAnchorOffset","nextSibling","nextNonBlank","findNextNonBlankInLine","nodeTextContentSize","$getEndOfCodeInLine","lastNode","$textNodeTransform","tokenizer","parentNode","getParent","codeNodeTransform","updateCodeGutter","codeElement","getElementByKey","getKey","__cachedChildrenLength","gutter","count","nodesCurrentlyHighlighting","Set","nodeKey","has","add","$updateAndRetainSelection","currentNode","isAttached","currentLanguage","diffLanguageMatch","highlightNodes","$getHighlightNodes","diffRange","getDiffRange","from","to","nodesForReplacement","onUpdate","delete","skipTransforms","nodes","partials","partialsLength","part","updateFn","anchorOffset","isNewLineAnchor","getChildAtIndex","textOffset","anchorNode","getPreviousSiblings","reduce","_node","hasChanges","some","isText","textContentSize","prevNodes","nextNodes","leadingMatch","isEqual","prevNodesLength","nextNodesLength","maxTrailingMatch","min","trailingMatch","nodeA","nodeB","$isSelectionInCode","maybeAnchorCodeNode","focusNode","maybeFocusCodeNode","is","$getCodeLines","getNodes","lines","lastLine","selectionEnd","isBackward","lastPoint","$handleTab","shiftKey","indentOrOutdent","tabOrOutdent","codeLines","codeLine","codeLineLength","selectionFirst","selectionLast","firstOfLine","lastOfLine","anchorOfLine","focusOfLine","$handleMultilineIndent","codeLinesLength","tabNode","lineBreakNode","line","insertBefore","anchorKey","anchorLine","set","$handleShiftLines","event","focusOffset","arrowIsUp","altKey","codeNodeSibling","preventDefault","start","range","getNodesBetween","stopPropagation","linebreak","sibling","maybeInsertionPoint","insertionPoint","setTextNodeRange","$handleMoveTo","isMoveToStart","selectStart","registerCodeHighlighting","hasNodes","registrations","_headless","registerMutationListener","mutations","skipInitialization","registerNodeTransform","registerCommand","command","dispatchCommand","payload","getFirstCodeNodeOfLine","getLastCodeNodeOfLine","getEndOfCodeInLine","getStartOfCodeInLine"],"sources":["C:/Code/beedoo/node_modules/@lexical/code/LexicalCode.dev.mjs"],"sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport { isHTMLElement, addClassNamesToElement, removeClassNamesFromElement, $getAdjacentCaret, mergeRegister } from '@lexical/utils';\nimport { ElementNode, $createParagraphNode, $isTextNode, $isTabNode, $createTabNode, $createLineBreakNode, $applyNodeReplacement, TextNode, $getSiblingCaret, $isLineBreakNode, $createTextNode, $getNodeByKey, $getSelection, $isRangeSelection, $createPoint, INDENT_CONTENT_COMMAND, OUTDENT_CONTENT_COMMAND, INSERT_TAB_COMMAND, $setSelectionFromCaretRange, $getCaretRangeInDirection, $getCaretRange, $getTextPointCaret, $normalizeCaret, KEY_ARROW_UP_COMMAND, MOVE_TO_START, KEY_TAB_COMMAND, COMMAND_PRIORITY_LOW, $insertNodes, KEY_ARROW_DOWN_COMMAND, MOVE_TO_END } from 'lexical';\nimport 'prismjs';\nimport 'prismjs/components/prism-clike.js';\nimport 'prismjs/components/prism-javascript.js';\nimport 'prismjs/components/prism-markup.js';\nimport 'prismjs/components/prism-markdown.js';\nimport 'prismjs/components/prism-c.js';\nimport 'prismjs/components/prism-css.js';\nimport 'prismjs/components/prism-objectivec.js';\nimport 'prismjs/components/prism-sql.js';\nimport 'prismjs/components/prism-powershell.js';\nimport 'prismjs/components/prism-python.js';\nimport 'prismjs/components/prism-rust.js';\nimport 'prismjs/components/prism-swift.js';\nimport 'prismjs/components/prism-typescript.js';\nimport 'prismjs/components/prism-java.js';\nimport 'prismjs/components/prism-cpp.js';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n// Do not require this module directly! Use normal `invariant` calls.\n\nfunction formatDevErrorMessage(message) {\n  throw new Error(message);\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n// invariant(condition, message) will refine types based on \"condition\", and\n// if \"condition\" is false will throw an error. This function is special-cased\n// in flow itself, so we can't name it anything else.\nfunction invariant(cond, message, ...args) {\n  if (cond) {\n    return;\n  }\n  throw new Error('Internal Lexical error: invariant() is meant to be replaced at compile ' + 'time. There is no runtime version. Error: ' + message);\n}\n\n(function (Prism) {\n\n\tPrism.languages.diff = {\n\t\t'coord': [\n\t\t\t// Match all kinds of coord lines (prefixed by \"+++\", \"---\" or \"***\").\n\t\t\t/^(?:\\*{3}|-{3}|\\+{3}).*$/m,\n\t\t\t// Match \"@@ ... @@\" coord lines in unified diff.\n\t\t\t/^@@.*@@$/m,\n\t\t\t// Match coord lines in normal diff (starts with a number).\n\t\t\t/^\\d.*$/m\n\t\t]\n\n\t\t// deleted, inserted, unchanged, diff\n\t};\n\n\t/**\n\t * A map from the name of a block to its line prefix.\n\t *\n\t * @type {Object<string, string>}\n\t */\n\tvar PREFIXES = {\n\t\t'deleted-sign': '-',\n\t\t'deleted-arrow': '<',\n\t\t'inserted-sign': '+',\n\t\t'inserted-arrow': '>',\n\t\t'unchanged': ' ',\n\t\t'diff': '!',\n\t};\n\n\t// add a token for each prefix\n\tObject.keys(PREFIXES).forEach(function (name) {\n\t\tvar prefix = PREFIXES[name];\n\n\t\tvar alias = [];\n\t\tif (!/^\\w+$/.test(name)) { // \"deleted-sign\" -> \"deleted\"\n\t\t\talias.push(/\\w+/.exec(name)[0]);\n\t\t}\n\t\tif (name === 'diff') {\n\t\t\talias.push('bold');\n\t\t}\n\n\t\tPrism.languages.diff[name] = {\n\t\t\tpattern: RegExp('^(?:[' + prefix + '].*(?:\\r\\n?|\\n|(?![\\\\s\\\\S])))+', 'm'),\n\t\t\talias: alias,\n\t\t\tinside: {\n\t\t\t\t'line': {\n\t\t\t\t\tpattern: /(.)(?=[\\s\\S]).*(?:\\r\\n?|\\n)?/,\n\t\t\t\t\tlookbehind: true\n\t\t\t\t},\n\t\t\t\t'prefix': {\n\t\t\t\t\tpattern: /[\\s\\S]/,\n\t\t\t\t\talias: /\\w+/.exec(name)[0]\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t});\n\n\t// make prefixes available to Diff plugin\n\tObject.defineProperty(Prism.languages.diff, 'PREFIXES', {\n\t\tvalue: PREFIXES\n\t});\n\n}(Prism));\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst Prism$1 = globalThis.Prism || window.Prism;\n\n// The following code is extracted/adapted from prismjs v2\n// It will probably be possible to use it directly from prism v2\n// in the future when prismjs v2 is published and Lexical upgrades\n// the prismsjs dependency\n\nfunction getTextContent(token) {\n  if (typeof token === 'string') {\n    return token;\n  } else if (Array.isArray(token)) {\n    return token.map(getTextContent).join('');\n  } else {\n    return getTextContent(token.content);\n  }\n}\nfunction tokenizeDiffHighlight(tokens, language) {\n  const diffLanguage = language;\n  const diffGrammar = Prism$1.languages[diffLanguage];\n  const env = {\n    tokens\n  };\n  const PREFIXES = Prism$1.languages.diff.PREFIXES;\n  for (const token of env.tokens) {\n    if (typeof token === 'string' || !(token.type in PREFIXES) || !Array.isArray(token.content)) {\n      continue;\n    }\n    const type = token.type;\n    let insertedPrefixes = 0;\n    const getPrefixToken = () => {\n      insertedPrefixes++;\n      return new Prism$1.Token('prefix', PREFIXES[type], type.replace(/^(\\w+).*/, '$1'));\n    };\n    const withoutPrefixes = token.content.filter(t => typeof t === 'string' || t.type !== 'prefix');\n    const prefixCount = token.content.length - withoutPrefixes.length;\n    const diffTokens = Prism$1.tokenize(getTextContent(withoutPrefixes), diffGrammar);\n\n    // re-insert prefixes\n    // always add a prefix at the start\n    diffTokens.unshift(getPrefixToken());\n    const LINE_BREAK = /\\r\\n|\\n/g;\n    const insertAfterLineBreakString = text => {\n      const result = [];\n      LINE_BREAK.lastIndex = 0;\n      let last = 0;\n      let m;\n      while (insertedPrefixes < prefixCount && (m = LINE_BREAK.exec(text))) {\n        const end = m.index + m[0].length;\n        result.push(text.slice(last, end));\n        last = end;\n        result.push(getPrefixToken());\n      }\n      if (result.length === 0) {\n        return undefined;\n      }\n      if (last < text.length) {\n        result.push(text.slice(last));\n      }\n      return result;\n    };\n    const insertAfterLineBreak = toks => {\n      for (let i = 0; i < toks.length && insertedPrefixes < prefixCount; i++) {\n        const tok = toks[i];\n        if (typeof tok === 'string') {\n          const inserted = insertAfterLineBreakString(tok);\n          if (inserted) {\n            toks.splice(i, 1, ...inserted);\n            i += inserted.length - 1;\n          }\n        } else if (typeof tok.content === 'string') {\n          const inserted = insertAfterLineBreakString(tok.content);\n          if (inserted) {\n            tok.content = inserted;\n          }\n        } else if (Array.isArray(tok.content)) {\n          insertAfterLineBreak(tok.content);\n        } else {\n          insertAfterLineBreak([tok.content]);\n        }\n      }\n    };\n    insertAfterLineBreak(diffTokens);\n    if (insertedPrefixes < prefixCount) {\n      // we are missing the last prefix\n      diffTokens.push(getPrefixToken());\n    }\n    token.content = diffTokens;\n  }\n  return env.tokens;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst isLanguageSupportedByPrism = language => {\n  const DIFF_LANGUAGE_REGEX = /^diff-([\\w-]+)/i;\n  try {\n    if (!language) {\n      return false;\n    }\n    const langMatch = DIFF_LANGUAGE_REGEX.exec(language);\n    if (langMatch) {\n      return (\n        // eslint-disable-next-line no-prototype-builtins\n        Prism$1.languages.hasOwnProperty('diff') &&\n        // eslint-disable-next-line no-prototype-builtins\n        Prism$1.languages.hasOwnProperty(langMatch[1])\n      );\n    } else {\n      // eslint-disable-next-line no-prototype-builtins\n      return Prism$1.languages.hasOwnProperty(language);\n    }\n  } catch (_unused) {\n    return false;\n  }\n};\nfunction hasChildDOMNodeTag(node, tagName) {\n  for (const child of node.childNodes) {\n    if (isHTMLElement(child) && child.tagName === tagName) {\n      return true;\n    }\n    hasChildDOMNodeTag(child, tagName);\n  }\n  return false;\n}\nconst LANGUAGE_DATA_ATTRIBUTE = 'data-language';\nconst HIGHLIGHT_LANGUAGE_DATA_ATTRIBUTE = 'data-highlight-language';\n\n/** @noInheritDoc */\nclass CodeNode extends ElementNode {\n  /** @internal */\n\n  /** @internal */\n\n  static getType() {\n    return 'code';\n  }\n  static clone(node) {\n    return new CodeNode(node.__language, node.__key);\n  }\n  constructor(language, key) {\n    super(key);\n    this.__language = language || undefined;\n    this.__isSyntaxHighlightSupported = isLanguageSupportedByPrism(language);\n  }\n\n  // View\n  createDOM(config) {\n    const element = document.createElement('code');\n    addClassNamesToElement(element, config.theme.code);\n    element.setAttribute('spellcheck', 'false');\n    const language = this.getLanguage();\n    if (language) {\n      element.setAttribute(LANGUAGE_DATA_ATTRIBUTE, language);\n      if (this.getIsSyntaxHighlightSupported()) {\n        element.setAttribute(HIGHLIGHT_LANGUAGE_DATA_ATTRIBUTE, language);\n      }\n    }\n    return element;\n  }\n  updateDOM(prevNode, dom, config) {\n    const language = this.__language;\n    const prevLanguage = prevNode.__language;\n    if (language) {\n      if (language !== prevLanguage) {\n        dom.setAttribute(LANGUAGE_DATA_ATTRIBUTE, language);\n        if (this.__isSyntaxHighlightSupported) {\n          dom.setAttribute(HIGHLIGHT_LANGUAGE_DATA_ATTRIBUTE, language);\n        }\n      }\n    } else if (prevLanguage) {\n      dom.removeAttribute(LANGUAGE_DATA_ATTRIBUTE);\n      if (prevNode.__isSyntaxHighlightSupported) {\n        dom.removeAttribute(HIGHLIGHT_LANGUAGE_DATA_ATTRIBUTE);\n      }\n    }\n    return false;\n  }\n  exportDOM(editor) {\n    const element = document.createElement('pre');\n    addClassNamesToElement(element, editor._config.theme.code);\n    element.setAttribute('spellcheck', 'false');\n    const language = this.getLanguage();\n    if (language) {\n      element.setAttribute(LANGUAGE_DATA_ATTRIBUTE, language);\n      if (this.getIsSyntaxHighlightSupported()) {\n        element.setAttribute(HIGHLIGHT_LANGUAGE_DATA_ATTRIBUTE, language);\n      }\n    }\n    return {\n      element\n    };\n  }\n  static importDOM() {\n    return {\n      // Typically <pre> is used for code blocks, and <code> for inline code styles\n      // but if it's a multi line <code> we'll create a block. Pass through to\n      // inline format handled by TextNode otherwise.\n      code: node => {\n        const isMultiLine = node.textContent != null && (/\\r?\\n/.test(node.textContent) || hasChildDOMNodeTag(node, 'BR'));\n        return isMultiLine ? {\n          conversion: $convertPreElement,\n          priority: 1\n        } : null;\n      },\n      div: () => ({\n        conversion: $convertDivElement,\n        priority: 1\n      }),\n      pre: () => ({\n        conversion: $convertPreElement,\n        priority: 0\n      }),\n      table: node => {\n        const table = node;\n        // domNode is a <table> since we matched it by nodeName\n        if (isGitHubCodeTable(table)) {\n          return {\n            conversion: $convertTableElement,\n            priority: 3\n          };\n        }\n        return null;\n      },\n      td: node => {\n        // element is a <td> since we matched it by nodeName\n        const td = node;\n        const table = td.closest('table');\n        if (isGitHubCodeCell(td) || table && isGitHubCodeTable(table)) {\n          // Return a no-op if it's a table cell in a code table, but not a code line.\n          // Otherwise it'll fall back to the T\n          return {\n            conversion: convertCodeNoop,\n            priority: 3\n          };\n        }\n        return null;\n      },\n      tr: node => {\n        // element is a <tr> since we matched it by nodeName\n        const tr = node;\n        const table = tr.closest('table');\n        if (table && isGitHubCodeTable(table)) {\n          return {\n            conversion: convertCodeNoop,\n            priority: 3\n          };\n        }\n        return null;\n      }\n    };\n  }\n  static importJSON(serializedNode) {\n    return $createCodeNode().updateFromJSON(serializedNode);\n  }\n  updateFromJSON(serializedNode) {\n    return super.updateFromJSON(serializedNode).setLanguage(serializedNode.language);\n  }\n  exportJSON() {\n    return {\n      ...super.exportJSON(),\n      language: this.getLanguage()\n    };\n  }\n\n  // Mutation\n  insertNewAfter(selection, restoreSelection = true) {\n    const children = this.getChildren();\n    const childrenLength = children.length;\n    if (childrenLength >= 2 && children[childrenLength - 1].getTextContent() === '\\n' && children[childrenLength - 2].getTextContent() === '\\n' && selection.isCollapsed() && selection.anchor.key === this.__key && selection.anchor.offset === childrenLength) {\n      children[childrenLength - 1].remove();\n      children[childrenLength - 2].remove();\n      const newElement = $createParagraphNode();\n      this.insertAfter(newElement, restoreSelection);\n      return newElement;\n    }\n\n    // If the selection is within the codeblock, find all leading tabs and\n    // spaces of the current line. Create a new line that has all those\n    // tabs and spaces, such that leading indentation is preserved.\n    const {\n      anchor,\n      focus\n    } = selection;\n    const firstPoint = anchor.isBefore(focus) ? anchor : focus;\n    const firstSelectionNode = firstPoint.getNode();\n    if ($isTextNode(firstSelectionNode)) {\n      let node = $getFirstCodeNodeOfLine(firstSelectionNode);\n      const insertNodes = [];\n      // eslint-disable-next-line no-constant-condition\n      while (true) {\n        if ($isTabNode(node)) {\n          insertNodes.push($createTabNode());\n          node = node.getNextSibling();\n        } else if ($isCodeHighlightNode(node)) {\n          let spaces = 0;\n          const text = node.getTextContent();\n          const textSize = node.getTextContentSize();\n          while (spaces < textSize && text[spaces] === ' ') {\n            spaces++;\n          }\n          if (spaces !== 0) {\n            insertNodes.push($createCodeHighlightNode(' '.repeat(spaces)));\n          }\n          if (spaces !== textSize) {\n            break;\n          }\n          node = node.getNextSibling();\n        } else {\n          break;\n        }\n      }\n      const split = firstSelectionNode.splitText(anchor.offset)[0];\n      const x = anchor.offset === 0 ? 0 : 1;\n      const index = split.getIndexWithinParent() + x;\n      const codeNode = firstSelectionNode.getParentOrThrow();\n      const nodesToInsert = [$createLineBreakNode(), ...insertNodes];\n      codeNode.splice(index, 0, nodesToInsert);\n      const last = insertNodes[insertNodes.length - 1];\n      if (last) {\n        last.select();\n      } else if (anchor.offset === 0) {\n        split.selectPrevious();\n      } else {\n        split.getNextSibling().selectNext(0, 0);\n      }\n    }\n    if ($isCodeNode(firstSelectionNode)) {\n      const {\n        offset\n      } = selection.anchor;\n      firstSelectionNode.splice(offset, 0, [$createLineBreakNode()]);\n      firstSelectionNode.select(offset + 1, offset + 1);\n    }\n    return null;\n  }\n  canIndent() {\n    return false;\n  }\n  collapseAtStart() {\n    const paragraph = $createParagraphNode();\n    const children = this.getChildren();\n    children.forEach(child => paragraph.append(child));\n    this.replace(paragraph);\n    return true;\n  }\n  setLanguage(language) {\n    const writable = this.getWritable();\n    writable.__language = language || undefined;\n    writable.__isSyntaxHighlightSupported = isLanguageSupportedByPrism(language);\n    return writable;\n  }\n  getLanguage() {\n    return this.getLatest().__language;\n  }\n  getIsSyntaxHighlightSupported() {\n    return this.getLatest().__isSyntaxHighlightSupported;\n  }\n}\nfunction $createCodeNode(language) {\n  return $applyNodeReplacement(new CodeNode(language));\n}\nfunction $isCodeNode(node) {\n  return node instanceof CodeNode;\n}\nfunction $convertPreElement(domNode) {\n  const language = domNode.getAttribute(LANGUAGE_DATA_ATTRIBUTE);\n  return {\n    node: $createCodeNode(language)\n  };\n}\nfunction $convertDivElement(domNode) {\n  // domNode is a <div> since we matched it by nodeName\n  const div = domNode;\n  const isCode = isCodeElement(div);\n  if (!isCode && !isCodeChildElement(div)) {\n    return {\n      node: null\n    };\n  }\n  return {\n    node: isCode ? $createCodeNode() : null\n  };\n}\nfunction $convertTableElement() {\n  return {\n    node: $createCodeNode()\n  };\n}\nfunction convertCodeNoop() {\n  return {\n    node: null\n  };\n}\nfunction isCodeElement(div) {\n  return div.style.fontFamily.match('monospace') !== null;\n}\nfunction isCodeChildElement(node) {\n  let parent = node.parentElement;\n  while (parent !== null) {\n    if (isCodeElement(parent)) {\n      return true;\n    }\n    parent = parent.parentElement;\n  }\n  return false;\n}\nfunction isGitHubCodeCell(cell) {\n  return cell.classList.contains('js-file-line');\n}\nfunction isGitHubCodeTable(table) {\n  return table.classList.contains('js-file-line-container');\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst DEFAULT_CODE_LANGUAGE = 'javascript';\nconst CODE_LANGUAGE_FRIENDLY_NAME_MAP = {\n  c: 'C',\n  clike: 'C-like',\n  cpp: 'C++',\n  css: 'CSS',\n  html: 'HTML',\n  java: 'Java',\n  js: 'JavaScript',\n  markdown: 'Markdown',\n  objc: 'Objective-C',\n  plain: 'Plain Text',\n  powershell: 'PowerShell',\n  py: 'Python',\n  rust: 'Rust',\n  sql: 'SQL',\n  swift: 'Swift',\n  typescript: 'TypeScript',\n  xml: 'XML'\n};\nconst CODE_LANGUAGE_MAP = {\n  cpp: 'cpp',\n  java: 'java',\n  javascript: 'js',\n  md: 'markdown',\n  plaintext: 'plain',\n  python: 'py',\n  text: 'plain',\n  ts: 'typescript'\n};\nfunction normalizeCodeLang(lang) {\n  return CODE_LANGUAGE_MAP[lang] || lang;\n}\nfunction getLanguageFriendlyName(lang) {\n  const _lang = normalizeCodeLang(lang);\n  return CODE_LANGUAGE_FRIENDLY_NAME_MAP[_lang] || _lang;\n}\nconst getDefaultCodeLanguage = () => DEFAULT_CODE_LANGUAGE;\nconst getCodeLanguages = () => Object.keys(Prism$1.languages).filter(\n// Prism has several language helpers mixed into languages object\n// so filtering them out here to get langs list\nlanguage => typeof Prism$1.languages[language] !== 'function').sort();\n\n/** @noInheritDoc */\nclass CodeHighlightNode extends TextNode {\n  /** @internal */\n\n  constructor(text = '', highlightType, key) {\n    super(text, key);\n    this.__highlightType = highlightType;\n  }\n  static getType() {\n    return 'code-highlight';\n  }\n  static clone(node) {\n    return new CodeHighlightNode(node.__text, node.__highlightType || undefined, node.__key);\n  }\n  getHighlightType() {\n    const self = this.getLatest();\n    return self.__highlightType;\n  }\n  setHighlightType(highlightType) {\n    const self = this.getWritable();\n    self.__highlightType = highlightType || undefined;\n    return self;\n  }\n  canHaveFormat() {\n    return false;\n  }\n  createDOM(config) {\n    const element = super.createDOM(config);\n    const className = getHighlightThemeClass(config.theme, this.__highlightType);\n    addClassNamesToElement(element, className);\n    return element;\n  }\n  updateDOM(prevNode, dom, config) {\n    const update = super.updateDOM(prevNode, dom, config);\n    const prevClassName = getHighlightThemeClass(config.theme, prevNode.__highlightType);\n    const nextClassName = getHighlightThemeClass(config.theme, this.__highlightType);\n    if (prevClassName !== nextClassName) {\n      if (prevClassName) {\n        removeClassNamesFromElement(dom, prevClassName);\n      }\n      if (nextClassName) {\n        addClassNamesToElement(dom, nextClassName);\n      }\n    }\n    return update;\n  }\n  static importJSON(serializedNode) {\n    return $createCodeHighlightNode().updateFromJSON(serializedNode);\n  }\n  updateFromJSON(serializedNode) {\n    return super.updateFromJSON(serializedNode).setHighlightType(serializedNode.highlightType);\n  }\n  exportJSON() {\n    return {\n      ...super.exportJSON(),\n      highlightType: this.getHighlightType()\n    };\n  }\n\n  // Prevent formatting (bold, underline, etc)\n  setFormat(format) {\n    return this;\n  }\n  isParentRequired() {\n    return true;\n  }\n  createParentElementNode() {\n    return $createCodeNode();\n  }\n}\nfunction getHighlightThemeClass(theme, highlightType) {\n  return highlightType && theme && theme.codeHighlight && theme.codeHighlight[highlightType];\n}\nfunction $createCodeHighlightNode(text = '', highlightType) {\n  return $applyNodeReplacement(new CodeHighlightNode(text, highlightType));\n}\nfunction $isCodeHighlightNode(node) {\n  return node instanceof CodeHighlightNode;\n}\nfunction $getLastMatchingCodeNode(anchor, direction) {\n  let matchingNode = anchor;\n  for (let caret = $getSiblingCaret(anchor, direction); caret && ($isCodeHighlightNode(caret.origin) || $isTabNode(caret.origin)); caret = $getAdjacentCaret(caret)) {\n    matchingNode = caret.origin;\n  }\n  return matchingNode;\n}\nfunction $getFirstCodeNodeOfLine(anchor) {\n  return $getLastMatchingCodeNode(anchor, 'previous');\n}\nfunction $getLastCodeNodeOfLine(anchor) {\n  return $getLastMatchingCodeNode(anchor, 'next');\n}\n\nconst PrismTokenizer = {\n  defaultLanguage: DEFAULT_CODE_LANGUAGE,\n  tokenize(code, language) {\n    return Prism$1.tokenize(code, Prism$1.languages[language || ''] || Prism$1.languages[this.defaultLanguage]);\n  }\n};\nfunction $getStartOfCodeInLine(anchor, offset) {\n  let last = null;\n  let lastNonBlank = null;\n  let node = anchor;\n  let nodeOffset = offset;\n  let nodeTextContent = anchor.getTextContent();\n  // eslint-disable-next-line no-constant-condition\n  while (true) {\n    if (nodeOffset === 0) {\n      node = node.getPreviousSibling();\n      if (node === null) {\n        break;\n      }\n      if (!($isCodeHighlightNode(node) || $isTabNode(node) || $isLineBreakNode(node))) {\n        formatDevErrorMessage(`Expected a valid Code Node: CodeHighlightNode, TabNode, LineBreakNode`);\n      }\n      if ($isLineBreakNode(node)) {\n        last = {\n          node,\n          offset: 1\n        };\n        break;\n      }\n      nodeOffset = Math.max(0, node.getTextContentSize() - 1);\n      nodeTextContent = node.getTextContent();\n    } else {\n      nodeOffset--;\n    }\n    const character = nodeTextContent[nodeOffset];\n    if ($isCodeHighlightNode(node) && character !== ' ') {\n      lastNonBlank = {\n        node,\n        offset: nodeOffset\n      };\n    }\n  }\n  // lastNonBlank !== null: anchor in the middle of code; move to line beginning\n  if (lastNonBlank !== null) {\n    return lastNonBlank;\n  }\n  // Spaces, tabs or nothing ahead of anchor\n  let codeCharacterAtAnchorOffset = null;\n  if (offset < anchor.getTextContentSize()) {\n    if ($isCodeHighlightNode(anchor)) {\n      codeCharacterAtAnchorOffset = anchor.getTextContent()[offset];\n    }\n  } else {\n    const nextSibling = anchor.getNextSibling();\n    if ($isCodeHighlightNode(nextSibling)) {\n      codeCharacterAtAnchorOffset = nextSibling.getTextContent()[0];\n    }\n  }\n  if (codeCharacterAtAnchorOffset !== null && codeCharacterAtAnchorOffset !== ' ') {\n    // Borderline whitespace and code, move to line beginning\n    return last;\n  } else {\n    const nextNonBlank = findNextNonBlankInLine(anchor, offset);\n    if (nextNonBlank !== null) {\n      return nextNonBlank;\n    } else {\n      return last;\n    }\n  }\n}\nfunction findNextNonBlankInLine(anchor, offset) {\n  let node = anchor;\n  let nodeOffset = offset;\n  let nodeTextContent = anchor.getTextContent();\n  let nodeTextContentSize = anchor.getTextContentSize();\n  // eslint-disable-next-line no-constant-condition\n  while (true) {\n    if (!$isCodeHighlightNode(node) || nodeOffset === nodeTextContentSize) {\n      node = node.getNextSibling();\n      if (node === null || $isLineBreakNode(node)) {\n        return null;\n      }\n      if ($isCodeHighlightNode(node)) {\n        nodeOffset = 0;\n        nodeTextContent = node.getTextContent();\n        nodeTextContentSize = node.getTextContentSize();\n      }\n    }\n    if ($isCodeHighlightNode(node)) {\n      if (nodeTextContent[nodeOffset] !== ' ') {\n        return {\n          node,\n          offset: nodeOffset\n        };\n      }\n      nodeOffset++;\n    }\n  }\n}\nfunction $getEndOfCodeInLine(anchor) {\n  const lastNode = $getLastCodeNodeOfLine(anchor);\n  if (!!$isLineBreakNode(lastNode)) {\n    formatDevErrorMessage(`Unexpected lineBreakNode in getEndOfCodeInLine`);\n  }\n  return lastNode;\n}\nfunction $textNodeTransform(node, editor, tokenizer) {\n  // Since CodeNode has flat children structure we only need to check\n  // if node's parent is a code node and run highlighting if so\n  const parentNode = node.getParent();\n  if ($isCodeNode(parentNode)) {\n    codeNodeTransform(parentNode, editor, tokenizer);\n  } else if ($isCodeHighlightNode(node)) {\n    // When code block converted into paragraph or other element\n    // code highlight nodes converted back to normal text\n    node.replace($createTextNode(node.__text));\n  }\n}\nfunction updateCodeGutter(node, editor) {\n  const codeElement = editor.getElementByKey(node.getKey());\n  if (codeElement === null) {\n    return;\n  }\n  const children = node.getChildren();\n  const childrenLength = children.length;\n  // @ts-ignore: internal field\n  if (childrenLength === codeElement.__cachedChildrenLength) {\n    // Avoid updating the attribute if the children length hasn't changed.\n    return;\n  }\n  // @ts-ignore:: internal field\n  codeElement.__cachedChildrenLength = childrenLength;\n  let gutter = '1';\n  let count = 1;\n  for (let i = 0; i < childrenLength; i++) {\n    if ($isLineBreakNode(children[i])) {\n      gutter += '\\n' + ++count;\n    }\n  }\n  codeElement.setAttribute('data-gutter', gutter);\n}\n\n// Using `skipTransforms` to prevent extra transforms since reformatting the code\n// will not affect code block content itself.\n//\n// Using extra cache (`nodesCurrentlyHighlighting`) since both CodeNode and CodeHighlightNode\n// transforms might be called at the same time (e.g. new CodeHighlight node inserted) and\n// in both cases we'll rerun whole reformatting over CodeNode, which is redundant.\n// Especially when pasting code into CodeBlock.\n\nconst nodesCurrentlyHighlighting = new Set();\nfunction codeNodeTransform(node, editor, tokenizer) {\n  const nodeKey = node.getKey();\n  if (nodesCurrentlyHighlighting.has(nodeKey)) {\n    return;\n  }\n  nodesCurrentlyHighlighting.add(nodeKey);\n\n  // When new code block inserted it might not have language selected\n  if (node.getLanguage() === undefined) {\n    node.setLanguage(tokenizer.defaultLanguage);\n  }\n\n  // Using nested update call to pass `skipTransforms` since we don't want\n  // each individual CodeHighlightNode to be transformed again as it's already\n  // in its final state\n  editor.update(() => {\n    $updateAndRetainSelection(nodeKey, () => {\n      const currentNode = $getNodeByKey(nodeKey);\n      if (!$isCodeNode(currentNode) || !currentNode.isAttached()) {\n        return false;\n      }\n      const DIFF_LANGUAGE_REGEX = /^diff-([\\w-]+)/i;\n      const currentLanguage = currentNode.getLanguage() || tokenizer.defaultLanguage;\n      const diffLanguageMatch = DIFF_LANGUAGE_REGEX.exec(currentLanguage);\n      const code = currentNode.getTextContent();\n      let tokens = tokenizer.tokenize(code, diffLanguageMatch ? 'diff' : currentLanguage);\n      if (diffLanguageMatch) {\n        tokens = tokenizeDiffHighlight(tokens, diffLanguageMatch[1]);\n      }\n      const highlightNodes = $getHighlightNodes(tokens);\n      const diffRange = getDiffRange(currentNode.getChildren(), highlightNodes);\n      const {\n        from,\n        to,\n        nodesForReplacement\n      } = diffRange;\n      if (from !== to || nodesForReplacement.length) {\n        node.splice(from, to - from, nodesForReplacement);\n        return true;\n      }\n      return false;\n    });\n  }, {\n    onUpdate: () => {\n      nodesCurrentlyHighlighting.delete(nodeKey);\n    },\n    skipTransforms: true\n  });\n}\nfunction $getHighlightNodes(tokens, type) {\n  const nodes = [];\n  for (const token of tokens) {\n    if (typeof token === 'string') {\n      const partials = token.split(/(\\n|\\t)/);\n      const partialsLength = partials.length;\n      for (let i = 0; i < partialsLength; i++) {\n        const part = partials[i];\n        if (part === '\\n' || part === '\\r\\n') {\n          nodes.push($createLineBreakNode());\n        } else if (part === '\\t') {\n          nodes.push($createTabNode());\n        } else if (part.length > 0) {\n          nodes.push($createCodeHighlightNode(part, type));\n        }\n      }\n    } else {\n      const {\n        content,\n        alias\n      } = token;\n      if (typeof content === 'string') {\n        nodes.push(...$getHighlightNodes([content], token.type === 'prefix' && typeof alias === 'string' ? alias : token.type));\n      } else if (Array.isArray(content)) {\n        nodes.push(...$getHighlightNodes(content, token.type === 'unchanged' ? undefined : token.type));\n      }\n    }\n  }\n  return nodes;\n}\n\n// Wrapping update function into selection retainer, that tries to keep cursor at the same\n// position as before.\nfunction $updateAndRetainSelection(nodeKey, updateFn) {\n  const node = $getNodeByKey(nodeKey);\n  if (!$isCodeNode(node) || !node.isAttached()) {\n    return;\n  }\n  const selection = $getSelection();\n  // If it's not range selection (or null selection) there's no need to change it,\n  // but we can still run highlighting logic\n  if (!$isRangeSelection(selection)) {\n    updateFn();\n    return;\n  }\n  const anchor = selection.anchor;\n  const anchorOffset = anchor.offset;\n  const isNewLineAnchor = anchor.type === 'element' && $isLineBreakNode(node.getChildAtIndex(anchor.offset - 1));\n  let textOffset = 0;\n\n  // Calculating previous text offset (all text node prior to anchor + anchor own text offset)\n  if (!isNewLineAnchor) {\n    const anchorNode = anchor.getNode();\n    textOffset = anchorOffset + anchorNode.getPreviousSiblings().reduce((offset, _node) => {\n      return offset + _node.getTextContentSize();\n    }, 0);\n  }\n  const hasChanges = updateFn();\n  if (!hasChanges) {\n    return;\n  }\n\n  // Non-text anchors only happen for line breaks, otherwise\n  // selection will be within text node (code highlight node)\n  if (isNewLineAnchor) {\n    anchor.getNode().select(anchorOffset, anchorOffset);\n    return;\n  }\n\n  // If it was non-element anchor then we walk through child nodes\n  // and looking for a position of original text offset\n  node.getChildren().some(_node => {\n    const isText = $isTextNode(_node);\n    if (isText || $isLineBreakNode(_node)) {\n      const textContentSize = _node.getTextContentSize();\n      if (isText && textContentSize >= textOffset) {\n        _node.select(textOffset, textOffset);\n        return true;\n      }\n      textOffset -= textContentSize;\n    }\n    return false;\n  });\n}\n\n// Finds minimal diff range between two nodes lists. It returns from/to range boundaries of prevNodes\n// that needs to be replaced with `nodes` (subset of nextNodes) to make prevNodes equal to nextNodes.\nfunction getDiffRange(prevNodes, nextNodes) {\n  let leadingMatch = 0;\n  while (leadingMatch < prevNodes.length) {\n    if (!isEqual(prevNodes[leadingMatch], nextNodes[leadingMatch])) {\n      break;\n    }\n    leadingMatch++;\n  }\n  const prevNodesLength = prevNodes.length;\n  const nextNodesLength = nextNodes.length;\n  const maxTrailingMatch = Math.min(prevNodesLength, nextNodesLength) - leadingMatch;\n  let trailingMatch = 0;\n  while (trailingMatch < maxTrailingMatch) {\n    trailingMatch++;\n    if (!isEqual(prevNodes[prevNodesLength - trailingMatch], nextNodes[nextNodesLength - trailingMatch])) {\n      trailingMatch--;\n      break;\n    }\n  }\n  const from = leadingMatch;\n  const to = prevNodesLength - trailingMatch;\n  const nodesForReplacement = nextNodes.slice(leadingMatch, nextNodesLength - trailingMatch);\n  return {\n    from,\n    nodesForReplacement,\n    to\n  };\n}\nfunction isEqual(nodeA, nodeB) {\n  // Only checking for code highlight nodes, tabs and linebreaks. If it's regular text node\n  // returning false so that it's transformed into code highlight node\n  return $isCodeHighlightNode(nodeA) && $isCodeHighlightNode(nodeB) && nodeA.__text === nodeB.__text && nodeA.__highlightType === nodeB.__highlightType || $isTabNode(nodeA) && $isTabNode(nodeB) || $isLineBreakNode(nodeA) && $isLineBreakNode(nodeB);\n}\n\n/**\n * Returns a boolean.\n * Check that the selection span is within a single CodeNode.\n * This is used to guard against executing handlers that can only be\n * applied in a single CodeNode context\n */\nfunction $isSelectionInCode(selection) {\n  if (!$isRangeSelection(selection)) {\n    return false;\n  }\n  const anchorNode = selection.anchor.getNode();\n  const maybeAnchorCodeNode = $isCodeNode(anchorNode) ? anchorNode : anchorNode.getParent();\n  const focusNode = selection.focus.getNode();\n  const maybeFocusCodeNode = $isCodeNode(focusNode) ? focusNode : focusNode.getParent();\n  return $isCodeNode(maybeAnchorCodeNode) && maybeAnchorCodeNode.is(maybeFocusCodeNode);\n}\n\n/**\n * Returns an Array of code lines\n * Take the sequence of LineBreakNode | TabNode | CodeHighlightNode forming\n * the selection and split it by LineBreakNode.\n * If the selection ends at the start of the last line, it is considered empty.\n * Empty lines are discarded.\n */\nfunction $getCodeLines(selection) {\n  const nodes = selection.getNodes();\n  const lines = [];\n  if (nodes.length === 1 && $isCodeNode(nodes[0])) {\n    return lines;\n  }\n  let lastLine = [];\n  for (let i = 0; i < nodes.length; i++) {\n    const node = nodes[i];\n    if (!($isCodeHighlightNode(node) || $isTabNode(node) || $isLineBreakNode(node))) {\n      formatDevErrorMessage(`Expected selection to be inside CodeBlock and consisting of CodeHighlightNode, TabNode and LineBreakNode`);\n    }\n    if ($isLineBreakNode(node)) {\n      if (lastLine.length > 0) {\n        lines.push(lastLine);\n        lastLine = [];\n      }\n    } else {\n      lastLine.push(node);\n    }\n  }\n  if (lastLine.length > 0) {\n    const selectionEnd = selection.isBackward() ? selection.anchor : selection.focus;\n\n    // Discard the last line if the selection ends exactly at the\n    // start of the line (no real selection)\n    const lastPoint = $createPoint(lastLine[0].getKey(), 0, 'text');\n    if (!selectionEnd.is(lastPoint)) {\n      lines.push(lastLine);\n    }\n  }\n  return lines;\n}\nfunction $handleTab(shiftKey) {\n  const selection = $getSelection();\n  if (!$isRangeSelection(selection) || !$isSelectionInCode(selection)) {\n    return null;\n  }\n  const indentOrOutdent = !shiftKey ? INDENT_CONTENT_COMMAND : OUTDENT_CONTENT_COMMAND;\n  const tabOrOutdent = !shiftKey ? INSERT_TAB_COMMAND : OUTDENT_CONTENT_COMMAND;\n  const anchor = selection.anchor;\n  const focus = selection.focus;\n\n  // 1. early decision when there is no real selection\n  if (anchor.is(focus)) {\n    return tabOrOutdent;\n  }\n\n  // 2. If only empty lines or multiple non-empty lines are selected: indent/outdent\n  const codeLines = $getCodeLines(selection);\n  if (codeLines.length !== 1) {\n    return indentOrOutdent;\n  }\n  const codeLine = codeLines[0];\n  const codeLineLength = codeLine.length;\n  if (!(codeLineLength !== 0)) {\n    formatDevErrorMessage(`$getCodeLines only extracts non-empty lines`);\n  } // Take into account the direction of the selection\n  let selectionFirst;\n  let selectionLast;\n  if (selection.isBackward()) {\n    selectionFirst = focus;\n    selectionLast = anchor;\n  } else {\n    selectionFirst = anchor;\n    selectionLast = focus;\n  }\n\n  // find boundary elements of the line\n  // since codeLine only contains TabNode | CodeHighlightNode\n  // the result of these functions should is of Type TabNode | CodeHighlightNode\n  const firstOfLine = $getFirstCodeNodeOfLine(codeLine[0]);\n  const lastOfLine = $getLastCodeNodeOfLine(codeLine[0]);\n  const anchorOfLine = $createPoint(firstOfLine.getKey(), 0, 'text');\n  const focusOfLine = $createPoint(lastOfLine.getKey(), lastOfLine.getTextContentSize(), 'text');\n\n  // 3. multiline because selection started strictly before the line\n  if (selectionFirst.isBefore(anchorOfLine)) {\n    return indentOrOutdent;\n  }\n\n  // 4. multiline because the selection stops strictly after the line\n  if (focusOfLine.isBefore(selectionLast)) {\n    return indentOrOutdent;\n  }\n\n  // The selection if within the line.\n  // 4. If it does not touch both borders, it needs a tab\n  if (anchorOfLine.isBefore(selectionFirst) || selectionLast.isBefore(focusOfLine)) {\n    return tabOrOutdent;\n  }\n\n  // 5. Selection is matching a full line on non-empty code\n  return indentOrOutdent;\n}\nfunction $handleMultilineIndent(type) {\n  const selection = $getSelection();\n  if (!$isRangeSelection(selection) || !$isSelectionInCode(selection)) {\n    return false;\n  }\n  const codeLines = $getCodeLines(selection);\n  const codeLinesLength = codeLines.length;\n\n  // Special Indent case\n  // Selection is collapsed at the beginning of a line\n  if (codeLinesLength === 0 && selection.isCollapsed()) {\n    if (type === INDENT_CONTENT_COMMAND) {\n      selection.insertNodes([$createTabNode()]);\n    }\n    return true;\n  }\n\n  // Special Indent case\n  // Selection is matching only one LineBreak\n  if (codeLinesLength === 0 && type === INDENT_CONTENT_COMMAND && selection.getTextContent() === '\\n') {\n    const tabNode = $createTabNode();\n    const lineBreakNode = $createLineBreakNode();\n    const direction = selection.isBackward() ? 'previous' : 'next';\n    selection.insertNodes([tabNode, lineBreakNode]);\n    $setSelectionFromCaretRange($getCaretRangeInDirection($getCaretRange($getTextPointCaret(tabNode, 'next', 0), $normalizeCaret($getSiblingCaret(lineBreakNode, 'next'))), direction));\n    return true;\n  }\n\n  // Indent Non Empty Lines\n  for (let i = 0; i < codeLinesLength; i++) {\n    const line = codeLines[i];\n    // a line here is never empty\n    if (line.length > 0) {\n      let firstOfLine = line[0];\n\n      // make sure to consider the first node on the first line\n      // because the line might not be fully selected\n      if (i === 0) {\n        firstOfLine = $getFirstCodeNodeOfLine(firstOfLine);\n      }\n      if (type === INDENT_CONTENT_COMMAND) {\n        const tabNode = $createTabNode();\n        firstOfLine.insertBefore(tabNode);\n        // First real code line may need selection adjustment\n        // when firstOfLine is at the selection boundary\n        if (i === 0) {\n          const anchorKey = selection.isBackward() ? 'focus' : 'anchor';\n          const anchorLine = $createPoint(firstOfLine.getKey(), 0, 'text');\n          if (selection[anchorKey].is(anchorLine)) {\n            selection[anchorKey].set(tabNode.getKey(), 0, 'text');\n          }\n        }\n      } else if ($isTabNode(firstOfLine)) {\n        firstOfLine.remove();\n      }\n    }\n  }\n  return true;\n}\nfunction $handleShiftLines(type, event) {\n  // We only care about the alt+arrow keys\n  const selection = $getSelection();\n  if (!$isRangeSelection(selection)) {\n    return false;\n  }\n\n  // I'm not quite sure why, but it seems like calling anchor.getNode() collapses the selection here\n  // So first, get the anchor and the focus, then get their nodes\n  const {\n    anchor,\n    focus\n  } = selection;\n  const anchorOffset = anchor.offset;\n  const focusOffset = focus.offset;\n  const anchorNode = anchor.getNode();\n  const focusNode = focus.getNode();\n  const arrowIsUp = type === KEY_ARROW_UP_COMMAND;\n\n  // Ensure the selection is within the codeblock\n  if (!$isSelectionInCode(selection) || !($isCodeHighlightNode(anchorNode) || $isTabNode(anchorNode)) || !($isCodeHighlightNode(focusNode) || $isTabNode(focusNode))) {\n    return false;\n  }\n  if (!event.altKey) {\n    // Handle moving selection out of the code block, given there are no\n    // siblings that can natively take the selection.\n    if (selection.isCollapsed()) {\n      const codeNode = anchorNode.getParentOrThrow();\n      if (arrowIsUp && anchorOffset === 0 && anchorNode.getPreviousSibling() === null) {\n        const codeNodeSibling = codeNode.getPreviousSibling();\n        if (codeNodeSibling === null) {\n          codeNode.selectPrevious();\n          event.preventDefault();\n          return true;\n        }\n      } else if (!arrowIsUp && anchorOffset === anchorNode.getTextContentSize() && anchorNode.getNextSibling() === null) {\n        const codeNodeSibling = codeNode.getNextSibling();\n        if (codeNodeSibling === null) {\n          codeNode.selectNext();\n          event.preventDefault();\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n  let start;\n  let end;\n  if (anchorNode.isBefore(focusNode)) {\n    start = $getFirstCodeNodeOfLine(anchorNode);\n    end = $getLastCodeNodeOfLine(focusNode);\n  } else {\n    start = $getFirstCodeNodeOfLine(focusNode);\n    end = $getLastCodeNodeOfLine(anchorNode);\n  }\n  if (start == null || end == null) {\n    return false;\n  }\n  const range = start.getNodesBetween(end);\n  for (let i = 0; i < range.length; i++) {\n    const node = range[i];\n    if (!$isCodeHighlightNode(node) && !$isTabNode(node) && !$isLineBreakNode(node)) {\n      return false;\n    }\n  }\n\n  // After this point, we know the selection is within the codeblock. We may not be able to\n  // actually move the lines around, but we want to return true either way to prevent\n  // the event's default behavior\n  event.preventDefault();\n  event.stopPropagation(); // required to stop cursor movement under Firefox\n\n  const linebreak = arrowIsUp ? start.getPreviousSibling() : end.getNextSibling();\n  if (!$isLineBreakNode(linebreak)) {\n    return true;\n  }\n  const sibling = arrowIsUp ? linebreak.getPreviousSibling() : linebreak.getNextSibling();\n  if (sibling == null) {\n    return true;\n  }\n  const maybeInsertionPoint = $isCodeHighlightNode(sibling) || $isTabNode(sibling) || $isLineBreakNode(sibling) ? arrowIsUp ? $getFirstCodeNodeOfLine(sibling) : $getLastCodeNodeOfLine(sibling) : null;\n  let insertionPoint = maybeInsertionPoint != null ? maybeInsertionPoint : sibling;\n  linebreak.remove();\n  range.forEach(node => node.remove());\n  if (type === KEY_ARROW_UP_COMMAND) {\n    range.forEach(node => insertionPoint.insertBefore(node));\n    insertionPoint.insertBefore(linebreak);\n  } else {\n    insertionPoint.insertAfter(linebreak);\n    insertionPoint = linebreak;\n    range.forEach(node => {\n      insertionPoint.insertAfter(node);\n      insertionPoint = node;\n    });\n  }\n  selection.setTextNodeRange(anchorNode, anchorOffset, focusNode, focusOffset);\n  return true;\n}\nfunction $handleMoveTo(type, event) {\n  const selection = $getSelection();\n  if (!$isRangeSelection(selection)) {\n    return false;\n  }\n  const {\n    anchor,\n    focus\n  } = selection;\n  const anchorNode = anchor.getNode();\n  const focusNode = focus.getNode();\n  const isMoveToStart = type === MOVE_TO_START;\n\n  // Ensure the selection is within the codeblock\n  if (!$isSelectionInCode(selection) || !($isCodeHighlightNode(anchorNode) || $isTabNode(anchorNode)) || !($isCodeHighlightNode(focusNode) || $isTabNode(focusNode))) {\n    return false;\n  }\n  if (isMoveToStart) {\n    const start = $getStartOfCodeInLine(focusNode, focus.offset);\n    if (start !== null) {\n      const {\n        node,\n        offset\n      } = start;\n      if ($isLineBreakNode(node)) {\n        node.selectNext(0, 0);\n      } else {\n        selection.setTextNodeRange(node, offset, node, offset);\n      }\n    } else {\n      focusNode.getParentOrThrow().selectStart();\n    }\n  } else {\n    const node = $getEndOfCodeInLine(focusNode);\n    node.select();\n  }\n  event.preventDefault();\n  event.stopPropagation();\n  return true;\n}\nfunction registerCodeHighlighting(editor, tokenizer) {\n  if (!editor.hasNodes([CodeNode, CodeHighlightNode])) {\n    throw new Error('CodeHighlightPlugin: CodeNode or CodeHighlightNode not registered on editor');\n  }\n  if (tokenizer == null) {\n    tokenizer = PrismTokenizer;\n  }\n  const registrations = [];\n\n  // Only register the mutation listener if not in headless mode\n  if (editor._headless !== true) {\n    registrations.push(editor.registerMutationListener(CodeNode, mutations => {\n      editor.update(() => {\n        for (const [key, type] of mutations) {\n          if (type !== 'destroyed') {\n            const node = $getNodeByKey(key);\n            if (node !== null) {\n              updateCodeGutter(node, editor);\n            }\n          }\n        }\n      });\n    }, {\n      skipInitialization: false\n    }));\n  }\n\n  // Add the rest of the registrations\n  registrations.push(editor.registerNodeTransform(CodeNode, node => codeNodeTransform(node, editor, tokenizer)), editor.registerNodeTransform(TextNode, node => $textNodeTransform(node, editor, tokenizer)), editor.registerNodeTransform(CodeHighlightNode, node => $textNodeTransform(node, editor, tokenizer)), editor.registerCommand(KEY_TAB_COMMAND, event => {\n    const command = $handleTab(event.shiftKey);\n    if (command === null) {\n      return false;\n    }\n    event.preventDefault();\n    editor.dispatchCommand(command, undefined);\n    return true;\n  }, COMMAND_PRIORITY_LOW), editor.registerCommand(INSERT_TAB_COMMAND, () => {\n    const selection = $getSelection();\n    if (!$isSelectionInCode(selection)) {\n      return false;\n    }\n    $insertNodes([$createTabNode()]);\n    return true;\n  }, COMMAND_PRIORITY_LOW), editor.registerCommand(INDENT_CONTENT_COMMAND, payload => $handleMultilineIndent(INDENT_CONTENT_COMMAND), COMMAND_PRIORITY_LOW), editor.registerCommand(OUTDENT_CONTENT_COMMAND, payload => $handleMultilineIndent(OUTDENT_CONTENT_COMMAND), COMMAND_PRIORITY_LOW), editor.registerCommand(KEY_ARROW_UP_COMMAND, event => {\n    const selection = $getSelection();\n    if (!$isRangeSelection(selection)) {\n      return false;\n    }\n    const {\n      anchor\n    } = selection;\n    const anchorNode = anchor.getNode();\n    if (!$isSelectionInCode(selection)) {\n      return false;\n    }\n    // If at the start of a code block, prevent selection from moving out\n    if (selection.isCollapsed() && anchor.offset === 0 && anchorNode.getPreviousSibling() === null && $isCodeNode(anchorNode.getParentOrThrow())) {\n      event.preventDefault();\n      return true;\n    }\n    return $handleShiftLines(KEY_ARROW_UP_COMMAND, event);\n  }, COMMAND_PRIORITY_LOW), editor.registerCommand(KEY_ARROW_DOWN_COMMAND, event => {\n    const selection = $getSelection();\n    if (!$isRangeSelection(selection)) {\n      return false;\n    }\n    const {\n      anchor\n    } = selection;\n    const anchorNode = anchor.getNode();\n    if (!$isSelectionInCode(selection)) {\n      return false;\n    }\n    // If at the end of a code block, prevent selection from moving out\n    if (selection.isCollapsed() && anchor.offset === anchorNode.getTextContentSize() && anchorNode.getNextSibling() === null && $isCodeNode(anchorNode.getParentOrThrow())) {\n      event.preventDefault();\n      return true;\n    }\n    return $handleShiftLines(KEY_ARROW_DOWN_COMMAND, event);\n  }, COMMAND_PRIORITY_LOW), editor.registerCommand(MOVE_TO_START, event => $handleMoveTo(MOVE_TO_START, event), COMMAND_PRIORITY_LOW), editor.registerCommand(MOVE_TO_END, event => $handleMoveTo(MOVE_TO_END, event), COMMAND_PRIORITY_LOW));\n  return mergeRegister(...registrations);\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n/** @deprecated renamed to {@link $getFirstCodeNodeOfLine} by @lexical/eslint-plugin rules-of-lexical */\nconst getFirstCodeNodeOfLine = $getFirstCodeNodeOfLine;\n/** @deprecated renamed to {@link $getLastCodeNodeOfLine} by @lexical/eslint-plugin rules-of-lexical */\nconst getLastCodeNodeOfLine = $getLastCodeNodeOfLine;\n/** @deprecated renamed to {@link $getEndOfCodeInLine} by @lexical/eslint-plugin rules-of-lexical */\nconst getEndOfCodeInLine = $getEndOfCodeInLine;\n/** @deprecated renamed to {@link $getStartOfCodeInLine} by @lexical/eslint-plugin rules-of-lexical */\nconst getStartOfCodeInLine = $getStartOfCodeInLine;\n\nexport { $createCodeHighlightNode, $createCodeNode, $getEndOfCodeInLine, $getFirstCodeNodeOfLine, $getLastCodeNodeOfLine, $getStartOfCodeInLine, $isCodeHighlightNode, $isCodeNode, CODE_LANGUAGE_FRIENDLY_NAME_MAP, CODE_LANGUAGE_MAP, CodeHighlightNode, CodeNode, DEFAULT_CODE_LANGUAGE, PrismTokenizer, getCodeLanguages, getDefaultCodeLanguage, getEndOfCodeInLine, getFirstCodeNodeOfLine, getLanguageFriendlyName, getLastCodeNodeOfLine, getStartOfCodeInLine, normalizeCodeLang, registerCodeHighlighting };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}