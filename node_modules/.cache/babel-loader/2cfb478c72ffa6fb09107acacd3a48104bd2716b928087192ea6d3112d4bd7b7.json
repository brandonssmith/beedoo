{"ast":null,"code":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport { isHTMLElement, $getSelection, $isRangeSelection, $isElementNode, getDOMTextNode, $getRoot, $getChildCaret, $getSiblingCaret, $getAdjacentChildCaret, $getChildCaretOrSelf, makeStepwiseIterator, $isChildCaret, $cloneWithProperties, $setSelection, $getPreviousSelection, $caretFromPoint, $createParagraphNode, $normalizeCaret, $setSelectionFromCaretRange, $getCollapsedCaretRange, $getCaretInDirection, $splitAtPointCaretNext, $isTextPointCaret, $isSiblingCaret, $rewindSiblingCaret, $getState, $setState } from 'lexical';\nexport { $splitNode, isBlockDomNode, isHTMLAnchorElement, isHTMLElement, isInlineDomNode } from 'lexical';\nimport { createRectsFromDOMRange } from '@lexical/selection';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n// Do not require this module directly! Use normal `invariant` calls.\n\nfunction formatDevErrorMessage(message) {\n  throw new Error(message);\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst CAN_USE_DOM$1 = typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst documentMode = CAN_USE_DOM$1 && 'documentMode' in document ? document.documentMode : null;\nconst IS_APPLE$1 = CAN_USE_DOM$1 && /Mac|iPod|iPhone|iPad/.test(navigator.platform);\nconst IS_FIREFOX$1 = CAN_USE_DOM$1 && /^(?!.*Seamonkey)(?=.*Firefox).*/i.test(navigator.userAgent);\nconst CAN_USE_BEFORE_INPUT$1 = CAN_USE_DOM$1 && 'InputEvent' in window && !documentMode ? 'getTargetRanges' in new window.InputEvent('input') : false;\nconst IS_SAFARI$1 = CAN_USE_DOM$1 && /Version\\/[\\d.]+.*Safari/.test(navigator.userAgent);\nconst IS_IOS$1 = CAN_USE_DOM$1 && /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;\nconst IS_ANDROID$1 = CAN_USE_DOM$1 && /Android/.test(navigator.userAgent);\n\n// Keep these in case we need to use them in the future.\n// export const IS_WINDOWS: boolean = CAN_USE_DOM && /Win/.test(navigator.platform);\nconst IS_CHROME$1 = CAN_USE_DOM$1 && /^(?=.*Chrome).*/i.test(navigator.userAgent);\n// export const canUseTextInputEvent: boolean = CAN_USE_DOM && 'TextEvent' in window && !documentMode;\n\nconst IS_ANDROID_CHROME$1 = CAN_USE_DOM$1 && IS_ANDROID$1 && IS_CHROME$1;\nconst IS_APPLE_WEBKIT$1 = CAN_USE_DOM$1 && /AppleWebKit\\/[\\d.]+/.test(navigator.userAgent) && !IS_CHROME$1;\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction normalizeClassNames(...classNames) {\n  const rval = [];\n  for (const className of classNames) {\n    if (className && typeof className === 'string') {\n      for (const [s] of className.matchAll(/\\S+/g)) {\n        rval.push(s);\n      }\n    }\n  }\n  return rval;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/**\n * Returns a function that will execute all functions passed when called. It is generally used\n * to register multiple lexical listeners and then tear them down with a single function call, such\n * as React's useEffect hook.\n * @example\n * ```ts\n * useEffect(() => {\n *   return mergeRegister(\n *     editor.registerCommand(...registerCommand1 logic),\n *     editor.registerCommand(...registerCommand2 logic),\n *     editor.registerCommand(...registerCommand3 logic)\n *   )\n * }, [editor])\n * ```\n * In this case, useEffect is returning the function returned by mergeRegister as a cleanup\n * function to be executed after either the useEffect runs again (due to one of its dependencies\n * updating) or the component it resides in unmounts.\n * Note the functions don't necessarily need to be in an array as all arguments\n * are considered to be the func argument and spread from there.\n * The order of cleanup is the reverse of the argument order. Generally it is\n * expected that the first \"acquire\" will be \"released\" last (LIFO order),\n * because a later step may have some dependency on an earlier one.\n * @param func - An array of cleanup functions meant to be executed by the returned function.\n * @returns the function which executes all the passed cleanup functions.\n */\nfunction mergeRegister(...func) {\n  return () => {\n    for (let i = func.length - 1; i >= 0; i--) {\n      func[i]();\n    }\n    // Clean up the references and make future calls a no-op\n    func.length = 0;\n  };\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction px(value) {\n  return `${value}px`;\n}\nconst mutationObserverConfig = {\n  attributes: true,\n  characterData: true,\n  childList: true,\n  subtree: true\n};\nfunction prependDOMNode(parent, node) {\n  parent.insertBefore(node, parent.firstChild);\n}\n\n/**\n * Place one or multiple newly created Nodes at the passed Range's position.\n * Multiple nodes will only be created when the Range spans multiple lines (aka\n * client rects).\n *\n * This function can come particularly useful to highlight particular parts of\n * the text without interfering with the EditorState, that will often replicate\n * the state across collab and clipboard.\n *\n * This function accounts for DOM updates which can modify the passed Range.\n * Hence, the function return to remove the listener.\n */\nfunction mlcPositionNodeOnRange(editor, range, onReposition) {\n  let rootDOMNode = null;\n  let parentDOMNode = null;\n  let observer = null;\n  let lastNodes = [];\n  const wrapperNode = document.createElement('div');\n  wrapperNode.style.position = 'relative';\n  function position() {\n    if (!(rootDOMNode !== null)) {\n      formatDevErrorMessage(`Unexpected null rootDOMNode`);\n    }\n    if (!(parentDOMNode !== null)) {\n      formatDevErrorMessage(`Unexpected null parentDOMNode`);\n    }\n    const {\n      left: parentLeft,\n      top: parentTop\n    } = parentDOMNode.getBoundingClientRect();\n    const rects = createRectsFromDOMRange(editor, range);\n    if (!wrapperNode.isConnected) {\n      prependDOMNode(parentDOMNode, wrapperNode);\n    }\n    let hasRepositioned = false;\n    for (let i = 0; i < rects.length; i++) {\n      const rect = rects[i];\n      // Try to reuse the previously created Node when possible, no need to\n      // remove/create on the most common case reposition case\n      const rectNode = lastNodes[i] || document.createElement('div');\n      const rectNodeStyle = rectNode.style;\n      if (rectNodeStyle.position !== 'absolute') {\n        rectNodeStyle.position = 'absolute';\n        hasRepositioned = true;\n      }\n      const left = px(rect.left - parentLeft);\n      if (rectNodeStyle.left !== left) {\n        rectNodeStyle.left = left;\n        hasRepositioned = true;\n      }\n      const top = px(rect.top - parentTop);\n      if (rectNodeStyle.top !== top) {\n        rectNode.style.top = top;\n        hasRepositioned = true;\n      }\n      const width = px(rect.width);\n      if (rectNodeStyle.width !== width) {\n        rectNode.style.width = width;\n        hasRepositioned = true;\n      }\n      const height = px(rect.height);\n      if (rectNodeStyle.height !== height) {\n        rectNode.style.height = height;\n        hasRepositioned = true;\n      }\n      if (rectNode.parentNode !== wrapperNode) {\n        wrapperNode.append(rectNode);\n        hasRepositioned = true;\n      }\n      lastNodes[i] = rectNode;\n    }\n    while (lastNodes.length > rects.length) {\n      lastNodes.pop();\n    }\n    if (hasRepositioned) {\n      onReposition(lastNodes);\n    }\n  }\n  function stop() {\n    parentDOMNode = null;\n    rootDOMNode = null;\n    if (observer !== null) {\n      observer.disconnect();\n    }\n    observer = null;\n    wrapperNode.remove();\n    for (const node of lastNodes) {\n      node.remove();\n    }\n    lastNodes = [];\n  }\n  function restart() {\n    const currentRootDOMNode = editor.getRootElement();\n    if (currentRootDOMNode === null) {\n      return stop();\n    }\n    const currentParentDOMNode = currentRootDOMNode.parentElement;\n    if (!isHTMLElement(currentParentDOMNode)) {\n      return stop();\n    }\n    stop();\n    rootDOMNode = currentRootDOMNode;\n    parentDOMNode = currentParentDOMNode;\n    observer = new MutationObserver(mutations => {\n      const nextRootDOMNode = editor.getRootElement();\n      const nextParentDOMNode = nextRootDOMNode && nextRootDOMNode.parentElement;\n      if (nextRootDOMNode !== rootDOMNode || nextParentDOMNode !== parentDOMNode) {\n        return restart();\n      }\n      for (const mutation of mutations) {\n        if (!wrapperNode.contains(mutation.target)) {\n          // TODO throttle\n          return position();\n        }\n      }\n    });\n    observer.observe(currentParentDOMNode, mutationObserverConfig);\n    position();\n  }\n  const removeRootListener = editor.registerRootListener(restart);\n  return () => {\n    removeRootListener();\n    stop();\n  };\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction rangeTargetFromPoint(point, node, dom) {\n  if (point.type === 'text' || !$isElementNode(node)) {\n    const textDOM = getDOMTextNode(dom) || dom;\n    return [textDOM, point.offset];\n  } else {\n    const slot = node.getDOMSlot(dom);\n    return [slot.element, slot.getFirstChildOffset() + point.offset];\n  }\n}\nfunction rangeFromPoints(editor, anchor, anchorNode, anchorDOM, focus, focusNode, focusDOM) {\n  const editorDocument = editor._window ? editor._window.document : document;\n  const range = editorDocument.createRange();\n  if (focusNode.isBefore(anchorNode)) {\n    range.setStart(...rangeTargetFromPoint(focus, focusNode, focusDOM));\n    range.setEnd(...rangeTargetFromPoint(anchor, anchorNode, anchorDOM));\n  } else {\n    range.setStart(...rangeTargetFromPoint(anchor, anchorNode, anchorDOM));\n    range.setEnd(...rangeTargetFromPoint(focus, focusNode, focusDOM));\n  }\n  return range;\n}\n/**\n * Place one or multiple newly created Nodes at the current selection. Multiple\n * nodes will only be created when the selection spans multiple lines (aka\n * client rects).\n *\n * This function can come useful when you want to show the selection but the\n * editor has been focused away.\n */\nfunction markSelection(editor, onReposition) {\n  let previousAnchorNode = null;\n  let previousAnchorNodeDOM = null;\n  let previousAnchorOffset = null;\n  let previousFocusNode = null;\n  let previousFocusNodeDOM = null;\n  let previousFocusOffset = null;\n  let removeRangeListener = () => {};\n  function compute(editorState) {\n    editorState.read(() => {\n      const selection = $getSelection();\n      if (!$isRangeSelection(selection)) {\n        // TODO\n        previousAnchorNode = null;\n        previousAnchorOffset = null;\n        previousFocusNode = null;\n        previousFocusOffset = null;\n        removeRangeListener();\n        removeRangeListener = () => {};\n        return;\n      }\n      const {\n        anchor,\n        focus\n      } = selection;\n      const currentAnchorNode = anchor.getNode();\n      const currentAnchorNodeKey = currentAnchorNode.getKey();\n      const currentAnchorOffset = anchor.offset;\n      const currentFocusNode = focus.getNode();\n      const currentFocusNodeKey = currentFocusNode.getKey();\n      const currentFocusOffset = focus.offset;\n      const currentAnchorNodeDOM = editor.getElementByKey(currentAnchorNodeKey);\n      const currentFocusNodeDOM = editor.getElementByKey(currentFocusNodeKey);\n      const differentAnchorDOM = previousAnchorNode === null || currentAnchorNodeDOM !== previousAnchorNodeDOM || currentAnchorOffset !== previousAnchorOffset || currentAnchorNodeKey !== previousAnchorNode.getKey();\n      const differentFocusDOM = previousFocusNode === null || currentFocusNodeDOM !== previousFocusNodeDOM || currentFocusOffset !== previousFocusOffset || currentFocusNodeKey !== previousFocusNode.getKey();\n      if ((differentAnchorDOM || differentFocusDOM) && currentAnchorNodeDOM !== null && currentFocusNodeDOM !== null) {\n        const range = rangeFromPoints(editor, anchor, currentAnchorNode, currentAnchorNodeDOM, focus, currentFocusNode, currentFocusNodeDOM);\n        removeRangeListener();\n        removeRangeListener = mlcPositionNodeOnRange(editor, range, domNodes => {\n          if (onReposition === undefined) {\n            for (const domNode of domNodes) {\n              const domNodeStyle = domNode.style;\n              if (domNodeStyle.background !== 'Highlight') {\n                domNodeStyle.background = 'Highlight';\n              }\n              if (domNodeStyle.color !== 'HighlightText') {\n                domNodeStyle.color = 'HighlightText';\n              }\n              if (domNodeStyle.marginTop !== px(-1.5)) {\n                domNodeStyle.marginTop = px(-1.5);\n              }\n              if (domNodeStyle.paddingTop !== px(4)) {\n                domNodeStyle.paddingTop = px(4);\n              }\n              if (domNodeStyle.paddingBottom !== px(0)) {\n                domNodeStyle.paddingBottom = px(0);\n              }\n            }\n          } else {\n            onReposition(domNodes);\n          }\n        });\n      }\n      previousAnchorNode = currentAnchorNode;\n      previousAnchorNodeDOM = currentAnchorNodeDOM;\n      previousAnchorOffset = currentAnchorOffset;\n      previousFocusNode = currentFocusNode;\n      previousFocusNodeDOM = currentFocusNodeDOM;\n      previousFocusOffset = currentFocusOffset;\n    });\n  }\n  compute(editor.getEditorState());\n  return mergeRegister(editor.registerUpdateListener(({\n    editorState\n  }) => compute(editorState)), () => {\n    removeRangeListener();\n  });\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction selectionAlwaysOnDisplay(editor) {\n  let removeSelectionMark = null;\n  const onSelectionChange = () => {\n    const domSelection = getSelection();\n    const domAnchorNode = domSelection && domSelection.anchorNode;\n    const editorRootElement = editor.getRootElement();\n    const isSelectionInsideEditor = domAnchorNode !== null && editorRootElement !== null && editorRootElement.contains(domAnchorNode);\n    if (isSelectionInsideEditor) {\n      if (removeSelectionMark !== null) {\n        removeSelectionMark();\n        removeSelectionMark = null;\n      }\n    } else {\n      if (removeSelectionMark === null) {\n        removeSelectionMark = markSelection(editor);\n      }\n    }\n  };\n  document.addEventListener('selectionchange', onSelectionChange);\n  return () => {\n    if (removeSelectionMark !== null) {\n      removeSelectionMark();\n    }\n    document.removeEventListener('selectionchange', onSelectionChange);\n  };\n}\n\n// Hotfix to export these with inlined types #5918\nconst CAN_USE_BEFORE_INPUT = CAN_USE_BEFORE_INPUT$1;\nconst CAN_USE_DOM = CAN_USE_DOM$1;\nconst IS_ANDROID = IS_ANDROID$1;\nconst IS_ANDROID_CHROME = IS_ANDROID_CHROME$1;\nconst IS_APPLE = IS_APPLE$1;\nconst IS_APPLE_WEBKIT = IS_APPLE_WEBKIT$1;\nconst IS_CHROME = IS_CHROME$1;\nconst IS_FIREFOX = IS_FIREFOX$1;\nconst IS_IOS = IS_IOS$1;\nconst IS_SAFARI = IS_SAFARI$1;\n\n/**\n * Takes an HTML element and adds the classNames passed within an array,\n * ignoring any non-string types. A space can be used to add multiple classes\n * eg. addClassNamesToElement(element, ['element-inner active', true, null])\n * will add both 'element-inner' and 'active' as classes to that element.\n * @param element - The element in which the classes are added\n * @param classNames - An array defining the class names to add to the element\n */\nfunction addClassNamesToElement(element, ...classNames) {\n  const classesToAdd = normalizeClassNames(...classNames);\n  if (classesToAdd.length > 0) {\n    element.classList.add(...classesToAdd);\n  }\n}\n\n/**\n * Takes an HTML element and removes the classNames passed within an array,\n * ignoring any non-string types. A space can be used to remove multiple classes\n * eg. removeClassNamesFromElement(element, ['active small', true, null])\n * will remove both the 'active' and 'small' classes from that element.\n * @param element - The element in which the classes are removed\n * @param classNames - An array defining the class names to remove from the element\n */\nfunction removeClassNamesFromElement(element, ...classNames) {\n  const classesToRemove = normalizeClassNames(...classNames);\n  if (classesToRemove.length > 0) {\n    element.classList.remove(...classesToRemove);\n  }\n}\n\n/**\n * Returns true if the file type matches the types passed within the acceptableMimeTypes array, false otherwise.\n * The types passed must be strings and are CASE-SENSITIVE.\n * eg. if file is of type 'text' and acceptableMimeTypes = ['TEXT', 'IMAGE'] the function will return false.\n * @param file - The file you want to type check.\n * @param acceptableMimeTypes - An array of strings of types which the file is checked against.\n * @returns true if the file is an acceptable mime type, false otherwise.\n */\nfunction isMimeType(file, acceptableMimeTypes) {\n  for (const acceptableType of acceptableMimeTypes) {\n    if (file.type.startsWith(acceptableType)) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * Lexical File Reader with:\n *  1. MIME type support\n *  2. batched results (HistoryPlugin compatibility)\n *  3. Order aware (respects the order when multiple Files are passed)\n *\n * const filesResult = await mediaFileReader(files, ['image/']);\n * filesResult.forEach(file => editor.dispatchCommand('INSERT_IMAGE', \\\\{\n *   src: file.result,\n * \\\\}));\n */\nfunction mediaFileReader(files, acceptableMimeTypes) {\n  const filesIterator = files[Symbol.iterator]();\n  return new Promise((resolve, reject) => {\n    const processed = [];\n    const handleNextFile = () => {\n      const {\n        done,\n        value: file\n      } = filesIterator.next();\n      if (done) {\n        return resolve(processed);\n      }\n      const fileReader = new FileReader();\n      fileReader.addEventListener('error', reject);\n      fileReader.addEventListener('load', () => {\n        const result = fileReader.result;\n        if (typeof result === 'string') {\n          processed.push({\n            file,\n            result\n          });\n        }\n        handleNextFile();\n      });\n      if (isMimeType(file, acceptableMimeTypes)) {\n        fileReader.readAsDataURL(file);\n      } else {\n        handleNextFile();\n      }\n    };\n    handleNextFile();\n  });\n}\n/**\n * \"Depth-First Search\" starts at the root/top node of a tree and goes as far as it can down a branch end\n * before backtracking and finding a new path. Consider solving a maze by hugging either wall, moving down a\n * branch until you hit a dead-end (leaf) and backtracking to find the nearest branching path and repeat.\n * It will then return all the nodes found in the search in an array of objects.\n * @param startNode - The node to start the search, if omitted, it will start at the root node.\n * @param endNode - The node to end the search, if omitted, it will find all descendants of the startingNode.\n * @returns An array of objects of all the nodes found by the search, including their depth into the tree.\n * \\\\{depth: number, node: LexicalNode\\\\} It will always return at least 1 node (the start node).\n */\nfunction $dfs(startNode, endNode) {\n  return Array.from($dfsIterator(startNode, endNode));\n}\n\n/**\n * Get the adjacent caret in the same direction\n *\n * @param caret A caret or null\n * @returns `caret.getAdjacentCaret()` or `null`\n */\nfunction $getAdjacentCaret(caret) {\n  return caret ? caret.getAdjacentCaret() : null;\n}\n\n/**\n * $dfs iterator (right to left). Tree traversal is done on the fly as new values are requested with O(1) memory.\n * @param startNode - The node to start the search, if omitted, it will start at the root node.\n * @param endNode - The node to end the search, if omitted, it will find all descendants of the startingNode.\n * @returns An iterator, each yielded value is a DFSNode. It will always return at least 1 node (the start node).\n */\nfunction $reverseDfs(startNode, endNode) {\n  return Array.from($reverseDfsIterator(startNode, endNode));\n}\n\n/**\n * $dfs iterator (left to right). Tree traversal is done on the fly as new values are requested with O(1) memory.\n * @param startNode - The node to start the search, if omitted, it will start at the root node.\n * @param endNode - The node to end the search, if omitted, it will find all descendants of the startingNode.\n * @returns An iterator, each yielded value is a DFSNode. It will always return at least 1 node (the start node).\n */\nfunction $dfsIterator(startNode, endNode) {\n  return $dfsCaretIterator('next', startNode, endNode);\n}\nfunction $getEndCaret(startNode, direction) {\n  const rval = $getAdjacentSiblingOrParentSiblingCaret($getSiblingCaret(startNode, direction));\n  return rval && rval[0];\n}\nfunction $dfsCaretIterator(direction, startNode, endNode) {\n  const root = $getRoot();\n  const start = startNode || root;\n  const startCaret = $isElementNode(start) ? $getChildCaret(start, direction) : $getSiblingCaret(start, direction);\n  const startDepth = $getDepth(start);\n  const endCaret = endNode ? $getAdjacentChildCaret($getChildCaretOrSelf($getSiblingCaret(endNode, direction))) : $getEndCaret(start, direction);\n  let depth = startDepth;\n  return makeStepwiseIterator({\n    hasNext: state => state !== null,\n    initial: startCaret,\n    map: state => ({\n      depth,\n      node: state.origin\n    }),\n    step: state => {\n      if (state.isSameNodeCaret(endCaret)) {\n        return null;\n      }\n      if ($isChildCaret(state)) {\n        depth++;\n      }\n      const rval = $getAdjacentSiblingOrParentSiblingCaret(state);\n      if (!rval || rval[0].isSameNodeCaret(endCaret)) {\n        return null;\n      }\n      depth += rval[1];\n      return rval[0];\n    }\n  });\n}\n\n/**\n * Returns the Node sibling when this exists, otherwise the closest parent sibling. For example\n * R -> P -> T1, T2\n *   -> P2\n * returns T2 for node T1, P2 for node T2, and null for node P2.\n * @param node LexicalNode.\n * @returns An array (tuple) containing the found Lexical node and the depth difference, or null, if this node doesn't exist.\n */\nfunction $getNextSiblingOrParentSibling(node) {\n  const rval = $getAdjacentSiblingOrParentSiblingCaret($getSiblingCaret(node, 'next'));\n  return rval && [rval[0].origin, rval[1]];\n}\nfunction $getDepth(node) {\n  let depth = -1;\n  for (let innerNode = node; innerNode !== null; innerNode = innerNode.getParent()) {\n    depth++;\n  }\n  return depth;\n}\n\n/**\n * Performs a right-to-left preorder tree traversal.\n * From the starting node it goes to the rightmost child, than backtracks to parent and finds new rightmost path.\n * It will return the next node in traversal sequence after the startingNode.\n * The traversal is similar to $dfs functions above, but the nodes are visited right-to-left, not left-to-right.\n * @param startingNode - The node to start the search.\n * @returns The next node in pre-order right to left traversal sequence or `null`, if the node does not exist\n */\nfunction $getNextRightPreorderNode(startingNode) {\n  const startCaret = $getChildCaretOrSelf($getSiblingCaret(startingNode, 'previous'));\n  const next = $getAdjacentSiblingOrParentSiblingCaret(startCaret, 'root');\n  return next && next[0].origin;\n}\n\n/**\n * $dfs iterator (right to left). Tree traversal is done on the fly as new values are requested with O(1) memory.\n * @param startNode - The node to start the search, if omitted, it will start at the root node.\n * @param endNode - The node to end the search, if omitted, it will find all descendants of the startingNode.\n * @returns An iterator, each yielded value is a DFSNode. It will always return at least 1 node (the start node).\n */\nfunction $reverseDfsIterator(startNode, endNode) {\n  return $dfsCaretIterator('previous', startNode, endNode);\n}\n\n/**\n * Takes a node and traverses up its ancestors (toward the root node)\n * in order to find a specific type of node.\n * @param node - the node to begin searching.\n * @param klass - an instance of the type of node to look for.\n * @returns the node of type klass that was passed, or null if none exist.\n */\nfunction $getNearestNodeOfType(node, klass) {\n  let parent = node;\n  while (parent != null) {\n    if (parent instanceof klass) {\n      return parent;\n    }\n    parent = parent.getParent();\n  }\n  return null;\n}\n\n/**\n * Returns the element node of the nearest ancestor, otherwise throws an error.\n * @param startNode - The starting node of the search\n * @returns The ancestor node found\n */\nfunction $getNearestBlockElementAncestorOrThrow(startNode) {\n  const blockNode = $findMatchingParent(startNode, node => $isElementNode(node) && !node.isInline());\n  if (!$isElementNode(blockNode)) {\n    {\n      formatDevErrorMessage(`Expected node ${startNode.__key} to have closest block element node.`);\n    }\n  }\n  return blockNode;\n}\n/**\n * Starts with a node and moves up the tree (toward the root node) to find a matching node based on\n * the search parameters of the findFn. (Consider JavaScripts' .find() function where a testing function must be\n * passed as an argument. eg. if( (node) => node.__type === 'div') ) return true; otherwise return false\n * @param startingNode - The node where the search starts.\n * @param findFn - A testing function that returns true if the current node satisfies the testing parameters.\n * @returns A parent node that matches the findFn parameters, or null if one wasn't found.\n */\nconst $findMatchingParent = (startingNode, findFn) => {\n  let curr = startingNode;\n  while (curr !== $getRoot() && curr != null) {\n    if (findFn(curr)) {\n      return curr;\n    }\n    curr = curr.getParent();\n  }\n  return null;\n};\n\n/**\n * Attempts to resolve nested element nodes of the same type into a single node of that type.\n * It is generally used for marks/commenting\n * @param editor - The lexical editor\n * @param targetNode - The target for the nested element to be extracted from.\n * @param cloneNode - See {@link $createMarkNode}\n * @param handleOverlap - Handles any overlap between the node to extract and the targetNode\n * @returns The lexical editor\n */\nfunction registerNestedElementResolver(editor, targetNode, cloneNode, handleOverlap) {\n  const $isTargetNode = node => {\n    return node instanceof targetNode;\n  };\n  const $findMatch = node => {\n    // First validate we don't have any children that are of the target,\n    // as we need to handle them first.\n    const children = node.getChildren();\n    for (let i = 0; i < children.length; i++) {\n      const child = children[i];\n      if ($isTargetNode(child)) {\n        return null;\n      }\n    }\n    let parentNode = node;\n    let childNode = node;\n    while (parentNode !== null) {\n      childNode = parentNode;\n      parentNode = parentNode.getParent();\n      if ($isTargetNode(parentNode)) {\n        return {\n          child: childNode,\n          parent: parentNode\n        };\n      }\n    }\n    return null;\n  };\n  const $elementNodeTransform = node => {\n    const match = $findMatch(node);\n    if (match !== null) {\n      const {\n        child,\n        parent\n      } = match;\n\n      // Simple path, we can move child out and siblings into a new parent.\n\n      if (child.is(node)) {\n        handleOverlap(parent, node);\n        const nextSiblings = child.getNextSiblings();\n        const nextSiblingsLength = nextSiblings.length;\n        parent.insertAfter(child);\n        if (nextSiblingsLength !== 0) {\n          const newParent = cloneNode(parent);\n          child.insertAfter(newParent);\n          for (let i = 0; i < nextSiblingsLength; i++) {\n            newParent.append(nextSiblings[i]);\n          }\n        }\n        if (!parent.canBeEmpty() && parent.getChildrenSize() === 0) {\n          parent.remove();\n        }\n      }\n    }\n  };\n  return editor.registerNodeTransform(targetNode, $elementNodeTransform);\n}\n\n/**\n * Clones the editor and marks it as dirty to be reconciled. If there was a selection,\n * it would be set back to its previous state, or null otherwise.\n * @param editor - The lexical editor\n * @param editorState - The editor's state\n */\nfunction $restoreEditorState(editor, editorState) {\n  const FULL_RECONCILE = 2;\n  const nodeMap = new Map();\n  const activeEditorState = editor._pendingEditorState;\n  for (const [key, node] of editorState._nodeMap) {\n    nodeMap.set(key, $cloneWithProperties(node));\n  }\n  if (activeEditorState) {\n    activeEditorState._nodeMap = nodeMap;\n  }\n  editor._dirtyType = FULL_RECONCILE;\n  const selection = editorState._selection;\n  $setSelection(selection === null ? null : selection.clone());\n}\n\n/**\n * If the selected insertion area is the root/shadow root node (see {@link lexical!$isRootOrShadowRoot}),\n * the node will be appended there, otherwise, it will be inserted before the insertion area.\n * If there is no selection where the node is to be inserted, it will be appended after any current nodes\n * within the tree, as a child of the root node. A paragraph will then be added after the inserted node and selected.\n * @param node - The node to be inserted\n * @returns The node after its insertion\n */\nfunction $insertNodeToNearestRoot(node) {\n  const selection = $getSelection() || $getPreviousSelection();\n  let initialCaret;\n  if ($isRangeSelection(selection)) {\n    initialCaret = $caretFromPoint(selection.focus, 'next');\n  } else {\n    if (selection != null) {\n      const nodes = selection.getNodes();\n      const lastNode = nodes[nodes.length - 1];\n      if (lastNode) {\n        initialCaret = $getSiblingCaret(lastNode, 'next');\n      }\n    }\n    initialCaret = initialCaret || $getChildCaret($getRoot(), 'previous').getFlipped().insert($createParagraphNode());\n  }\n  const insertCaret = $insertNodeToNearestRootAtCaret(node, initialCaret);\n  const adjacent = $getAdjacentChildCaret(insertCaret);\n  const selectionCaret = $isChildCaret(adjacent) ? $normalizeCaret(adjacent) : insertCaret;\n  $setSelectionFromCaretRange($getCollapsedCaretRange(selectionCaret));\n  return node.getLatest();\n}\n\n/**\n * If the insertion caret is the root/shadow root node (see {@link lexical!$isRootOrShadowRoot}),\n * the node will be inserted there, otherwise the parent nodes will be split according to the\n * given options.\n * @param node - The node to be inserted\n * @param caret - The location to insert or split from\n * @returns The node after its insertion\n */\nfunction $insertNodeToNearestRootAtCaret(node, caret, options) {\n  let insertCaret = $getCaretInDirection(caret, 'next');\n  for (let nextCaret = insertCaret; nextCaret; nextCaret = $splitAtPointCaretNext(nextCaret, options)) {\n    insertCaret = nextCaret;\n  }\n  if (!!$isTextPointCaret(insertCaret)) {\n    formatDevErrorMessage(`$insertNodeToNearestRootAtCaret: An unattached TextNode can not be split`);\n  }\n  insertCaret.insert(node.isInline() ? $createParagraphNode().append(node) : node);\n  return $getCaretInDirection($getSiblingCaret(node.getLatest(), 'next'), caret.direction);\n}\n\n/**\n * Wraps the node into another node created from a createElementNode function, eg. $createParagraphNode\n * @param node - Node to be wrapped.\n * @param createElementNode - Creates a new lexical element to wrap the to-be-wrapped node and returns it.\n * @returns A new lexical element with the previous node appended within (as a child, including its children).\n */\nfunction $wrapNodeInElement(node, createElementNode) {\n  const elementNode = createElementNode();\n  node.replace(elementNode);\n  elementNode.append(node);\n  return elementNode;\n}\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n/**\n * @param object = The instance of the type\n * @param objectClass = The class of the type\n * @returns Whether the object is has the same Klass of the objectClass, ignoring the difference across window (e.g. different iframes)\n */\nfunction objectKlassEquals(object, objectClass) {\n  return object !== null ? Object.getPrototypeOf(object).constructor.name === objectClass.name : false;\n}\n\n/**\n * Filter the nodes\n * @param nodes Array of nodes that needs to be filtered\n * @param filterFn A filter function that returns node if the current node satisfies the condition otherwise null\n * @returns Array of filtered nodes\n */\n\nfunction $filter(nodes, filterFn) {\n  const result = [];\n  for (let i = 0; i < nodes.length; i++) {\n    const node = filterFn(nodes[i]);\n    if (node !== null) {\n      result.push(node);\n    }\n  }\n  return result;\n}\n/**\n * Appends the node before the first child of the parent node\n * @param parent A parent node\n * @param node Node that needs to be appended\n */\nfunction $insertFirst(parent, node) {\n  $getChildCaret(parent, 'next').insert(node);\n}\nlet NEEDS_MANUAL_ZOOM = IS_FIREFOX || !CAN_USE_DOM ? false : undefined;\nfunction needsManualZoom() {\n  if (NEEDS_MANUAL_ZOOM === undefined) {\n    // If the browser implements standardized CSS zoom, then the client rect\n    // will be wider after zoom is applied\n    // https://chromestatus.com/feature/5198254868529152\n    // https://github.com/facebook/lexical/issues/6863\n    const div = document.createElement('div');\n    div.style.cssText = 'position: absolute; opacity: 0; width: 100px; left: -1000px;';\n    document.body.appendChild(div);\n    const noZoom = div.getBoundingClientRect();\n    div.style.setProperty('zoom', '2');\n    NEEDS_MANUAL_ZOOM = div.getBoundingClientRect().width === noZoom.width;\n    document.body.removeChild(div);\n  }\n  return NEEDS_MANUAL_ZOOM;\n}\n\n/**\n * Calculates the zoom level of an element as a result of using\n * css zoom property. For browsers that implement standardized CSS\n * zoom (Firefox, Chrome >= 128), this will always return 1.\n * @param element\n */\nfunction calculateZoomLevel(element) {\n  let zoom = 1;\n  if (needsManualZoom()) {\n    while (element) {\n      zoom *= Number(window.getComputedStyle(element).getPropertyValue('zoom'));\n      element = element.parentElement;\n    }\n  }\n  return zoom;\n}\n\n/**\n * Checks if the editor is a nested editor created by LexicalNestedComposer\n */\nfunction $isEditorIsNestedEditor(editor) {\n  return editor._parentEditor !== null;\n}\n\n/**\n * A depth first last-to-first traversal of root that stops at each node that matches\n * $predicate and ensures that its parent is root. This is typically used to discard\n * invalid or unsupported wrapping nodes. For example, a TableNode must only have\n * TableRowNode as children, but an importer might add invalid nodes based on\n * caption, tbody, thead, etc. and this will unwrap and discard those.\n *\n * @param root The root to start the traversal\n * @param $predicate Should return true for nodes that are permitted to be children of root\n * @returns true if this unwrapped or removed any nodes\n */\nfunction $unwrapAndFilterDescendants(root, $predicate) {\n  return $unwrapAndFilterDescendantsImpl(root, $predicate, null);\n}\nfunction $unwrapAndFilterDescendantsImpl(root, $predicate, $onSuccess) {\n  let didMutate = false;\n  for (const node of $lastToFirstIterator(root)) {\n    if ($predicate(node)) {\n      if ($onSuccess !== null) {\n        $onSuccess(node);\n      }\n      continue;\n    }\n    didMutate = true;\n    if ($isElementNode(node)) {\n      $unwrapAndFilterDescendantsImpl(node, $predicate, $onSuccess || (child => node.insertAfter(child)));\n    }\n    node.remove();\n  }\n  return didMutate;\n}\n\n/**\n * A depth first traversal of the children array that stops at and collects\n * each node that `$predicate` matches. This is typically used to discard\n * invalid or unsupported wrapping nodes on a children array in the `after`\n * of an {@link lexical!DOMConversionOutput}. For example, a TableNode must only have\n * TableRowNode as children, but an importer might add invalid nodes based on\n * caption, tbody, thead, etc. and this will unwrap and discard those.\n *\n * This function is read-only and performs no mutation operations, which makes\n * it suitable for import and export purposes but likely not for any in-place\n * mutation. You should use {@link $unwrapAndFilterDescendants} for in-place\n * mutations such as node transforms.\n *\n * @param children The children to traverse\n * @param $predicate Should return true for nodes that are permitted to be children of root\n * @returns The children or their descendants that match $predicate\n */\n\nfunction $descendantsMatching(children, $predicate) {\n  const result = [];\n  const stack = Array.from(children).reverse();\n  for (let child = stack.pop(); child !== undefined; child = stack.pop()) {\n    if ($predicate(child)) {\n      result.push(child);\n    } else if ($isElementNode(child)) {\n      for (const grandchild of $lastToFirstIterator(child)) {\n        stack.push(grandchild);\n      }\n    }\n  }\n  return result;\n}\n\n/**\n * Return an iterator that yields each child of node from first to last, taking\n * care to preserve the next sibling before yielding the value in case the caller\n * removes the yielded node.\n *\n * @param node The node whose children to iterate\n * @returns An iterator of the node's children\n */\nfunction $firstToLastIterator(node) {\n  return $childIterator($getChildCaret(node, 'next'));\n}\n\n/**\n * Return an iterator that yields each child of node from last to first, taking\n * care to preserve the previous sibling before yielding the value in case the caller\n * removes the yielded node.\n *\n * @param node The node whose children to iterate\n * @returns An iterator of the node's children\n */\nfunction $lastToFirstIterator(node) {\n  return $childIterator($getChildCaret(node, 'previous'));\n}\nfunction $childIterator(startCaret) {\n  const seen = new Set();\n  return makeStepwiseIterator({\n    hasNext: $isSiblingCaret,\n    initial: startCaret.getAdjacentCaret(),\n    map: caret => {\n      const origin = caret.origin.getLatest();\n      if (seen !== null) {\n        const key = origin.getKey();\n        if (!!seen.has(key)) {\n          formatDevErrorMessage(`$childIterator: Cycle detected, node with key ${String(key)} has already been traversed`);\n        }\n        seen.add(key);\n      }\n      return origin;\n    },\n    step: caret => caret.getAdjacentCaret()\n  });\n}\n\n/**\n * Replace this node with its children\n *\n * @param node The ElementNode to unwrap and remove\n */\nfunction $unwrapNode(node) {\n  $rewindSiblingCaret($getSiblingCaret(node, 'next')).splice(1, node.getChildren());\n}\n\n/**\n * Returns the Node sibling when this exists, otherwise the closest parent sibling. For example\n * R -> P -> T1, T2\n *   -> P2\n * returns T2 for node T1, P2 for node T2, and null for node P2.\n * @param node LexicalNode.\n * @returns An array (tuple) containing the found Lexical node and the depth difference, or null, if this node doesn't exist.\n */\nfunction $getAdjacentSiblingOrParentSiblingCaret(startCaret, rootMode = 'root') {\n  let depthDiff = 0;\n  let caret = startCaret;\n  let nextCaret = $getAdjacentChildCaret(caret);\n  while (nextCaret === null) {\n    depthDiff--;\n    nextCaret = caret.getParentCaret(rootMode);\n    if (!nextCaret) {\n      return null;\n    }\n    caret = nextCaret;\n    nextCaret = $getAdjacentChildCaret(caret);\n  }\n  return nextCaret && [nextCaret, depthDiff];\n}\n\n/**\n * A wrapper that creates bound functions and methods for the\n * StateConfig to save some boilerplate when defining methods\n * or exporting only the accessors from your modules rather\n * than exposing the StateConfig directly.\n */\n\n/**\n * EXPERIMENTAL\n *\n * A convenience interface for working with {@link $getState} and\n * {@link $setState}.\n *\n * @param stateConfig The stateConfig to wrap with convenience functionality\n * @returns a StateWrapper\n */\nfunction makeStateWrapper(stateConfig) {\n  const $get = node => $getState(node, stateConfig);\n  const $set = (node, valueOrUpdater) => $setState(node, stateConfig, valueOrUpdater);\n  return {\n    $get,\n    $set,\n    accessors: [$get, $set],\n    makeGetterMethod: () => function $getter() {\n      return $get(this);\n    },\n    makeSetterMethod: () => function $setter(valueOrUpdater) {\n      return $set(this, valueOrUpdater);\n    },\n    stateConfig\n  };\n}\nexport { $descendantsMatching, $dfs, $dfsIterator, $filter, $findMatchingParent, $firstToLastIterator, $getAdjacentCaret, $getAdjacentSiblingOrParentSiblingCaret, $getDepth, $getNearestBlockElementAncestorOrThrow, $getNearestNodeOfType, $getNextRightPreorderNode, $getNextSiblingOrParentSibling, $insertFirst, $insertNodeToNearestRoot, $insertNodeToNearestRootAtCaret, $isEditorIsNestedEditor, $lastToFirstIterator, $restoreEditorState, $reverseDfs, $reverseDfsIterator, $unwrapAndFilterDescendants, $unwrapNode, $wrapNodeInElement, CAN_USE_BEFORE_INPUT, CAN_USE_DOM, IS_ANDROID, IS_ANDROID_CHROME, IS_APPLE, IS_APPLE_WEBKIT, IS_CHROME, IS_FIREFOX, IS_IOS, IS_SAFARI, addClassNamesToElement, calculateZoomLevel, isMimeType, makeStateWrapper, markSelection, mediaFileReader, mergeRegister, objectKlassEquals, mlcPositionNodeOnRange as positionNodeOnRange, registerNestedElementResolver, removeClassNamesFromElement, selectionAlwaysOnDisplay };","map":{"version":3,"names":["isHTMLElement","$getSelection","$isRangeSelection","$isElementNode","getDOMTextNode","$getRoot","$getChildCaret","$getSiblingCaret","$getAdjacentChildCaret","$getChildCaretOrSelf","makeStepwiseIterator","$isChildCaret","$cloneWithProperties","$setSelection","$getPreviousSelection","$caretFromPoint","$createParagraphNode","$normalizeCaret","$setSelectionFromCaretRange","$getCollapsedCaretRange","$getCaretInDirection","$splitAtPointCaretNext","$isTextPointCaret","$isSiblingCaret","$rewindSiblingCaret","$getState","$setState","$splitNode","isBlockDomNode","isHTMLAnchorElement","isInlineDomNode","createRectsFromDOMRange","formatDevErrorMessage","message","Error","CAN_USE_DOM$1","window","document","createElement","documentMode","IS_APPLE$1","test","navigator","platform","IS_FIREFOX$1","userAgent","CAN_USE_BEFORE_INPUT$1","InputEvent","IS_SAFARI$1","IS_IOS$1","MSStream","IS_ANDROID$1","IS_CHROME$1","IS_ANDROID_CHROME$1","IS_APPLE_WEBKIT$1","normalizeClassNames","classNames","rval","className","s","matchAll","push","mergeRegister","func","i","length","px","value","mutationObserverConfig","attributes","characterData","childList","subtree","prependDOMNode","parent","node","insertBefore","firstChild","mlcPositionNodeOnRange","editor","range","onReposition","rootDOMNode","parentDOMNode","observer","lastNodes","wrapperNode","style","position","left","parentLeft","top","parentTop","getBoundingClientRect","rects","isConnected","hasRepositioned","rect","rectNode","rectNodeStyle","width","height","parentNode","append","pop","stop","disconnect","remove","restart","currentRootDOMNode","getRootElement","currentParentDOMNode","parentElement","MutationObserver","mutations","nextRootDOMNode","nextParentDOMNode","mutation","contains","target","observe","removeRootListener","registerRootListener","rangeTargetFromPoint","point","dom","type","textDOM","offset","slot","getDOMSlot","element","getFirstChildOffset","rangeFromPoints","anchor","anchorNode","anchorDOM","focus","focusNode","focusDOM","editorDocument","_window","createRange","isBefore","setStart","setEnd","markSelection","previousAnchorNode","previousAnchorNodeDOM","previousAnchorOffset","previousFocusNode","previousFocusNodeDOM","previousFocusOffset","removeRangeListener","compute","editorState","read","selection","currentAnchorNode","getNode","currentAnchorNodeKey","getKey","currentAnchorOffset","currentFocusNode","currentFocusNodeKey","currentFocusOffset","currentAnchorNodeDOM","getElementByKey","currentFocusNodeDOM","differentAnchorDOM","differentFocusDOM","domNodes","undefined","domNode","domNodeStyle","background","color","marginTop","paddingTop","paddingBottom","getEditorState","registerUpdateListener","selectionAlwaysOnDisplay","removeSelectionMark","onSelectionChange","domSelection","getSelection","domAnchorNode","editorRootElement","isSelectionInsideEditor","addEventListener","removeEventListener","CAN_USE_BEFORE_INPUT","CAN_USE_DOM","IS_ANDROID","IS_ANDROID_CHROME","IS_APPLE","IS_APPLE_WEBKIT","IS_CHROME","IS_FIREFOX","IS_IOS","IS_SAFARI","addClassNamesToElement","classesToAdd","classList","add","removeClassNamesFromElement","classesToRemove","isMimeType","file","acceptableMimeTypes","acceptableType","startsWith","mediaFileReader","files","filesIterator","Symbol","iterator","Promise","resolve","reject","processed","handleNextFile","done","next","fileReader","FileReader","result","readAsDataURL","$dfs","startNode","endNode","Array","from","$dfsIterator","$getAdjacentCaret","caret","getAdjacentCaret","$reverseDfs","$reverseDfsIterator","$dfsCaretIterator","$getEndCaret","direction","$getAdjacentSiblingOrParentSiblingCaret","root","start","startCaret","startDepth","$getDepth","endCaret","depth","hasNext","state","initial","map","origin","step","isSameNodeCaret","$getNextSiblingOrParentSibling","innerNode","getParent","$getNextRightPreorderNode","startingNode","$getNearestNodeOfType","klass","$getNearestBlockElementAncestorOrThrow","blockNode","$findMatchingParent","isInline","__key","findFn","curr","registerNestedElementResolver","targetNode","cloneNode","handleOverlap","$isTargetNode","$findMatch","children","getChildren","child","childNode","$elementNodeTransform","match","is","nextSiblings","getNextSiblings","nextSiblingsLength","insertAfter","newParent","canBeEmpty","getChildrenSize","registerNodeTransform","$restoreEditorState","FULL_RECONCILE","nodeMap","Map","activeEditorState","_pendingEditorState","key","_nodeMap","set","_dirtyType","_selection","clone","$insertNodeToNearestRoot","initialCaret","nodes","getNodes","lastNode","getFlipped","insert","insertCaret","$insertNodeToNearestRootAtCaret","adjacent","selectionCaret","getLatest","options","nextCaret","$wrapNodeInElement","createElementNode","elementNode","replace","objectKlassEquals","object","objectClass","Object","getPrototypeOf","constructor","name","$filter","filterFn","$insertFirst","NEEDS_MANUAL_ZOOM","needsManualZoom","div","cssText","body","appendChild","noZoom","setProperty","removeChild","calculateZoomLevel","zoom","Number","getComputedStyle","getPropertyValue","$isEditorIsNestedEditor","_parentEditor","$unwrapAndFilterDescendants","$predicate","$unwrapAndFilterDescendantsImpl","$onSuccess","didMutate","$lastToFirstIterator","$descendantsMatching","stack","reverse","grandchild","$firstToLastIterator","$childIterator","seen","Set","has","String","$unwrapNode","splice","rootMode","depthDiff","getParentCaret","makeStateWrapper","stateConfig","$get","$set","valueOrUpdater","accessors","makeGetterMethod","$getter","makeSetterMethod","$setter","positionNodeOnRange"],"sources":["C:/Code/beedoo/node_modules/@lexical/utils/LexicalUtils.dev.mjs"],"sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport { isHTMLElement, $getSelection, $isRangeSelection, $isElementNode, getDOMTextNode, $getRoot, $getChildCaret, $getSiblingCaret, $getAdjacentChildCaret, $getChildCaretOrSelf, makeStepwiseIterator, $isChildCaret, $cloneWithProperties, $setSelection, $getPreviousSelection, $caretFromPoint, $createParagraphNode, $normalizeCaret, $setSelectionFromCaretRange, $getCollapsedCaretRange, $getCaretInDirection, $splitAtPointCaretNext, $isTextPointCaret, $isSiblingCaret, $rewindSiblingCaret, $getState, $setState } from 'lexical';\nexport { $splitNode, isBlockDomNode, isHTMLAnchorElement, isHTMLElement, isInlineDomNode } from 'lexical';\nimport { createRectsFromDOMRange } from '@lexical/selection';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n// Do not require this module directly! Use normal `invariant` calls.\n\nfunction formatDevErrorMessage(message) {\n  throw new Error(message);\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst CAN_USE_DOM$1 = typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst documentMode = CAN_USE_DOM$1 && 'documentMode' in document ? document.documentMode : null;\nconst IS_APPLE$1 = CAN_USE_DOM$1 && /Mac|iPod|iPhone|iPad/.test(navigator.platform);\nconst IS_FIREFOX$1 = CAN_USE_DOM$1 && /^(?!.*Seamonkey)(?=.*Firefox).*/i.test(navigator.userAgent);\nconst CAN_USE_BEFORE_INPUT$1 = CAN_USE_DOM$1 && 'InputEvent' in window && !documentMode ? 'getTargetRanges' in new window.InputEvent('input') : false;\nconst IS_SAFARI$1 = CAN_USE_DOM$1 && /Version\\/[\\d.]+.*Safari/.test(navigator.userAgent);\nconst IS_IOS$1 = CAN_USE_DOM$1 && /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;\nconst IS_ANDROID$1 = CAN_USE_DOM$1 && /Android/.test(navigator.userAgent);\n\n// Keep these in case we need to use them in the future.\n// export const IS_WINDOWS: boolean = CAN_USE_DOM && /Win/.test(navigator.platform);\nconst IS_CHROME$1 = CAN_USE_DOM$1 && /^(?=.*Chrome).*/i.test(navigator.userAgent);\n// export const canUseTextInputEvent: boolean = CAN_USE_DOM && 'TextEvent' in window && !documentMode;\n\nconst IS_ANDROID_CHROME$1 = CAN_USE_DOM$1 && IS_ANDROID$1 && IS_CHROME$1;\nconst IS_APPLE_WEBKIT$1 = CAN_USE_DOM$1 && /AppleWebKit\\/[\\d.]+/.test(navigator.userAgent) && !IS_CHROME$1;\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction normalizeClassNames(...classNames) {\n  const rval = [];\n  for (const className of classNames) {\n    if (className && typeof className === 'string') {\n      for (const [s] of className.matchAll(/\\S+/g)) {\n        rval.push(s);\n      }\n    }\n  }\n  return rval;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/**\n * Returns a function that will execute all functions passed when called. It is generally used\n * to register multiple lexical listeners and then tear them down with a single function call, such\n * as React's useEffect hook.\n * @example\n * ```ts\n * useEffect(() => {\n *   return mergeRegister(\n *     editor.registerCommand(...registerCommand1 logic),\n *     editor.registerCommand(...registerCommand2 logic),\n *     editor.registerCommand(...registerCommand3 logic)\n *   )\n * }, [editor])\n * ```\n * In this case, useEffect is returning the function returned by mergeRegister as a cleanup\n * function to be executed after either the useEffect runs again (due to one of its dependencies\n * updating) or the component it resides in unmounts.\n * Note the functions don't necessarily need to be in an array as all arguments\n * are considered to be the func argument and spread from there.\n * The order of cleanup is the reverse of the argument order. Generally it is\n * expected that the first \"acquire\" will be \"released\" last (LIFO order),\n * because a later step may have some dependency on an earlier one.\n * @param func - An array of cleanup functions meant to be executed by the returned function.\n * @returns the function which executes all the passed cleanup functions.\n */\nfunction mergeRegister(...func) {\n  return () => {\n    for (let i = func.length - 1; i >= 0; i--) {\n      func[i]();\n    }\n    // Clean up the references and make future calls a no-op\n    func.length = 0;\n  };\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction px(value) {\n  return `${value}px`;\n}\n\nconst mutationObserverConfig = {\n  attributes: true,\n  characterData: true,\n  childList: true,\n  subtree: true\n};\nfunction prependDOMNode(parent, node) {\n  parent.insertBefore(node, parent.firstChild);\n}\n\n/**\n * Place one or multiple newly created Nodes at the passed Range's position.\n * Multiple nodes will only be created when the Range spans multiple lines (aka\n * client rects).\n *\n * This function can come particularly useful to highlight particular parts of\n * the text without interfering with the EditorState, that will often replicate\n * the state across collab and clipboard.\n *\n * This function accounts for DOM updates which can modify the passed Range.\n * Hence, the function return to remove the listener.\n */\nfunction mlcPositionNodeOnRange(editor, range, onReposition) {\n  let rootDOMNode = null;\n  let parentDOMNode = null;\n  let observer = null;\n  let lastNodes = [];\n  const wrapperNode = document.createElement('div');\n  wrapperNode.style.position = 'relative';\n  function position() {\n    if (!(rootDOMNode !== null)) {\n      formatDevErrorMessage(`Unexpected null rootDOMNode`);\n    }\n    if (!(parentDOMNode !== null)) {\n      formatDevErrorMessage(`Unexpected null parentDOMNode`);\n    }\n    const {\n      left: parentLeft,\n      top: parentTop\n    } = parentDOMNode.getBoundingClientRect();\n    const rects = createRectsFromDOMRange(editor, range);\n    if (!wrapperNode.isConnected) {\n      prependDOMNode(parentDOMNode, wrapperNode);\n    }\n    let hasRepositioned = false;\n    for (let i = 0; i < rects.length; i++) {\n      const rect = rects[i];\n      // Try to reuse the previously created Node when possible, no need to\n      // remove/create on the most common case reposition case\n      const rectNode = lastNodes[i] || document.createElement('div');\n      const rectNodeStyle = rectNode.style;\n      if (rectNodeStyle.position !== 'absolute') {\n        rectNodeStyle.position = 'absolute';\n        hasRepositioned = true;\n      }\n      const left = px(rect.left - parentLeft);\n      if (rectNodeStyle.left !== left) {\n        rectNodeStyle.left = left;\n        hasRepositioned = true;\n      }\n      const top = px(rect.top - parentTop);\n      if (rectNodeStyle.top !== top) {\n        rectNode.style.top = top;\n        hasRepositioned = true;\n      }\n      const width = px(rect.width);\n      if (rectNodeStyle.width !== width) {\n        rectNode.style.width = width;\n        hasRepositioned = true;\n      }\n      const height = px(rect.height);\n      if (rectNodeStyle.height !== height) {\n        rectNode.style.height = height;\n        hasRepositioned = true;\n      }\n      if (rectNode.parentNode !== wrapperNode) {\n        wrapperNode.append(rectNode);\n        hasRepositioned = true;\n      }\n      lastNodes[i] = rectNode;\n    }\n    while (lastNodes.length > rects.length) {\n      lastNodes.pop();\n    }\n    if (hasRepositioned) {\n      onReposition(lastNodes);\n    }\n  }\n  function stop() {\n    parentDOMNode = null;\n    rootDOMNode = null;\n    if (observer !== null) {\n      observer.disconnect();\n    }\n    observer = null;\n    wrapperNode.remove();\n    for (const node of lastNodes) {\n      node.remove();\n    }\n    lastNodes = [];\n  }\n  function restart() {\n    const currentRootDOMNode = editor.getRootElement();\n    if (currentRootDOMNode === null) {\n      return stop();\n    }\n    const currentParentDOMNode = currentRootDOMNode.parentElement;\n    if (!isHTMLElement(currentParentDOMNode)) {\n      return stop();\n    }\n    stop();\n    rootDOMNode = currentRootDOMNode;\n    parentDOMNode = currentParentDOMNode;\n    observer = new MutationObserver(mutations => {\n      const nextRootDOMNode = editor.getRootElement();\n      const nextParentDOMNode = nextRootDOMNode && nextRootDOMNode.parentElement;\n      if (nextRootDOMNode !== rootDOMNode || nextParentDOMNode !== parentDOMNode) {\n        return restart();\n      }\n      for (const mutation of mutations) {\n        if (!wrapperNode.contains(mutation.target)) {\n          // TODO throttle\n          return position();\n        }\n      }\n    });\n    observer.observe(currentParentDOMNode, mutationObserverConfig);\n    position();\n  }\n  const removeRootListener = editor.registerRootListener(restart);\n  return () => {\n    removeRootListener();\n    stop();\n  };\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction rangeTargetFromPoint(point, node, dom) {\n  if (point.type === 'text' || !$isElementNode(node)) {\n    const textDOM = getDOMTextNode(dom) || dom;\n    return [textDOM, point.offset];\n  } else {\n    const slot = node.getDOMSlot(dom);\n    return [slot.element, slot.getFirstChildOffset() + point.offset];\n  }\n}\nfunction rangeFromPoints(editor, anchor, anchorNode, anchorDOM, focus, focusNode, focusDOM) {\n  const editorDocument = editor._window ? editor._window.document : document;\n  const range = editorDocument.createRange();\n  if (focusNode.isBefore(anchorNode)) {\n    range.setStart(...rangeTargetFromPoint(focus, focusNode, focusDOM));\n    range.setEnd(...rangeTargetFromPoint(anchor, anchorNode, anchorDOM));\n  } else {\n    range.setStart(...rangeTargetFromPoint(anchor, anchorNode, anchorDOM));\n    range.setEnd(...rangeTargetFromPoint(focus, focusNode, focusDOM));\n  }\n  return range;\n}\n/**\n * Place one or multiple newly created Nodes at the current selection. Multiple\n * nodes will only be created when the selection spans multiple lines (aka\n * client rects).\n *\n * This function can come useful when you want to show the selection but the\n * editor has been focused away.\n */\nfunction markSelection(editor, onReposition) {\n  let previousAnchorNode = null;\n  let previousAnchorNodeDOM = null;\n  let previousAnchorOffset = null;\n  let previousFocusNode = null;\n  let previousFocusNodeDOM = null;\n  let previousFocusOffset = null;\n  let removeRangeListener = () => {};\n  function compute(editorState) {\n    editorState.read(() => {\n      const selection = $getSelection();\n      if (!$isRangeSelection(selection)) {\n        // TODO\n        previousAnchorNode = null;\n        previousAnchorOffset = null;\n        previousFocusNode = null;\n        previousFocusOffset = null;\n        removeRangeListener();\n        removeRangeListener = () => {};\n        return;\n      }\n      const {\n        anchor,\n        focus\n      } = selection;\n      const currentAnchorNode = anchor.getNode();\n      const currentAnchorNodeKey = currentAnchorNode.getKey();\n      const currentAnchorOffset = anchor.offset;\n      const currentFocusNode = focus.getNode();\n      const currentFocusNodeKey = currentFocusNode.getKey();\n      const currentFocusOffset = focus.offset;\n      const currentAnchorNodeDOM = editor.getElementByKey(currentAnchorNodeKey);\n      const currentFocusNodeDOM = editor.getElementByKey(currentFocusNodeKey);\n      const differentAnchorDOM = previousAnchorNode === null || currentAnchorNodeDOM !== previousAnchorNodeDOM || currentAnchorOffset !== previousAnchorOffset || currentAnchorNodeKey !== previousAnchorNode.getKey();\n      const differentFocusDOM = previousFocusNode === null || currentFocusNodeDOM !== previousFocusNodeDOM || currentFocusOffset !== previousFocusOffset || currentFocusNodeKey !== previousFocusNode.getKey();\n      if ((differentAnchorDOM || differentFocusDOM) && currentAnchorNodeDOM !== null && currentFocusNodeDOM !== null) {\n        const range = rangeFromPoints(editor, anchor, currentAnchorNode, currentAnchorNodeDOM, focus, currentFocusNode, currentFocusNodeDOM);\n        removeRangeListener();\n        removeRangeListener = mlcPositionNodeOnRange(editor, range, domNodes => {\n          if (onReposition === undefined) {\n            for (const domNode of domNodes) {\n              const domNodeStyle = domNode.style;\n              if (domNodeStyle.background !== 'Highlight') {\n                domNodeStyle.background = 'Highlight';\n              }\n              if (domNodeStyle.color !== 'HighlightText') {\n                domNodeStyle.color = 'HighlightText';\n              }\n              if (domNodeStyle.marginTop !== px(-1.5)) {\n                domNodeStyle.marginTop = px(-1.5);\n              }\n              if (domNodeStyle.paddingTop !== px(4)) {\n                domNodeStyle.paddingTop = px(4);\n              }\n              if (domNodeStyle.paddingBottom !== px(0)) {\n                domNodeStyle.paddingBottom = px(0);\n              }\n            }\n          } else {\n            onReposition(domNodes);\n          }\n        });\n      }\n      previousAnchorNode = currentAnchorNode;\n      previousAnchorNodeDOM = currentAnchorNodeDOM;\n      previousAnchorOffset = currentAnchorOffset;\n      previousFocusNode = currentFocusNode;\n      previousFocusNodeDOM = currentFocusNodeDOM;\n      previousFocusOffset = currentFocusOffset;\n    });\n  }\n  compute(editor.getEditorState());\n  return mergeRegister(editor.registerUpdateListener(({\n    editorState\n  }) => compute(editorState)), () => {\n    removeRangeListener();\n  });\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction selectionAlwaysOnDisplay(editor) {\n  let removeSelectionMark = null;\n  const onSelectionChange = () => {\n    const domSelection = getSelection();\n    const domAnchorNode = domSelection && domSelection.anchorNode;\n    const editorRootElement = editor.getRootElement();\n    const isSelectionInsideEditor = domAnchorNode !== null && editorRootElement !== null && editorRootElement.contains(domAnchorNode);\n    if (isSelectionInsideEditor) {\n      if (removeSelectionMark !== null) {\n        removeSelectionMark();\n        removeSelectionMark = null;\n      }\n    } else {\n      if (removeSelectionMark === null) {\n        removeSelectionMark = markSelection(editor);\n      }\n    }\n  };\n  document.addEventListener('selectionchange', onSelectionChange);\n  return () => {\n    if (removeSelectionMark !== null) {\n      removeSelectionMark();\n    }\n    document.removeEventListener('selectionchange', onSelectionChange);\n  };\n}\n\n// Hotfix to export these with inlined types #5918\nconst CAN_USE_BEFORE_INPUT = CAN_USE_BEFORE_INPUT$1;\nconst CAN_USE_DOM = CAN_USE_DOM$1;\nconst IS_ANDROID = IS_ANDROID$1;\nconst IS_ANDROID_CHROME = IS_ANDROID_CHROME$1;\nconst IS_APPLE = IS_APPLE$1;\nconst IS_APPLE_WEBKIT = IS_APPLE_WEBKIT$1;\nconst IS_CHROME = IS_CHROME$1;\nconst IS_FIREFOX = IS_FIREFOX$1;\nconst IS_IOS = IS_IOS$1;\nconst IS_SAFARI = IS_SAFARI$1;\n\n/**\n * Takes an HTML element and adds the classNames passed within an array,\n * ignoring any non-string types. A space can be used to add multiple classes\n * eg. addClassNamesToElement(element, ['element-inner active', true, null])\n * will add both 'element-inner' and 'active' as classes to that element.\n * @param element - The element in which the classes are added\n * @param classNames - An array defining the class names to add to the element\n */\nfunction addClassNamesToElement(element, ...classNames) {\n  const classesToAdd = normalizeClassNames(...classNames);\n  if (classesToAdd.length > 0) {\n    element.classList.add(...classesToAdd);\n  }\n}\n\n/**\n * Takes an HTML element and removes the classNames passed within an array,\n * ignoring any non-string types. A space can be used to remove multiple classes\n * eg. removeClassNamesFromElement(element, ['active small', true, null])\n * will remove both the 'active' and 'small' classes from that element.\n * @param element - The element in which the classes are removed\n * @param classNames - An array defining the class names to remove from the element\n */\nfunction removeClassNamesFromElement(element, ...classNames) {\n  const classesToRemove = normalizeClassNames(...classNames);\n  if (classesToRemove.length > 0) {\n    element.classList.remove(...classesToRemove);\n  }\n}\n\n/**\n * Returns true if the file type matches the types passed within the acceptableMimeTypes array, false otherwise.\n * The types passed must be strings and are CASE-SENSITIVE.\n * eg. if file is of type 'text' and acceptableMimeTypes = ['TEXT', 'IMAGE'] the function will return false.\n * @param file - The file you want to type check.\n * @param acceptableMimeTypes - An array of strings of types which the file is checked against.\n * @returns true if the file is an acceptable mime type, false otherwise.\n */\nfunction isMimeType(file, acceptableMimeTypes) {\n  for (const acceptableType of acceptableMimeTypes) {\n    if (file.type.startsWith(acceptableType)) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * Lexical File Reader with:\n *  1. MIME type support\n *  2. batched results (HistoryPlugin compatibility)\n *  3. Order aware (respects the order when multiple Files are passed)\n *\n * const filesResult = await mediaFileReader(files, ['image/']);\n * filesResult.forEach(file => editor.dispatchCommand('INSERT_IMAGE', \\\\{\n *   src: file.result,\n * \\\\}));\n */\nfunction mediaFileReader(files, acceptableMimeTypes) {\n  const filesIterator = files[Symbol.iterator]();\n  return new Promise((resolve, reject) => {\n    const processed = [];\n    const handleNextFile = () => {\n      const {\n        done,\n        value: file\n      } = filesIterator.next();\n      if (done) {\n        return resolve(processed);\n      }\n      const fileReader = new FileReader();\n      fileReader.addEventListener('error', reject);\n      fileReader.addEventListener('load', () => {\n        const result = fileReader.result;\n        if (typeof result === 'string') {\n          processed.push({\n            file,\n            result\n          });\n        }\n        handleNextFile();\n      });\n      if (isMimeType(file, acceptableMimeTypes)) {\n        fileReader.readAsDataURL(file);\n      } else {\n        handleNextFile();\n      }\n    };\n    handleNextFile();\n  });\n}\n/**\n * \"Depth-First Search\" starts at the root/top node of a tree and goes as far as it can down a branch end\n * before backtracking and finding a new path. Consider solving a maze by hugging either wall, moving down a\n * branch until you hit a dead-end (leaf) and backtracking to find the nearest branching path and repeat.\n * It will then return all the nodes found in the search in an array of objects.\n * @param startNode - The node to start the search, if omitted, it will start at the root node.\n * @param endNode - The node to end the search, if omitted, it will find all descendants of the startingNode.\n * @returns An array of objects of all the nodes found by the search, including their depth into the tree.\n * \\\\{depth: number, node: LexicalNode\\\\} It will always return at least 1 node (the start node).\n */\nfunction $dfs(startNode, endNode) {\n  return Array.from($dfsIterator(startNode, endNode));\n}\n\n/**\n * Get the adjacent caret in the same direction\n *\n * @param caret A caret or null\n * @returns `caret.getAdjacentCaret()` or `null`\n */\nfunction $getAdjacentCaret(caret) {\n  return caret ? caret.getAdjacentCaret() : null;\n}\n\n/**\n * $dfs iterator (right to left). Tree traversal is done on the fly as new values are requested with O(1) memory.\n * @param startNode - The node to start the search, if omitted, it will start at the root node.\n * @param endNode - The node to end the search, if omitted, it will find all descendants of the startingNode.\n * @returns An iterator, each yielded value is a DFSNode. It will always return at least 1 node (the start node).\n */\nfunction $reverseDfs(startNode, endNode) {\n  return Array.from($reverseDfsIterator(startNode, endNode));\n}\n\n/**\n * $dfs iterator (left to right). Tree traversal is done on the fly as new values are requested with O(1) memory.\n * @param startNode - The node to start the search, if omitted, it will start at the root node.\n * @param endNode - The node to end the search, if omitted, it will find all descendants of the startingNode.\n * @returns An iterator, each yielded value is a DFSNode. It will always return at least 1 node (the start node).\n */\nfunction $dfsIterator(startNode, endNode) {\n  return $dfsCaretIterator('next', startNode, endNode);\n}\nfunction $getEndCaret(startNode, direction) {\n  const rval = $getAdjacentSiblingOrParentSiblingCaret($getSiblingCaret(startNode, direction));\n  return rval && rval[0];\n}\nfunction $dfsCaretIterator(direction, startNode, endNode) {\n  const root = $getRoot();\n  const start = startNode || root;\n  const startCaret = $isElementNode(start) ? $getChildCaret(start, direction) : $getSiblingCaret(start, direction);\n  const startDepth = $getDepth(start);\n  const endCaret = endNode ? $getAdjacentChildCaret($getChildCaretOrSelf($getSiblingCaret(endNode, direction))) : $getEndCaret(start, direction);\n  let depth = startDepth;\n  return makeStepwiseIterator({\n    hasNext: state => state !== null,\n    initial: startCaret,\n    map: state => ({\n      depth,\n      node: state.origin\n    }),\n    step: state => {\n      if (state.isSameNodeCaret(endCaret)) {\n        return null;\n      }\n      if ($isChildCaret(state)) {\n        depth++;\n      }\n      const rval = $getAdjacentSiblingOrParentSiblingCaret(state);\n      if (!rval || rval[0].isSameNodeCaret(endCaret)) {\n        return null;\n      }\n      depth += rval[1];\n      return rval[0];\n    }\n  });\n}\n\n/**\n * Returns the Node sibling when this exists, otherwise the closest parent sibling. For example\n * R -> P -> T1, T2\n *   -> P2\n * returns T2 for node T1, P2 for node T2, and null for node P2.\n * @param node LexicalNode.\n * @returns An array (tuple) containing the found Lexical node and the depth difference, or null, if this node doesn't exist.\n */\nfunction $getNextSiblingOrParentSibling(node) {\n  const rval = $getAdjacentSiblingOrParentSiblingCaret($getSiblingCaret(node, 'next'));\n  return rval && [rval[0].origin, rval[1]];\n}\nfunction $getDepth(node) {\n  let depth = -1;\n  for (let innerNode = node; innerNode !== null; innerNode = innerNode.getParent()) {\n    depth++;\n  }\n  return depth;\n}\n\n/**\n * Performs a right-to-left preorder tree traversal.\n * From the starting node it goes to the rightmost child, than backtracks to parent and finds new rightmost path.\n * It will return the next node in traversal sequence after the startingNode.\n * The traversal is similar to $dfs functions above, but the nodes are visited right-to-left, not left-to-right.\n * @param startingNode - The node to start the search.\n * @returns The next node in pre-order right to left traversal sequence or `null`, if the node does not exist\n */\nfunction $getNextRightPreorderNode(startingNode) {\n  const startCaret = $getChildCaretOrSelf($getSiblingCaret(startingNode, 'previous'));\n  const next = $getAdjacentSiblingOrParentSiblingCaret(startCaret, 'root');\n  return next && next[0].origin;\n}\n\n/**\n * $dfs iterator (right to left). Tree traversal is done on the fly as new values are requested with O(1) memory.\n * @param startNode - The node to start the search, if omitted, it will start at the root node.\n * @param endNode - The node to end the search, if omitted, it will find all descendants of the startingNode.\n * @returns An iterator, each yielded value is a DFSNode. It will always return at least 1 node (the start node).\n */\nfunction $reverseDfsIterator(startNode, endNode) {\n  return $dfsCaretIterator('previous', startNode, endNode);\n}\n\n/**\n * Takes a node and traverses up its ancestors (toward the root node)\n * in order to find a specific type of node.\n * @param node - the node to begin searching.\n * @param klass - an instance of the type of node to look for.\n * @returns the node of type klass that was passed, or null if none exist.\n */\nfunction $getNearestNodeOfType(node, klass) {\n  let parent = node;\n  while (parent != null) {\n    if (parent instanceof klass) {\n      return parent;\n    }\n    parent = parent.getParent();\n  }\n  return null;\n}\n\n/**\n * Returns the element node of the nearest ancestor, otherwise throws an error.\n * @param startNode - The starting node of the search\n * @returns The ancestor node found\n */\nfunction $getNearestBlockElementAncestorOrThrow(startNode) {\n  const blockNode = $findMatchingParent(startNode, node => $isElementNode(node) && !node.isInline());\n  if (!$isElementNode(blockNode)) {\n    {\n      formatDevErrorMessage(`Expected node ${startNode.__key} to have closest block element node.`);\n    }\n  }\n  return blockNode;\n}\n/**\n * Starts with a node and moves up the tree (toward the root node) to find a matching node based on\n * the search parameters of the findFn. (Consider JavaScripts' .find() function where a testing function must be\n * passed as an argument. eg. if( (node) => node.__type === 'div') ) return true; otherwise return false\n * @param startingNode - The node where the search starts.\n * @param findFn - A testing function that returns true if the current node satisfies the testing parameters.\n * @returns A parent node that matches the findFn parameters, or null if one wasn't found.\n */\nconst $findMatchingParent = (startingNode, findFn) => {\n  let curr = startingNode;\n  while (curr !== $getRoot() && curr != null) {\n    if (findFn(curr)) {\n      return curr;\n    }\n    curr = curr.getParent();\n  }\n  return null;\n};\n\n/**\n * Attempts to resolve nested element nodes of the same type into a single node of that type.\n * It is generally used for marks/commenting\n * @param editor - The lexical editor\n * @param targetNode - The target for the nested element to be extracted from.\n * @param cloneNode - See {@link $createMarkNode}\n * @param handleOverlap - Handles any overlap between the node to extract and the targetNode\n * @returns The lexical editor\n */\nfunction registerNestedElementResolver(editor, targetNode, cloneNode, handleOverlap) {\n  const $isTargetNode = node => {\n    return node instanceof targetNode;\n  };\n  const $findMatch = node => {\n    // First validate we don't have any children that are of the target,\n    // as we need to handle them first.\n    const children = node.getChildren();\n    for (let i = 0; i < children.length; i++) {\n      const child = children[i];\n      if ($isTargetNode(child)) {\n        return null;\n      }\n    }\n    let parentNode = node;\n    let childNode = node;\n    while (parentNode !== null) {\n      childNode = parentNode;\n      parentNode = parentNode.getParent();\n      if ($isTargetNode(parentNode)) {\n        return {\n          child: childNode,\n          parent: parentNode\n        };\n      }\n    }\n    return null;\n  };\n  const $elementNodeTransform = node => {\n    const match = $findMatch(node);\n    if (match !== null) {\n      const {\n        child,\n        parent\n      } = match;\n\n      // Simple path, we can move child out and siblings into a new parent.\n\n      if (child.is(node)) {\n        handleOverlap(parent, node);\n        const nextSiblings = child.getNextSiblings();\n        const nextSiblingsLength = nextSiblings.length;\n        parent.insertAfter(child);\n        if (nextSiblingsLength !== 0) {\n          const newParent = cloneNode(parent);\n          child.insertAfter(newParent);\n          for (let i = 0; i < nextSiblingsLength; i++) {\n            newParent.append(nextSiblings[i]);\n          }\n        }\n        if (!parent.canBeEmpty() && parent.getChildrenSize() === 0) {\n          parent.remove();\n        }\n      }\n    }\n  };\n  return editor.registerNodeTransform(targetNode, $elementNodeTransform);\n}\n\n/**\n * Clones the editor and marks it as dirty to be reconciled. If there was a selection,\n * it would be set back to its previous state, or null otherwise.\n * @param editor - The lexical editor\n * @param editorState - The editor's state\n */\nfunction $restoreEditorState(editor, editorState) {\n  const FULL_RECONCILE = 2;\n  const nodeMap = new Map();\n  const activeEditorState = editor._pendingEditorState;\n  for (const [key, node] of editorState._nodeMap) {\n    nodeMap.set(key, $cloneWithProperties(node));\n  }\n  if (activeEditorState) {\n    activeEditorState._nodeMap = nodeMap;\n  }\n  editor._dirtyType = FULL_RECONCILE;\n  const selection = editorState._selection;\n  $setSelection(selection === null ? null : selection.clone());\n}\n\n/**\n * If the selected insertion area is the root/shadow root node (see {@link lexical!$isRootOrShadowRoot}),\n * the node will be appended there, otherwise, it will be inserted before the insertion area.\n * If there is no selection where the node is to be inserted, it will be appended after any current nodes\n * within the tree, as a child of the root node. A paragraph will then be added after the inserted node and selected.\n * @param node - The node to be inserted\n * @returns The node after its insertion\n */\nfunction $insertNodeToNearestRoot(node) {\n  const selection = $getSelection() || $getPreviousSelection();\n  let initialCaret;\n  if ($isRangeSelection(selection)) {\n    initialCaret = $caretFromPoint(selection.focus, 'next');\n  } else {\n    if (selection != null) {\n      const nodes = selection.getNodes();\n      const lastNode = nodes[nodes.length - 1];\n      if (lastNode) {\n        initialCaret = $getSiblingCaret(lastNode, 'next');\n      }\n    }\n    initialCaret = initialCaret || $getChildCaret($getRoot(), 'previous').getFlipped().insert($createParagraphNode());\n  }\n  const insertCaret = $insertNodeToNearestRootAtCaret(node, initialCaret);\n  const adjacent = $getAdjacentChildCaret(insertCaret);\n  const selectionCaret = $isChildCaret(adjacent) ? $normalizeCaret(adjacent) : insertCaret;\n  $setSelectionFromCaretRange($getCollapsedCaretRange(selectionCaret));\n  return node.getLatest();\n}\n\n/**\n * If the insertion caret is the root/shadow root node (see {@link lexical!$isRootOrShadowRoot}),\n * the node will be inserted there, otherwise the parent nodes will be split according to the\n * given options.\n * @param node - The node to be inserted\n * @param caret - The location to insert or split from\n * @returns The node after its insertion\n */\nfunction $insertNodeToNearestRootAtCaret(node, caret, options) {\n  let insertCaret = $getCaretInDirection(caret, 'next');\n  for (let nextCaret = insertCaret; nextCaret; nextCaret = $splitAtPointCaretNext(nextCaret, options)) {\n    insertCaret = nextCaret;\n  }\n  if (!!$isTextPointCaret(insertCaret)) {\n    formatDevErrorMessage(`$insertNodeToNearestRootAtCaret: An unattached TextNode can not be split`);\n  }\n  insertCaret.insert(node.isInline() ? $createParagraphNode().append(node) : node);\n  return $getCaretInDirection($getSiblingCaret(node.getLatest(), 'next'), caret.direction);\n}\n\n/**\n * Wraps the node into another node created from a createElementNode function, eg. $createParagraphNode\n * @param node - Node to be wrapped.\n * @param createElementNode - Creates a new lexical element to wrap the to-be-wrapped node and returns it.\n * @returns A new lexical element with the previous node appended within (as a child, including its children).\n */\nfunction $wrapNodeInElement(node, createElementNode) {\n  const elementNode = createElementNode();\n  node.replace(elementNode);\n  elementNode.append(node);\n  return elementNode;\n}\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n/**\n * @param object = The instance of the type\n * @param objectClass = The class of the type\n * @returns Whether the object is has the same Klass of the objectClass, ignoring the difference across window (e.g. different iframes)\n */\nfunction objectKlassEquals(object, objectClass) {\n  return object !== null ? Object.getPrototypeOf(object).constructor.name === objectClass.name : false;\n}\n\n/**\n * Filter the nodes\n * @param nodes Array of nodes that needs to be filtered\n * @param filterFn A filter function that returns node if the current node satisfies the condition otherwise null\n * @returns Array of filtered nodes\n */\n\nfunction $filter(nodes, filterFn) {\n  const result = [];\n  for (let i = 0; i < nodes.length; i++) {\n    const node = filterFn(nodes[i]);\n    if (node !== null) {\n      result.push(node);\n    }\n  }\n  return result;\n}\n/**\n * Appends the node before the first child of the parent node\n * @param parent A parent node\n * @param node Node that needs to be appended\n */\nfunction $insertFirst(parent, node) {\n  $getChildCaret(parent, 'next').insert(node);\n}\nlet NEEDS_MANUAL_ZOOM = IS_FIREFOX || !CAN_USE_DOM ? false : undefined;\nfunction needsManualZoom() {\n  if (NEEDS_MANUAL_ZOOM === undefined) {\n    // If the browser implements standardized CSS zoom, then the client rect\n    // will be wider after zoom is applied\n    // https://chromestatus.com/feature/5198254868529152\n    // https://github.com/facebook/lexical/issues/6863\n    const div = document.createElement('div');\n    div.style.cssText = 'position: absolute; opacity: 0; width: 100px; left: -1000px;';\n    document.body.appendChild(div);\n    const noZoom = div.getBoundingClientRect();\n    div.style.setProperty('zoom', '2');\n    NEEDS_MANUAL_ZOOM = div.getBoundingClientRect().width === noZoom.width;\n    document.body.removeChild(div);\n  }\n  return NEEDS_MANUAL_ZOOM;\n}\n\n/**\n * Calculates the zoom level of an element as a result of using\n * css zoom property. For browsers that implement standardized CSS\n * zoom (Firefox, Chrome >= 128), this will always return 1.\n * @param element\n */\nfunction calculateZoomLevel(element) {\n  let zoom = 1;\n  if (needsManualZoom()) {\n    while (element) {\n      zoom *= Number(window.getComputedStyle(element).getPropertyValue('zoom'));\n      element = element.parentElement;\n    }\n  }\n  return zoom;\n}\n\n/**\n * Checks if the editor is a nested editor created by LexicalNestedComposer\n */\nfunction $isEditorIsNestedEditor(editor) {\n  return editor._parentEditor !== null;\n}\n\n/**\n * A depth first last-to-first traversal of root that stops at each node that matches\n * $predicate and ensures that its parent is root. This is typically used to discard\n * invalid or unsupported wrapping nodes. For example, a TableNode must only have\n * TableRowNode as children, but an importer might add invalid nodes based on\n * caption, tbody, thead, etc. and this will unwrap and discard those.\n *\n * @param root The root to start the traversal\n * @param $predicate Should return true for nodes that are permitted to be children of root\n * @returns true if this unwrapped or removed any nodes\n */\nfunction $unwrapAndFilterDescendants(root, $predicate) {\n  return $unwrapAndFilterDescendantsImpl(root, $predicate, null);\n}\nfunction $unwrapAndFilterDescendantsImpl(root, $predicate, $onSuccess) {\n  let didMutate = false;\n  for (const node of $lastToFirstIterator(root)) {\n    if ($predicate(node)) {\n      if ($onSuccess !== null) {\n        $onSuccess(node);\n      }\n      continue;\n    }\n    didMutate = true;\n    if ($isElementNode(node)) {\n      $unwrapAndFilterDescendantsImpl(node, $predicate, $onSuccess || (child => node.insertAfter(child)));\n    }\n    node.remove();\n  }\n  return didMutate;\n}\n\n/**\n * A depth first traversal of the children array that stops at and collects\n * each node that `$predicate` matches. This is typically used to discard\n * invalid or unsupported wrapping nodes on a children array in the `after`\n * of an {@link lexical!DOMConversionOutput}. For example, a TableNode must only have\n * TableRowNode as children, but an importer might add invalid nodes based on\n * caption, tbody, thead, etc. and this will unwrap and discard those.\n *\n * This function is read-only and performs no mutation operations, which makes\n * it suitable for import and export purposes but likely not for any in-place\n * mutation. You should use {@link $unwrapAndFilterDescendants} for in-place\n * mutations such as node transforms.\n *\n * @param children The children to traverse\n * @param $predicate Should return true for nodes that are permitted to be children of root\n * @returns The children or their descendants that match $predicate\n */\n\nfunction $descendantsMatching(children, $predicate) {\n  const result = [];\n  const stack = Array.from(children).reverse();\n  for (let child = stack.pop(); child !== undefined; child = stack.pop()) {\n    if ($predicate(child)) {\n      result.push(child);\n    } else if ($isElementNode(child)) {\n      for (const grandchild of $lastToFirstIterator(child)) {\n        stack.push(grandchild);\n      }\n    }\n  }\n  return result;\n}\n\n/**\n * Return an iterator that yields each child of node from first to last, taking\n * care to preserve the next sibling before yielding the value in case the caller\n * removes the yielded node.\n *\n * @param node The node whose children to iterate\n * @returns An iterator of the node's children\n */\nfunction $firstToLastIterator(node) {\n  return $childIterator($getChildCaret(node, 'next'));\n}\n\n/**\n * Return an iterator that yields each child of node from last to first, taking\n * care to preserve the previous sibling before yielding the value in case the caller\n * removes the yielded node.\n *\n * @param node The node whose children to iterate\n * @returns An iterator of the node's children\n */\nfunction $lastToFirstIterator(node) {\n  return $childIterator($getChildCaret(node, 'previous'));\n}\nfunction $childIterator(startCaret) {\n  const seen = new Set() ;\n  return makeStepwiseIterator({\n    hasNext: $isSiblingCaret,\n    initial: startCaret.getAdjacentCaret(),\n    map: caret => {\n      const origin = caret.origin.getLatest();\n      if (seen !== null) {\n        const key = origin.getKey();\n        if (!!seen.has(key)) {\n          formatDevErrorMessage(`$childIterator: Cycle detected, node with key ${String(key)} has already been traversed`);\n        }\n        seen.add(key);\n      }\n      return origin;\n    },\n    step: caret => caret.getAdjacentCaret()\n  });\n}\n\n/**\n * Replace this node with its children\n *\n * @param node The ElementNode to unwrap and remove\n */\nfunction $unwrapNode(node) {\n  $rewindSiblingCaret($getSiblingCaret(node, 'next')).splice(1, node.getChildren());\n}\n\n/**\n * Returns the Node sibling when this exists, otherwise the closest parent sibling. For example\n * R -> P -> T1, T2\n *   -> P2\n * returns T2 for node T1, P2 for node T2, and null for node P2.\n * @param node LexicalNode.\n * @returns An array (tuple) containing the found Lexical node and the depth difference, or null, if this node doesn't exist.\n */\nfunction $getAdjacentSiblingOrParentSiblingCaret(startCaret, rootMode = 'root') {\n  let depthDiff = 0;\n  let caret = startCaret;\n  let nextCaret = $getAdjacentChildCaret(caret);\n  while (nextCaret === null) {\n    depthDiff--;\n    nextCaret = caret.getParentCaret(rootMode);\n    if (!nextCaret) {\n      return null;\n    }\n    caret = nextCaret;\n    nextCaret = $getAdjacentChildCaret(caret);\n  }\n  return nextCaret && [nextCaret, depthDiff];\n}\n\n/**\n * A wrapper that creates bound functions and methods for the\n * StateConfig to save some boilerplate when defining methods\n * or exporting only the accessors from your modules rather\n * than exposing the StateConfig directly.\n */\n\n/**\n * EXPERIMENTAL\n *\n * A convenience interface for working with {@link $getState} and\n * {@link $setState}.\n *\n * @param stateConfig The stateConfig to wrap with convenience functionality\n * @returns a StateWrapper\n */\nfunction makeStateWrapper(stateConfig) {\n  const $get = node => $getState(node, stateConfig);\n  const $set = (node, valueOrUpdater) => $setState(node, stateConfig, valueOrUpdater);\n  return {\n    $get,\n    $set,\n    accessors: [$get, $set],\n    makeGetterMethod: () => function $getter() {\n      return $get(this);\n    },\n    makeSetterMethod: () => function $setter(valueOrUpdater) {\n      return $set(this, valueOrUpdater);\n    },\n    stateConfig\n  };\n}\n\nexport { $descendantsMatching, $dfs, $dfsIterator, $filter, $findMatchingParent, $firstToLastIterator, $getAdjacentCaret, $getAdjacentSiblingOrParentSiblingCaret, $getDepth, $getNearestBlockElementAncestorOrThrow, $getNearestNodeOfType, $getNextRightPreorderNode, $getNextSiblingOrParentSibling, $insertFirst, $insertNodeToNearestRoot, $insertNodeToNearestRootAtCaret, $isEditorIsNestedEditor, $lastToFirstIterator, $restoreEditorState, $reverseDfs, $reverseDfsIterator, $unwrapAndFilterDescendants, $unwrapNode, $wrapNodeInElement, CAN_USE_BEFORE_INPUT, CAN_USE_DOM, IS_ANDROID, IS_ANDROID_CHROME, IS_APPLE, IS_APPLE_WEBKIT, IS_CHROME, IS_FIREFOX, IS_IOS, IS_SAFARI, addClassNamesToElement, calculateZoomLevel, isMimeType, makeStateWrapper, markSelection, mediaFileReader, mergeRegister, objectKlassEquals, mlcPositionNodeOnRange as positionNodeOnRange, registerNestedElementResolver, removeClassNamesFromElement, selectionAlwaysOnDisplay };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}