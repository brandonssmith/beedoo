{"ast":null,"code":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport { $sliceSelectedTextNodeContent } from '@lexical/selection';\nimport { isHTMLElement, isBlockDomNode } from '@lexical/utils';\nimport { $getRoot, $isElementNode, $cloneWithProperties, $isTextNode, getRegisteredNode, isDocumentFragment, $isRootOrShadowRoot, $isBlockElementNode, $createLineBreakNode, ArtificialNode__DO_NOT_USE, isInlineDomNode, $createParagraphNode } from 'lexical';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/**\n * How you parse your html string to get a document is left up to you. In the browser you can use the native\n * DOMParser API to generate a document (see clipboard.ts), but to use in a headless environment you can use JSDom\n * or an equivalent library and pass in the document here.\n */\nfunction $generateNodesFromDOM(editor, dom) {\n  const elements = dom.body ? dom.body.childNodes : [];\n  let lexicalNodes = [];\n  const allArtificialNodes = [];\n  for (let i = 0; i < elements.length; i++) {\n    const element = elements[i];\n    if (!IGNORE_TAGS.has(element.nodeName)) {\n      const lexicalNode = $createNodesFromDOM(element, editor, allArtificialNodes, false);\n      if (lexicalNode !== null) {\n        lexicalNodes = lexicalNodes.concat(lexicalNode);\n      }\n    }\n  }\n  $unwrapArtificialNodes(allArtificialNodes);\n  return lexicalNodes;\n}\nfunction $generateHtmlFromNodes(editor, selection) {\n  if (typeof document === 'undefined' || typeof window === 'undefined' && typeof global.window === 'undefined') {\n    throw new Error('To use $generateHtmlFromNodes in headless mode please initialize a headless browser implementation such as JSDom before calling this function.');\n  }\n  const container = document.createElement('div');\n  const root = $getRoot();\n  const topLevelChildren = root.getChildren();\n  for (let i = 0; i < topLevelChildren.length; i++) {\n    const topLevelNode = topLevelChildren[i];\n    $appendNodesToHTML(editor, topLevelNode, container, selection);\n  }\n  return container.innerHTML;\n}\nfunction $appendNodesToHTML(editor, currentNode, parentElement, selection = null) {\n  let shouldInclude = selection !== null ? currentNode.isSelected(selection) : true;\n  const shouldExclude = $isElementNode(currentNode) && currentNode.excludeFromCopy('html');\n  let target = currentNode;\n  if (selection !== null) {\n    let clone = $cloneWithProperties(currentNode);\n    clone = $isTextNode(clone) && selection !== null ? $sliceSelectedTextNodeContent(selection, clone) : clone;\n    target = clone;\n  }\n  const children = $isElementNode(target) ? target.getChildren() : [];\n  const registeredNode = getRegisteredNode(editor, target.getType());\n  let exportOutput;\n\n  // Use HTMLConfig overrides, if available.\n  if (registeredNode && registeredNode.exportDOM !== undefined) {\n    exportOutput = registeredNode.exportDOM(editor, target);\n  } else {\n    exportOutput = target.exportDOM(editor);\n  }\n  const {\n    element,\n    after\n  } = exportOutput;\n  if (!element) {\n    return false;\n  }\n  const fragment = document.createDocumentFragment();\n  for (let i = 0; i < children.length; i++) {\n    const childNode = children[i];\n    const shouldIncludeChild = $appendNodesToHTML(editor, childNode, fragment, selection);\n    if (!shouldInclude && $isElementNode(currentNode) && shouldIncludeChild && currentNode.extractWithChild(childNode, selection, 'html')) {\n      shouldInclude = true;\n    }\n  }\n  if (shouldInclude && !shouldExclude) {\n    if (isHTMLElement(element) || isDocumentFragment(element)) {\n      element.append(fragment);\n    }\n    parentElement.append(element);\n    if (after) {\n      const newElement = after.call(target, element);\n      if (newElement) {\n        if (isDocumentFragment(element)) {\n          element.replaceChildren(newElement);\n        } else {\n          element.replaceWith(newElement);\n        }\n      }\n    }\n  } else {\n    parentElement.append(fragment);\n  }\n  return shouldInclude;\n}\nfunction getConversionFunction(domNode, editor) {\n  const {\n    nodeName\n  } = domNode;\n  const cachedConversions = editor._htmlConversions.get(nodeName.toLowerCase());\n  let currentConversion = null;\n  if (cachedConversions !== undefined) {\n    for (const cachedConversion of cachedConversions) {\n      const domConversion = cachedConversion(domNode);\n      if (domConversion !== null && (currentConversion === null ||\n      // Given equal priority, prefer the last registered importer\n      // which is typically an application custom node or HTMLConfig['import']\n      (currentConversion.priority || 0) <= (domConversion.priority || 0))) {\n        currentConversion = domConversion;\n      }\n    }\n  }\n  return currentConversion !== null ? currentConversion.conversion : null;\n}\nconst IGNORE_TAGS = new Set(['STYLE', 'SCRIPT']);\nfunction $createNodesFromDOM(node, editor, allArtificialNodes, hasBlockAncestorLexicalNode, forChildMap = new Map(), parentLexicalNode) {\n  let lexicalNodes = [];\n  if (IGNORE_TAGS.has(node.nodeName)) {\n    return lexicalNodes;\n  }\n  let currentLexicalNode = null;\n  const transformFunction = getConversionFunction(node, editor);\n  const transformOutput = transformFunction ? transformFunction(node) : null;\n  let postTransform = null;\n  if (transformOutput !== null) {\n    postTransform = transformOutput.after;\n    const transformNodes = transformOutput.node;\n    currentLexicalNode = Array.isArray(transformNodes) ? transformNodes[transformNodes.length - 1] : transformNodes;\n    if (currentLexicalNode !== null) {\n      for (const [, forChildFunction] of forChildMap) {\n        currentLexicalNode = forChildFunction(currentLexicalNode, parentLexicalNode);\n        if (!currentLexicalNode) {\n          break;\n        }\n      }\n      if (currentLexicalNode) {\n        lexicalNodes.push(...(Array.isArray(transformNodes) ? transformNodes : [currentLexicalNode]));\n      }\n    }\n    if (transformOutput.forChild != null) {\n      forChildMap.set(node.nodeName, transformOutput.forChild);\n    }\n  }\n\n  // If the DOM node doesn't have a transformer, we don't know what\n  // to do with it but we still need to process any childNodes.\n  const children = node.childNodes;\n  let childLexicalNodes = [];\n  const hasBlockAncestorLexicalNodeForChildren = currentLexicalNode != null && $isRootOrShadowRoot(currentLexicalNode) ? false : currentLexicalNode != null && $isBlockElementNode(currentLexicalNode) || hasBlockAncestorLexicalNode;\n  for (let i = 0; i < children.length; i++) {\n    childLexicalNodes.push(...$createNodesFromDOM(children[i], editor, allArtificialNodes, hasBlockAncestorLexicalNodeForChildren, new Map(forChildMap), currentLexicalNode));\n  }\n  if (postTransform != null) {\n    childLexicalNodes = postTransform(childLexicalNodes);\n  }\n  if (isBlockDomNode(node)) {\n    if (!hasBlockAncestorLexicalNodeForChildren) {\n      childLexicalNodes = wrapContinuousInlines(node, childLexicalNodes, $createParagraphNode);\n    } else {\n      childLexicalNodes = wrapContinuousInlines(node, childLexicalNodes, () => {\n        const artificialNode = new ArtificialNode__DO_NOT_USE();\n        allArtificialNodes.push(artificialNode);\n        return artificialNode;\n      });\n    }\n  }\n  if (currentLexicalNode == null) {\n    if (childLexicalNodes.length > 0) {\n      // If it hasn't been converted to a LexicalNode, we hoist its children\n      // up to the same level as it.\n      lexicalNodes = lexicalNodes.concat(childLexicalNodes);\n    } else {\n      if (isBlockDomNode(node) && isDomNodeBetweenTwoInlineNodes(node)) {\n        // Empty block dom node that hasnt been converted, we replace it with a linebreak if its between inline nodes\n        lexicalNodes = lexicalNodes.concat($createLineBreakNode());\n      }\n    }\n  } else {\n    if ($isElementNode(currentLexicalNode)) {\n      // If the current node is a ElementNode after conversion,\n      // we can append all the children to it.\n      currentLexicalNode.append(...childLexicalNodes);\n    }\n  }\n  return lexicalNodes;\n}\nfunction wrapContinuousInlines(domNode, nodes, createWrapperFn) {\n  const textAlign = domNode.style.textAlign;\n  const out = [];\n  let continuousInlines = [];\n  // wrap contiguous inline child nodes in para\n  for (let i = 0; i < nodes.length; i++) {\n    const node = nodes[i];\n    if ($isBlockElementNode(node)) {\n      if (textAlign && !node.getFormat()) {\n        node.setFormat(textAlign);\n      }\n      out.push(node);\n    } else {\n      continuousInlines.push(node);\n      if (i === nodes.length - 1 || i < nodes.length - 1 && $isBlockElementNode(nodes[i + 1])) {\n        const wrapper = createWrapperFn();\n        wrapper.setFormat(textAlign);\n        wrapper.append(...continuousInlines);\n        out.push(wrapper);\n        continuousInlines = [];\n      }\n    }\n  }\n  return out;\n}\nfunction $unwrapArtificialNodes(allArtificialNodes) {\n  for (const node of allArtificialNodes) {\n    if (node.getNextSibling() instanceof ArtificialNode__DO_NOT_USE) {\n      node.insertAfter($createLineBreakNode());\n    }\n  }\n  // Replace artificial node with it's children\n  for (const node of allArtificialNodes) {\n    const children = node.getChildren();\n    for (const child of children) {\n      node.insertBefore(child);\n    }\n    node.remove();\n  }\n}\nfunction isDomNodeBetweenTwoInlineNodes(node) {\n  if (node.nextSibling == null || node.previousSibling == null) {\n    return false;\n  }\n  return isInlineDomNode(node.nextSibling) && isInlineDomNode(node.previousSibling);\n}\nexport { $generateHtmlFromNodes, $generateNodesFromDOM };","map":{"version":3,"names":["$sliceSelectedTextNodeContent","isHTMLElement","isBlockDomNode","$getRoot","$isElementNode","$cloneWithProperties","$isTextNode","getRegisteredNode","isDocumentFragment","$isRootOrShadowRoot","$isBlockElementNode","$createLineBreakNode","ArtificialNode__DO_NOT_USE","isInlineDomNode","$createParagraphNode","$generateNodesFromDOM","editor","dom","elements","body","childNodes","lexicalNodes","allArtificialNodes","i","length","element","IGNORE_TAGS","has","nodeName","lexicalNode","$createNodesFromDOM","concat","$unwrapArtificialNodes","$generateHtmlFromNodes","selection","document","window","global","Error","container","createElement","root","topLevelChildren","getChildren","topLevelNode","$appendNodesToHTML","innerHTML","currentNode","parentElement","shouldInclude","isSelected","shouldExclude","excludeFromCopy","target","clone","children","registeredNode","getType","exportOutput","exportDOM","undefined","after","fragment","createDocumentFragment","childNode","shouldIncludeChild","extractWithChild","append","newElement","call","replaceChildren","replaceWith","getConversionFunction","domNode","cachedConversions","_htmlConversions","get","toLowerCase","currentConversion","cachedConversion","domConversion","priority","conversion","Set","node","hasBlockAncestorLexicalNode","forChildMap","Map","parentLexicalNode","currentLexicalNode","transformFunction","transformOutput","postTransform","transformNodes","Array","isArray","forChildFunction","push","forChild","set","childLexicalNodes","hasBlockAncestorLexicalNodeForChildren","wrapContinuousInlines","artificialNode","isDomNodeBetweenTwoInlineNodes","nodes","createWrapperFn","textAlign","style","out","continuousInlines","getFormat","setFormat","wrapper","getNextSibling","insertAfter","child","insertBefore","remove","nextSibling","previousSibling"],"sources":["C:/Code/beedoo/node_modules/@lexical/html/LexicalHtml.dev.mjs"],"sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport { $sliceSelectedTextNodeContent } from '@lexical/selection';\nimport { isHTMLElement, isBlockDomNode } from '@lexical/utils';\nimport { $getRoot, $isElementNode, $cloneWithProperties, $isTextNode, getRegisteredNode, isDocumentFragment, $isRootOrShadowRoot, $isBlockElementNode, $createLineBreakNode, ArtificialNode__DO_NOT_USE, isInlineDomNode, $createParagraphNode } from 'lexical';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n/**\n * How you parse your html string to get a document is left up to you. In the browser you can use the native\n * DOMParser API to generate a document (see clipboard.ts), but to use in a headless environment you can use JSDom\n * or an equivalent library and pass in the document here.\n */\nfunction $generateNodesFromDOM(editor, dom) {\n  const elements = dom.body ? dom.body.childNodes : [];\n  let lexicalNodes = [];\n  const allArtificialNodes = [];\n  for (let i = 0; i < elements.length; i++) {\n    const element = elements[i];\n    if (!IGNORE_TAGS.has(element.nodeName)) {\n      const lexicalNode = $createNodesFromDOM(element, editor, allArtificialNodes, false);\n      if (lexicalNode !== null) {\n        lexicalNodes = lexicalNodes.concat(lexicalNode);\n      }\n    }\n  }\n  $unwrapArtificialNodes(allArtificialNodes);\n  return lexicalNodes;\n}\nfunction $generateHtmlFromNodes(editor, selection) {\n  if (typeof document === 'undefined' || typeof window === 'undefined' && typeof global.window === 'undefined') {\n    throw new Error('To use $generateHtmlFromNodes in headless mode please initialize a headless browser implementation such as JSDom before calling this function.');\n  }\n  const container = document.createElement('div');\n  const root = $getRoot();\n  const topLevelChildren = root.getChildren();\n  for (let i = 0; i < topLevelChildren.length; i++) {\n    const topLevelNode = topLevelChildren[i];\n    $appendNodesToHTML(editor, topLevelNode, container, selection);\n  }\n  return container.innerHTML;\n}\nfunction $appendNodesToHTML(editor, currentNode, parentElement, selection = null) {\n  let shouldInclude = selection !== null ? currentNode.isSelected(selection) : true;\n  const shouldExclude = $isElementNode(currentNode) && currentNode.excludeFromCopy('html');\n  let target = currentNode;\n  if (selection !== null) {\n    let clone = $cloneWithProperties(currentNode);\n    clone = $isTextNode(clone) && selection !== null ? $sliceSelectedTextNodeContent(selection, clone) : clone;\n    target = clone;\n  }\n  const children = $isElementNode(target) ? target.getChildren() : [];\n  const registeredNode = getRegisteredNode(editor, target.getType());\n  let exportOutput;\n\n  // Use HTMLConfig overrides, if available.\n  if (registeredNode && registeredNode.exportDOM !== undefined) {\n    exportOutput = registeredNode.exportDOM(editor, target);\n  } else {\n    exportOutput = target.exportDOM(editor);\n  }\n  const {\n    element,\n    after\n  } = exportOutput;\n  if (!element) {\n    return false;\n  }\n  const fragment = document.createDocumentFragment();\n  for (let i = 0; i < children.length; i++) {\n    const childNode = children[i];\n    const shouldIncludeChild = $appendNodesToHTML(editor, childNode, fragment, selection);\n    if (!shouldInclude && $isElementNode(currentNode) && shouldIncludeChild && currentNode.extractWithChild(childNode, selection, 'html')) {\n      shouldInclude = true;\n    }\n  }\n  if (shouldInclude && !shouldExclude) {\n    if (isHTMLElement(element) || isDocumentFragment(element)) {\n      element.append(fragment);\n    }\n    parentElement.append(element);\n    if (after) {\n      const newElement = after.call(target, element);\n      if (newElement) {\n        if (isDocumentFragment(element)) {\n          element.replaceChildren(newElement);\n        } else {\n          element.replaceWith(newElement);\n        }\n      }\n    }\n  } else {\n    parentElement.append(fragment);\n  }\n  return shouldInclude;\n}\nfunction getConversionFunction(domNode, editor) {\n  const {\n    nodeName\n  } = domNode;\n  const cachedConversions = editor._htmlConversions.get(nodeName.toLowerCase());\n  let currentConversion = null;\n  if (cachedConversions !== undefined) {\n    for (const cachedConversion of cachedConversions) {\n      const domConversion = cachedConversion(domNode);\n      if (domConversion !== null && (currentConversion === null ||\n      // Given equal priority, prefer the last registered importer\n      // which is typically an application custom node or HTMLConfig['import']\n      (currentConversion.priority || 0) <= (domConversion.priority || 0))) {\n        currentConversion = domConversion;\n      }\n    }\n  }\n  return currentConversion !== null ? currentConversion.conversion : null;\n}\nconst IGNORE_TAGS = new Set(['STYLE', 'SCRIPT']);\nfunction $createNodesFromDOM(node, editor, allArtificialNodes, hasBlockAncestorLexicalNode, forChildMap = new Map(), parentLexicalNode) {\n  let lexicalNodes = [];\n  if (IGNORE_TAGS.has(node.nodeName)) {\n    return lexicalNodes;\n  }\n  let currentLexicalNode = null;\n  const transformFunction = getConversionFunction(node, editor);\n  const transformOutput = transformFunction ? transformFunction(node) : null;\n  let postTransform = null;\n  if (transformOutput !== null) {\n    postTransform = transformOutput.after;\n    const transformNodes = transformOutput.node;\n    currentLexicalNode = Array.isArray(transformNodes) ? transformNodes[transformNodes.length - 1] : transformNodes;\n    if (currentLexicalNode !== null) {\n      for (const [, forChildFunction] of forChildMap) {\n        currentLexicalNode = forChildFunction(currentLexicalNode, parentLexicalNode);\n        if (!currentLexicalNode) {\n          break;\n        }\n      }\n      if (currentLexicalNode) {\n        lexicalNodes.push(...(Array.isArray(transformNodes) ? transformNodes : [currentLexicalNode]));\n      }\n    }\n    if (transformOutput.forChild != null) {\n      forChildMap.set(node.nodeName, transformOutput.forChild);\n    }\n  }\n\n  // If the DOM node doesn't have a transformer, we don't know what\n  // to do with it but we still need to process any childNodes.\n  const children = node.childNodes;\n  let childLexicalNodes = [];\n  const hasBlockAncestorLexicalNodeForChildren = currentLexicalNode != null && $isRootOrShadowRoot(currentLexicalNode) ? false : currentLexicalNode != null && $isBlockElementNode(currentLexicalNode) || hasBlockAncestorLexicalNode;\n  for (let i = 0; i < children.length; i++) {\n    childLexicalNodes.push(...$createNodesFromDOM(children[i], editor, allArtificialNodes, hasBlockAncestorLexicalNodeForChildren, new Map(forChildMap), currentLexicalNode));\n  }\n  if (postTransform != null) {\n    childLexicalNodes = postTransform(childLexicalNodes);\n  }\n  if (isBlockDomNode(node)) {\n    if (!hasBlockAncestorLexicalNodeForChildren) {\n      childLexicalNodes = wrapContinuousInlines(node, childLexicalNodes, $createParagraphNode);\n    } else {\n      childLexicalNodes = wrapContinuousInlines(node, childLexicalNodes, () => {\n        const artificialNode = new ArtificialNode__DO_NOT_USE();\n        allArtificialNodes.push(artificialNode);\n        return artificialNode;\n      });\n    }\n  }\n  if (currentLexicalNode == null) {\n    if (childLexicalNodes.length > 0) {\n      // If it hasn't been converted to a LexicalNode, we hoist its children\n      // up to the same level as it.\n      lexicalNodes = lexicalNodes.concat(childLexicalNodes);\n    } else {\n      if (isBlockDomNode(node) && isDomNodeBetweenTwoInlineNodes(node)) {\n        // Empty block dom node that hasnt been converted, we replace it with a linebreak if its between inline nodes\n        lexicalNodes = lexicalNodes.concat($createLineBreakNode());\n      }\n    }\n  } else {\n    if ($isElementNode(currentLexicalNode)) {\n      // If the current node is a ElementNode after conversion,\n      // we can append all the children to it.\n      currentLexicalNode.append(...childLexicalNodes);\n    }\n  }\n  return lexicalNodes;\n}\nfunction wrapContinuousInlines(domNode, nodes, createWrapperFn) {\n  const textAlign = domNode.style.textAlign;\n  const out = [];\n  let continuousInlines = [];\n  // wrap contiguous inline child nodes in para\n  for (let i = 0; i < nodes.length; i++) {\n    const node = nodes[i];\n    if ($isBlockElementNode(node)) {\n      if (textAlign && !node.getFormat()) {\n        node.setFormat(textAlign);\n      }\n      out.push(node);\n    } else {\n      continuousInlines.push(node);\n      if (i === nodes.length - 1 || i < nodes.length - 1 && $isBlockElementNode(nodes[i + 1])) {\n        const wrapper = createWrapperFn();\n        wrapper.setFormat(textAlign);\n        wrapper.append(...continuousInlines);\n        out.push(wrapper);\n        continuousInlines = [];\n      }\n    }\n  }\n  return out;\n}\nfunction $unwrapArtificialNodes(allArtificialNodes) {\n  for (const node of allArtificialNodes) {\n    if (node.getNextSibling() instanceof ArtificialNode__DO_NOT_USE) {\n      node.insertAfter($createLineBreakNode());\n    }\n  }\n  // Replace artificial node with it's children\n  for (const node of allArtificialNodes) {\n    const children = node.getChildren();\n    for (const child of children) {\n      node.insertBefore(child);\n    }\n    node.remove();\n  }\n}\nfunction isDomNodeBetweenTwoInlineNodes(node) {\n  if (node.nextSibling == null || node.previousSibling == null) {\n    return false;\n  }\n  return isInlineDomNode(node.nextSibling) && isInlineDomNode(node.previousSibling);\n}\n\nexport { $generateHtmlFromNodes, $generateNodesFromDOM };\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,SAASA,6BAA6B,QAAQ,oBAAoB;AAClE,SAASC,aAAa,EAAEC,cAAc,QAAQ,gBAAgB;AAC9D,SAASC,QAAQ,EAAEC,cAAc,EAAEC,oBAAoB,EAAEC,WAAW,EAAEC,iBAAiB,EAAEC,kBAAkB,EAAEC,mBAAmB,EAAEC,mBAAmB,EAAEC,oBAAoB,EAAEC,0BAA0B,EAAEC,eAAe,EAAEC,oBAAoB,QAAQ,SAAS;;AAE/P;AACA;AACA;AACA;AACA;AACA;AACA;;AAGA;AACA;AACA;AACA;AACA;AACA,SAASC,qBAAqBA,CAACC,MAAM,EAAEC,GAAG,EAAE;EAC1C,MAAMC,QAAQ,GAAGD,GAAG,CAACE,IAAI,GAAGF,GAAG,CAACE,IAAI,CAACC,UAAU,GAAG,EAAE;EACpD,IAAIC,YAAY,GAAG,EAAE;EACrB,MAAMC,kBAAkB,GAAG,EAAE;EAC7B,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGL,QAAQ,CAACM,MAAM,EAAED,CAAC,EAAE,EAAE;IACxC,MAAME,OAAO,GAAGP,QAAQ,CAACK,CAAC,CAAC;IAC3B,IAAI,CAACG,WAAW,CAACC,GAAG,CAACF,OAAO,CAACG,QAAQ,CAAC,EAAE;MACtC,MAAMC,WAAW,GAAGC,mBAAmB,CAACL,OAAO,EAAET,MAAM,EAAEM,kBAAkB,EAAE,KAAK,CAAC;MACnF,IAAIO,WAAW,KAAK,IAAI,EAAE;QACxBR,YAAY,GAAGA,YAAY,CAACU,MAAM,CAACF,WAAW,CAAC;MACjD;IACF;EACF;EACAG,sBAAsB,CAACV,kBAAkB,CAAC;EAC1C,OAAOD,YAAY;AACrB;AACA,SAASY,sBAAsBA,CAACjB,MAAM,EAAEkB,SAAS,EAAE;EACjD,IAAI,OAAOC,QAAQ,KAAK,WAAW,IAAI,OAAOC,MAAM,KAAK,WAAW,IAAI,OAAOC,MAAM,CAACD,MAAM,KAAK,WAAW,EAAE;IAC5G,MAAM,IAAIE,KAAK,CAAC,gJAAgJ,CAAC;EACnK;EACA,MAAMC,SAAS,GAAGJ,QAAQ,CAACK,aAAa,CAAC,KAAK,CAAC;EAC/C,MAAMC,IAAI,GAAGtC,QAAQ,CAAC,CAAC;EACvB,MAAMuC,gBAAgB,GAAGD,IAAI,CAACE,WAAW,CAAC,CAAC;EAC3C,KAAK,IAAIpB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGmB,gBAAgB,CAAClB,MAAM,EAAED,CAAC,EAAE,EAAE;IAChD,MAAMqB,YAAY,GAAGF,gBAAgB,CAACnB,CAAC,CAAC;IACxCsB,kBAAkB,CAAC7B,MAAM,EAAE4B,YAAY,EAAEL,SAAS,EAAEL,SAAS,CAAC;EAChE;EACA,OAAOK,SAAS,CAACO,SAAS;AAC5B;AACA,SAASD,kBAAkBA,CAAC7B,MAAM,EAAE+B,WAAW,EAAEC,aAAa,EAAEd,SAAS,GAAG,IAAI,EAAE;EAChF,IAAIe,aAAa,GAAGf,SAAS,KAAK,IAAI,GAAGa,WAAW,CAACG,UAAU,CAAChB,SAAS,CAAC,GAAG,IAAI;EACjF,MAAMiB,aAAa,GAAG/C,cAAc,CAAC2C,WAAW,CAAC,IAAIA,WAAW,CAACK,eAAe,CAAC,MAAM,CAAC;EACxF,IAAIC,MAAM,GAAGN,WAAW;EACxB,IAAIb,SAAS,KAAK,IAAI,EAAE;IACtB,IAAIoB,KAAK,GAAGjD,oBAAoB,CAAC0C,WAAW,CAAC;IAC7CO,KAAK,GAAGhD,WAAW,CAACgD,KAAK,CAAC,IAAIpB,SAAS,KAAK,IAAI,GAAGlC,6BAA6B,CAACkC,SAAS,EAAEoB,KAAK,CAAC,GAAGA,KAAK;IAC1GD,MAAM,GAAGC,KAAK;EAChB;EACA,MAAMC,QAAQ,GAAGnD,cAAc,CAACiD,MAAM,CAAC,GAAGA,MAAM,CAACV,WAAW,CAAC,CAAC,GAAG,EAAE;EACnE,MAAMa,cAAc,GAAGjD,iBAAiB,CAACS,MAAM,EAAEqC,MAAM,CAACI,OAAO,CAAC,CAAC,CAAC;EAClE,IAAIC,YAAY;;EAEhB;EACA,IAAIF,cAAc,IAAIA,cAAc,CAACG,SAAS,KAAKC,SAAS,EAAE;IAC5DF,YAAY,GAAGF,cAAc,CAACG,SAAS,CAAC3C,MAAM,EAAEqC,MAAM,CAAC;EACzD,CAAC,MAAM;IACLK,YAAY,GAAGL,MAAM,CAACM,SAAS,CAAC3C,MAAM,CAAC;EACzC;EACA,MAAM;IACJS,OAAO;IACPoC;EACF,CAAC,GAAGH,YAAY;EAChB,IAAI,CAACjC,OAAO,EAAE;IACZ,OAAO,KAAK;EACd;EACA,MAAMqC,QAAQ,GAAG3B,QAAQ,CAAC4B,sBAAsB,CAAC,CAAC;EAClD,KAAK,IAAIxC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGgC,QAAQ,CAAC/B,MAAM,EAAED,CAAC,EAAE,EAAE;IACxC,MAAMyC,SAAS,GAAGT,QAAQ,CAAChC,CAAC,CAAC;IAC7B,MAAM0C,kBAAkB,GAAGpB,kBAAkB,CAAC7B,MAAM,EAAEgD,SAAS,EAAEF,QAAQ,EAAE5B,SAAS,CAAC;IACrF,IAAI,CAACe,aAAa,IAAI7C,cAAc,CAAC2C,WAAW,CAAC,IAAIkB,kBAAkB,IAAIlB,WAAW,CAACmB,gBAAgB,CAACF,SAAS,EAAE9B,SAAS,EAAE,MAAM,CAAC,EAAE;MACrIe,aAAa,GAAG,IAAI;IACtB;EACF;EACA,IAAIA,aAAa,IAAI,CAACE,aAAa,EAAE;IACnC,IAAIlD,aAAa,CAACwB,OAAO,CAAC,IAAIjB,kBAAkB,CAACiB,OAAO,CAAC,EAAE;MACzDA,OAAO,CAAC0C,MAAM,CAACL,QAAQ,CAAC;IAC1B;IACAd,aAAa,CAACmB,MAAM,CAAC1C,OAAO,CAAC;IAC7B,IAAIoC,KAAK,EAAE;MACT,MAAMO,UAAU,GAAGP,KAAK,CAACQ,IAAI,CAAChB,MAAM,EAAE5B,OAAO,CAAC;MAC9C,IAAI2C,UAAU,EAAE;QACd,IAAI5D,kBAAkB,CAACiB,OAAO,CAAC,EAAE;UAC/BA,OAAO,CAAC6C,eAAe,CAACF,UAAU,CAAC;QACrC,CAAC,MAAM;UACL3C,OAAO,CAAC8C,WAAW,CAACH,UAAU,CAAC;QACjC;MACF;IACF;EACF,CAAC,MAAM;IACLpB,aAAa,CAACmB,MAAM,CAACL,QAAQ,CAAC;EAChC;EACA,OAAOb,aAAa;AACtB;AACA,SAASuB,qBAAqBA,CAACC,OAAO,EAAEzD,MAAM,EAAE;EAC9C,MAAM;IACJY;EACF,CAAC,GAAG6C,OAAO;EACX,MAAMC,iBAAiB,GAAG1D,MAAM,CAAC2D,gBAAgB,CAACC,GAAG,CAAChD,QAAQ,CAACiD,WAAW,CAAC,CAAC,CAAC;EAC7E,IAAIC,iBAAiB,GAAG,IAAI;EAC5B,IAAIJ,iBAAiB,KAAKd,SAAS,EAAE;IACnC,KAAK,MAAMmB,gBAAgB,IAAIL,iBAAiB,EAAE;MAChD,MAAMM,aAAa,GAAGD,gBAAgB,CAACN,OAAO,CAAC;MAC/C,IAAIO,aAAa,KAAK,IAAI,KAAKF,iBAAiB,KAAK,IAAI;MACzD;MACA;MACA,CAACA,iBAAiB,CAACG,QAAQ,IAAI,CAAC,MAAMD,aAAa,CAACC,QAAQ,IAAI,CAAC,CAAC,CAAC,EAAE;QACnEH,iBAAiB,GAAGE,aAAa;MACnC;IACF;EACF;EACA,OAAOF,iBAAiB,KAAK,IAAI,GAAGA,iBAAiB,CAACI,UAAU,GAAG,IAAI;AACzE;AACA,MAAMxD,WAAW,GAAG,IAAIyD,GAAG,CAAC,CAAC,OAAO,EAAE,QAAQ,CAAC,CAAC;AAChD,SAASrD,mBAAmBA,CAACsD,IAAI,EAAEpE,MAAM,EAAEM,kBAAkB,EAAE+D,2BAA2B,EAAEC,WAAW,GAAG,IAAIC,GAAG,CAAC,CAAC,EAAEC,iBAAiB,EAAE;EACtI,IAAInE,YAAY,GAAG,EAAE;EACrB,IAAIK,WAAW,CAACC,GAAG,CAACyD,IAAI,CAACxD,QAAQ,CAAC,EAAE;IAClC,OAAOP,YAAY;EACrB;EACA,IAAIoE,kBAAkB,GAAG,IAAI;EAC7B,MAAMC,iBAAiB,GAAGlB,qBAAqB,CAACY,IAAI,EAAEpE,MAAM,CAAC;EAC7D,MAAM2E,eAAe,GAAGD,iBAAiB,GAAGA,iBAAiB,CAACN,IAAI,CAAC,GAAG,IAAI;EAC1E,IAAIQ,aAAa,GAAG,IAAI;EACxB,IAAID,eAAe,KAAK,IAAI,EAAE;IAC5BC,aAAa,GAAGD,eAAe,CAAC9B,KAAK;IACrC,MAAMgC,cAAc,GAAGF,eAAe,CAACP,IAAI;IAC3CK,kBAAkB,GAAGK,KAAK,CAACC,OAAO,CAACF,cAAc,CAAC,GAAGA,cAAc,CAACA,cAAc,CAACrE,MAAM,GAAG,CAAC,CAAC,GAAGqE,cAAc;IAC/G,IAAIJ,kBAAkB,KAAK,IAAI,EAAE;MAC/B,KAAK,MAAM,GAAGO,gBAAgB,CAAC,IAAIV,WAAW,EAAE;QAC9CG,kBAAkB,GAAGO,gBAAgB,CAACP,kBAAkB,EAAED,iBAAiB,CAAC;QAC5E,IAAI,CAACC,kBAAkB,EAAE;UACvB;QACF;MACF;MACA,IAAIA,kBAAkB,EAAE;QACtBpE,YAAY,CAAC4E,IAAI,CAAC,IAAIH,KAAK,CAACC,OAAO,CAACF,cAAc,CAAC,GAAGA,cAAc,GAAG,CAACJ,kBAAkB,CAAC,CAAC,CAAC;MAC/F;IACF;IACA,IAAIE,eAAe,CAACO,QAAQ,IAAI,IAAI,EAAE;MACpCZ,WAAW,CAACa,GAAG,CAACf,IAAI,CAACxD,QAAQ,EAAE+D,eAAe,CAACO,QAAQ,CAAC;IAC1D;EACF;;EAEA;EACA;EACA,MAAM3C,QAAQ,GAAG6B,IAAI,CAAChE,UAAU;EAChC,IAAIgF,iBAAiB,GAAG,EAAE;EAC1B,MAAMC,sCAAsC,GAAGZ,kBAAkB,IAAI,IAAI,IAAIhF,mBAAmB,CAACgF,kBAAkB,CAAC,GAAG,KAAK,GAAGA,kBAAkB,IAAI,IAAI,IAAI/E,mBAAmB,CAAC+E,kBAAkB,CAAC,IAAIJ,2BAA2B;EACnO,KAAK,IAAI9D,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGgC,QAAQ,CAAC/B,MAAM,EAAED,CAAC,EAAE,EAAE;IACxC6E,iBAAiB,CAACH,IAAI,CAAC,GAAGnE,mBAAmB,CAACyB,QAAQ,CAAChC,CAAC,CAAC,EAAEP,MAAM,EAAEM,kBAAkB,EAAE+E,sCAAsC,EAAE,IAAId,GAAG,CAACD,WAAW,CAAC,EAAEG,kBAAkB,CAAC,CAAC;EAC3K;EACA,IAAIG,aAAa,IAAI,IAAI,EAAE;IACzBQ,iBAAiB,GAAGR,aAAa,CAACQ,iBAAiB,CAAC;EACtD;EACA,IAAIlG,cAAc,CAACkF,IAAI,CAAC,EAAE;IACxB,IAAI,CAACiB,sCAAsC,EAAE;MAC3CD,iBAAiB,GAAGE,qBAAqB,CAAClB,IAAI,EAAEgB,iBAAiB,EAAEtF,oBAAoB,CAAC;IAC1F,CAAC,MAAM;MACLsF,iBAAiB,GAAGE,qBAAqB,CAAClB,IAAI,EAAEgB,iBAAiB,EAAE,MAAM;QACvE,MAAMG,cAAc,GAAG,IAAI3F,0BAA0B,CAAC,CAAC;QACvDU,kBAAkB,CAAC2E,IAAI,CAACM,cAAc,CAAC;QACvC,OAAOA,cAAc;MACvB,CAAC,CAAC;IACJ;EACF;EACA,IAAId,kBAAkB,IAAI,IAAI,EAAE;IAC9B,IAAIW,iBAAiB,CAAC5E,MAAM,GAAG,CAAC,EAAE;MAChC;MACA;MACAH,YAAY,GAAGA,YAAY,CAACU,MAAM,CAACqE,iBAAiB,CAAC;IACvD,CAAC,MAAM;MACL,IAAIlG,cAAc,CAACkF,IAAI,CAAC,IAAIoB,8BAA8B,CAACpB,IAAI,CAAC,EAAE;QAChE;QACA/D,YAAY,GAAGA,YAAY,CAACU,MAAM,CAACpB,oBAAoB,CAAC,CAAC,CAAC;MAC5D;IACF;EACF,CAAC,MAAM;IACL,IAAIP,cAAc,CAACqF,kBAAkB,CAAC,EAAE;MACtC;MACA;MACAA,kBAAkB,CAACtB,MAAM,CAAC,GAAGiC,iBAAiB,CAAC;IACjD;EACF;EACA,OAAO/E,YAAY;AACrB;AACA,SAASiF,qBAAqBA,CAAC7B,OAAO,EAAEgC,KAAK,EAAEC,eAAe,EAAE;EAC9D,MAAMC,SAAS,GAAGlC,OAAO,CAACmC,KAAK,CAACD,SAAS;EACzC,MAAME,GAAG,GAAG,EAAE;EACd,IAAIC,iBAAiB,GAAG,EAAE;EAC1B;EACA,KAAK,IAAIvF,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGkF,KAAK,CAACjF,MAAM,EAAED,CAAC,EAAE,EAAE;IACrC,MAAM6D,IAAI,GAAGqB,KAAK,CAAClF,CAAC,CAAC;IACrB,IAAIb,mBAAmB,CAAC0E,IAAI,CAAC,EAAE;MAC7B,IAAIuB,SAAS,IAAI,CAACvB,IAAI,CAAC2B,SAAS,CAAC,CAAC,EAAE;QAClC3B,IAAI,CAAC4B,SAAS,CAACL,SAAS,CAAC;MAC3B;MACAE,GAAG,CAACZ,IAAI,CAACb,IAAI,CAAC;IAChB,CAAC,MAAM;MACL0B,iBAAiB,CAACb,IAAI,CAACb,IAAI,CAAC;MAC5B,IAAI7D,CAAC,KAAKkF,KAAK,CAACjF,MAAM,GAAG,CAAC,IAAID,CAAC,GAAGkF,KAAK,CAACjF,MAAM,GAAG,CAAC,IAAId,mBAAmB,CAAC+F,KAAK,CAAClF,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE;QACvF,MAAM0F,OAAO,GAAGP,eAAe,CAAC,CAAC;QACjCO,OAAO,CAACD,SAAS,CAACL,SAAS,CAAC;QAC5BM,OAAO,CAAC9C,MAAM,CAAC,GAAG2C,iBAAiB,CAAC;QACpCD,GAAG,CAACZ,IAAI,CAACgB,OAAO,CAAC;QACjBH,iBAAiB,GAAG,EAAE;MACxB;IACF;EACF;EACA,OAAOD,GAAG;AACZ;AACA,SAAS7E,sBAAsBA,CAACV,kBAAkB,EAAE;EAClD,KAAK,MAAM8D,IAAI,IAAI9D,kBAAkB,EAAE;IACrC,IAAI8D,IAAI,CAAC8B,cAAc,CAAC,CAAC,YAAYtG,0BAA0B,EAAE;MAC/DwE,IAAI,CAAC+B,WAAW,CAACxG,oBAAoB,CAAC,CAAC,CAAC;IAC1C;EACF;EACA;EACA,KAAK,MAAMyE,IAAI,IAAI9D,kBAAkB,EAAE;IACrC,MAAMiC,QAAQ,GAAG6B,IAAI,CAACzC,WAAW,CAAC,CAAC;IACnC,KAAK,MAAMyE,KAAK,IAAI7D,QAAQ,EAAE;MAC5B6B,IAAI,CAACiC,YAAY,CAACD,KAAK,CAAC;IAC1B;IACAhC,IAAI,CAACkC,MAAM,CAAC,CAAC;EACf;AACF;AACA,SAASd,8BAA8BA,CAACpB,IAAI,EAAE;EAC5C,IAAIA,IAAI,CAACmC,WAAW,IAAI,IAAI,IAAInC,IAAI,CAACoC,eAAe,IAAI,IAAI,EAAE;IAC5D,OAAO,KAAK;EACd;EACA,OAAO3G,eAAe,CAACuE,IAAI,CAACmC,WAAW,CAAC,IAAI1G,eAAe,CAACuE,IAAI,CAACoC,eAAe,CAAC;AACnF;AAEA,SAASvF,sBAAsB,EAAElB,qBAAqB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}